- [运算符优先级](#运算符优先级)
- [typeof](#typeof)
  - [描述](#描述)
  - [示例](#示例)
    - [typeof null === "object";](#typeof-null--object)
    - [使用 new 操作符](#使用-new-操作符)
    - [typeof 操作符的优先级](#typeof-操作符的优先级)
    - [与未声明和未初始化变量的交互](#与未声明和未初始化变量的交互)
  - [手写 typeof](#手写-typeof)
- [instanceof](#instanceof)
  - [示例](#示例-1)
    - [检测对象不是某个构造函数的实例](#检测对象不是某个构造函数的实例)
  - [手写 instanceof](#手写-instanceof)

# 运算符优先级
运算符的优先级决定了表达式中运算执行的先后顺序。**优先级高的运算符会作为优先级低的运算符的操作数。**

运算符优先级参考[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_precedence#%E6%B1%87%E6%80%BB%E8%A1%A8);

# typeof
typeof 运算符返回一个字符串，表示操作数的类型。

## 描述
返回值：
|类型|	结果|
|--|--|
Undefined|	"undefined"
Null|	"object"
Boolean|	"boolean"
Number|	"number"
BigInt|	"bigint"
String|	"string"
Symbol|	"symbol"
Function|（在 ECMA-262 中实现 `[[Call]]`；`classes`也是函数)	"function"
其他任何对象|	"object"

## 示例
```js
typeof 37 === "number";
typeof Infinity === "number";
typeof NaN === "number"; // 尽管它是 "Not-A-Number" (非数值) 的缩写

typeof 42n === "bigint";
typeof "" === "string";
typeof true === "boolean";
typeof Symbol() === "symbol";
typeof undefined === "undefined";
typeof { a: 1 } === "object";

typeof function () {} === "function";
typeof class C {} === "function";
```

### typeof null === "object";
原因：在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 "object"。

### 使用 new 操作符
所有使用 new 调用的构造函数都将返回非基本类型（"object" 或 "function"）。大多数返回对象，但值得注意的例外是 `Function` ，它返回一个函数。
```js
const str = new String("String");
const num = new Number(100);
typeof str; // "object"
typeof num; // "object"

const func = new Function();
typeof func; // "function"
```

### typeof 操作符的优先级
typeof 操作符的优先级高于加法（+）等二进制操作符。因此，需要用括号来计算加法结果的类型。
```js
// 括号有无将决定表达式的类型。
const someData = 99;

typeof someData + " Wisen"; // "number Wisen"
typeof (someData + " Wisen"); // "string"
```

### 与未声明和未初始化变量的交互
文件中压根没有声明的变量，`typeof` 会返回 `undefined`
```js
typeof undeclaredVariable; // "undefined"
```
但是 `let` 和 `const` 声明的变量，如果在声明前使用则会抛出一个 `ReferenceError`
```js
typeof newLetVariable; // ReferenceError
typeof newConstVariable; // ReferenceError
typeof newClass; // ReferenceError

let newLetVariable;
const newConstVariable = "hello";
class newClass {}
```

## 手写 typeof
```js
function mytypeof (obj){
    return Object.prototype.toString.call(obj).slice(8,-1).toLowerCase();
}
console.log(mytypeof('123')); 
```

# instanceof
`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

语法：`object instanceof constructor`  
`instanceof` 运算符用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上。

运算符返回 `true` 或 `false`

## 示例
```js
var simpleStr = "This is a simple string";
var myString = new String();
var newStr = new String("String created with constructor");
simpleStr instanceof String; // 返回 false，非对象实例，因此返回 false
myString instanceof String; // 返回 true
newStr instanceof String; // 返回 true
myString instanceof Object; // 返回 true

var myObj = {};
var myNonObj = Object.create(null);
myObj instanceof Object; // 返回 true，尽管原型没有定义
({}) instanceof Object; // 返回 true，同上
myNonObj instanceof Object; // 返回 false，一种创建非 Object 实例的对象的方法

var myDate = new Date();
myDate instanceof Date; // 返回 true
myDate instanceof Object; // 返回 true
```
### 检测对象不是某个构造函数的实例
```js
if (!(mycar instanceof Car)) {
  // Do something, like mycar = new Car(mycar)
}

// 这样是错误的写法，会先执行 !mycar，然后用 boolean 再执行 instanceof
if (!mycar instanceof Car)
```

## 手写 instanceof
```js
function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left);
  // 获取构造函数的 prototype 对象
  let prototype = right.prototype; 

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;

    proto = Object.getPrototypeOf(proto);
  }
}
```