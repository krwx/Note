## 1. 简单说一下http请求


## 2. 说一下cookie是什么，实际项目怎么使用
HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是**服务器发送到用户浏览器并保存在本地的一小块数据**。浏览器会存储 cookie 并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。**Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能**。

Cookie 主要用于以下三个方面：
* 会话状态管理  
如用户登录状态、购物车、游戏分数或其他需要记录的信息
* 个性化设置  
如用户自定义设置、主题和其他设置
* 浏览器行为跟踪  
如跟踪分析用户行为等

## 3. cookie过期了，怎么更新cookie
1. 用户手动登录，重新获取 cookie
2. 在每次请求时判断Cookie是否还有效，如果失效，则重新获取一个新的Cookie并设置到请求中。但是，这种方式会多出很多不必要的请求，浪费带宽和响应时间。

## 4. 还有什么储存技术
sessionStorage、localStorage、indexedDb

## 5. 会话是什么意思
会话是浏览器和服务器之间的多次请求和响应

## 6. cookie属于会话层面吗？删掉会话cookie还会存在吗
1. 会话期 Cookie： 会在当前的会话结束之后删除。浏览器定义了“当前会话”结束的时间，一些浏览器重启时会使用**会话恢复**。这可能导致会话 cookie 无限延长。
2. 持久性 Cookie： 在过期时间（Expires）指定的日期或有效期（Max-Age）指定的一段时间后被删除。

**只要浏览器还开着，Cookie数据就一直都在**。关闭标签页 cookie 还会存在

## 7. 浏览器读取资源的顺序  
memory、disk、请求服务器  
memory –> disk –> 服务器请求 

## 8. xss 通过什么方式造成，有什么后果（√）
XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行

后果：基于XSS的攻击种类几乎是无限的，但通常包括向攻击者传输cookie或其他会话信息等私人数据，将受害者重定向到攻击者控制的网页，或以易受攻击的网站为幌子在用户的机器上执行其他恶意操作

## 9. 强缓存可以怎么设置，cache
## 10. 说一下缓存存储读取的规则。说一下浏览器缓存策略的理解
9、10 同答案
```
### 强制缓存(Expires和Cache-Control)
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。  

强制缓存的情况主要有三种，如下：（这里的缓存标识指 Expires 或 Cache-Control）
- 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求。  
- 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用**协商缓存**。  
- 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果。  

控制强制缓存的字段分别是 **Expires** 和 **Cache-Control** ，其中 Cache-Control 优先级比 Expires高。

Expires：
1. Expires是HTTP/1.0控制网页缓存的字段；
其值为服务器返回该请求结果缓存的到期时间；
即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。
2. 到了HTTP/1.1，Expire已经被Cache-Control替代

Cache-Control：
|cache-control：主要用于控制网页缓存|	规则|
| ---- | ---- |
public|	所有内容都将被缓存（客户端和代理服务器都可缓存）
private|	所有内容只有客户端可以缓存，**Cache-Control的默认取值**
no-cache|	客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
no-store|	所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
max-age=xxx (xxx is numeric)|	缓存内容将在xxx**秒**后失效


### 协商缓存（Last-Modified / If-Modified-Since和Etag / If-None-Match）
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

主要有以下两种情况：
- 协商缓存生效，返回304。即该资源无更新，继续使用该缓存
- 协商缓存失效，返回200和请求结果。

控制协商缓存的字段分别有：**Last-Modified / If-Modified-Since 和 Etag / If-None-Match**。  
其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。

**Last-Modified / If-Modified-Since**  
- If-Modified-Since（客户端设置）：  
  是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。
- Last-Modified（服务器设置）：  
  是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。
- 缓存判断条件：  
  服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。

**Etag / If-None-Match**
- If-None-Match（客户端设置）：  
  - 是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。
- Etag（服务器设置）：  
  - 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
- 缓存判断条件：  
  - 会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。

Etag / If-None-Match 优先级高于 Last-Modified / If-Modified-Since ，同时存在则只有 Etag / If-None-Match 生效。对于协商缓存，使用 Ctrl+F5强制刷新可以使得缓存无效。
```

## 11. 讲一下浏览器输入url后做了些什么（回答漏了浏览器缓存页面的流程）
## 12. 浏览器输入url后怎么从DNS获取服务器的地址，详细讲一下DNS的处理流程
11、12同答案
1. 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

2. 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

3. 下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

4. 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

5. 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

6. 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加

7. 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

8. 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

9.  最后一步是 TCP 断开连接的四次挥手过程。

## 13. http请求有哪几种类型
HTTP 请求方式一共有 9 种。其中前三种 POST 、GET 、HEAD 是 HTTP 1.0 定义的，后六种 PUT 、PATCH 、 OPTIONS 、DELETE 、CONNECT 、 TRACE 是 HTTP 1.1 定义的。

1. POST 请求  
    POST ：表示向指定资源提交数据，数据包含在请求头中。有可能导致新的资源建立或原有资源修改。 POST 请求是 HTTP 请求中使用最多的一种请求方式。
2. GET 请求  
    GET ：表示请求指定的页面信息，并返回实体内容。  
    HTTP GET 方法请求指定资源的表示。使用 GET 的请求应该只用于请求数据，而不应该包含数据。
3. HEAD 请求  
    HEAD ：类似于 GET，只不过返回的响应体中没有具体内容，只有报文头，用于获取报文头。
4. PUT 请求  
    PUT ：从客户端向服务器传送的数据取代指定的内容，即向指定的位置上传最新的内容。
5. PATCH 请求  
    HTTP PATCH 请求方法用于对资源进行部分修改。  
    与 PUT 的不同点是：PUT 请求会将整个资源覆盖掉，但是 PATCH 请求可以只更新资源的部分
6. OPTIONS 请求  
    HTTP OPTIONS 方法请求给定的 URL 或服务器的允许通信选项。  
    可以检测服务器所支持的请求方法，检测实际请求是否可以被服务器所接受
7. DELETE 请求  
    HTTP DELETE 请求方法用于删除指定的资源。
8. CONNECT 请求  
    CONNECT ：HTTP 1.1 中预留给能够将连接改为管道方式的代理服务器。  
    官方：HTTP CONNECT 方法可以开启与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。
9. TRACE 请求  
    TRACE ：回显服务器收到的请求，主要用于测试和诊断。  
    官方：HTTP TRACE 方法沿着通往目标资源的路径进行信息回环测试，提供一个有用的调试机制。

## 14. 有用过原生的http请求吗。项目是怎么发送http请求的
XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。  

比较少用到。angular 有一个 http 库，引用之后，调用相关的 get、post 还有其他方法发送 http 请求。

## 15. 浏览器怎么找到对应的 js 文件