- [API 风格](#api-风格)
- [创建一个应用](#创建一个应用)
  - [挂载应用](#挂载应用)
  - [应用配置](#应用配置)
- [模板语法](#模板语法)
  - [文本插值](#文本插值)
  - [原始 HTML](#原始-html)
  - [Attribute 绑定](#attribute-绑定)
  - [使用 JavaScript 表达式](#使用-javascript-表达式)
    - [动态参数：](#动态参数)
- [响应式基础](#响应式基础)
  - [声明响应式状态](#声明响应式状态)
    - [`<script setup>`](#script-setup)
    - [为什么要使用 ref？，不使用普通变量](#为什么要使用-ref不使用普通变量)
    - [深层响应性](#深层响应性)
    - [DOM 更新时机](#dom-更新时机)
  - [reactive()](#reactive)
  - [Reactive Proxy 和 原始对象的区别](#reactive-proxy-和-原始对象的区别)
  - [reactive() 的局限性](#reactive-的局限性)
  - [ref 的解包细节](#ref-的解包细节)
    - [ref 作为 reactive 对象的属性](#ref-作为-reactive-对象的属性)
    - [在数组和集合使用 ref](#在数组和集合使用-ref)
    - [在模板中使用 ref](#在模板中使用-ref)
- [计算属性](#计算属性)
  - [计算属性缓存 vs 方法](#计算属性缓存-vs-方法)
  - [可写计算属性](#可写计算属性)
- [类与样式绑定](#类与样式绑定)
  - [绑定 HTML class](#绑定-html-class)
    - [绑定对象](#绑定对象)
    - [绑定数组](#绑定数组)
  - [绑定内联样式](#绑定内联样式)

# API 风格
组合式 API (Composition API)：  
通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 **`<script setup>`** 搭配使用。这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，`<script setup>` 中的导入和顶层变量/函数都能够在模板中直接使用。

# 创建一个应用
每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例。

我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。

如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。
```js
import { createApp } from 'vue'
// 从一个单文件组件中导入根组件
import App from './App.vue'

const app = createApp(App)
```
## 挂载应用
应用实例必须在调用了 .mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：
```js
// html
<div id="app"></div>

// js
app.mount('#app')
```
.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。
## 应用配置
应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，用来捕获所有子组件上的错误：
```js
app.config.errorHandler = (err) => {
  /* 处理错误 */
}
```

# 模板语法
在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。

vue也使用 virtual dom。

## 文本插值
最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：
```html
<span>Message: {{ msg }}</span>
```
双大括号标签会被替换为相应组件实例中 msg 属性的值。同时每次 msg 属性更改时它也会同步更新。

## 原始 HTML
使用 **v-html** 指令插入 HTML：
```html
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```
该指令做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 rawHtml 属性保持同步。
>安全警告：在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞。请仅在内容安全可信时再使用 v-html，并且永远不要使用用户提供的 HTML 内容。

## Attribute 绑定
使用 **v-bind** 指令响应式地绑定一个 attribute
```html
<div v-bind:id="dynamicId"></div>
<div :id="dynamicId"></div>
```
v-bind 指令指示 Vue 将元素的 id attribute 与组件的 dynamicId 属性保持一致。如果绑定的值是 null 或者 undefined，那么该 attribute 将会从渲染的元素上移除。

当绑定的值为布尔型 Attribute， 当属性为真值或一个空字符时，元素会包含这个 attribute。而当其为其他假值时 attribute 将被忽略。

绑定多个值：  
通过不带参数的 v-bind，你可以将它们绑定到单个元素上：
```js
const objectOfAttrs = {
  id: 'container',
  class: 'wrapper'
}

<div v-bind="objectOfAttrs"></div>
```

## 使用 JavaScript 表达式
在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：
- 在文本插值中 (双大括号)
- 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中

每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是**是否可以合法地写在 return 后面**。

可以调用组件内的函数。
> 绑定在表达式中的方法在组件每次更新时都会被重新调用，因此不应该产生任何副作用，比如改变数据或触发异步操作。

模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。

### 动态参数：  
同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：
```html
<!-- 绑定属性 -->
<a v-bind:[attributeName]="url"> ... </a>
<a :[attributeName]="url"> ... </a>
<!-- 这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 "href"，那么这个绑定就等价于 v-bind:href。 -->

<!-- 绑定事件 -->
<a v-on:[eventName]="doSomething"> ... </a>
<a @[eventName]="doSomething">
```
动态参数值的限制：应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。

动态参数语法的限制：
- 因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。
- 当使用 **DOM 内嵌模板** (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写。
  - 单文件组件内的模板不受此限制。

修饰符 Modifiers：
- 修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。
- 例如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()：
  ```html
  <form @submit.prevent="onSubmit">...</form>
  ```

# 响应式基础
## 声明响应式状态
在组合式 API 中，推荐使用 **ref()** 函数来声明响应式状态。  
ref() 接收参数，并将其包裹在一个带有 .value 属性的 ref 对象中返回
```js
import { ref } from 'vue'

const count = ref(0)
console.log(count) // { value: 0 }
console.log(count.value) // 0
```
注意，在模板中使用 ref 时，我们不需要附加 .value。为了方便起见，当在模板中使用时，ref 会**自动解包** 。

### `<script setup>`
在 setup() 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用单文件组件 (SFC) 来避免这种情况。我们可以使用 `<script setup>` 来大幅度地简化代码:
```js
<script setup>
import { ref } from 'vue'

const count = ref(0)
function increment() {
  count.value++
}
</script>

<template>
  <!-- 模板里面使用，ref 自动解包 -->
  <button @click="increment">{{ count }}</button>
</template>
```

### 为什么要使用 ref？，不使用普通变量
- 当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。
- 当一个组件首次渲染时，Vue 会追踪在渲染过程中使用的每一个 ref。
- 然后，当一个 ref 被修改时，它会触发追踪它的组件的一次重新渲染。
- 检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。
- `.value` 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。
- 与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。

### 深层响应性
Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 Map。

Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到
```js
import { ref } from 'vue'

const obj = ref({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // 以下都会按照期望工作
  obj.value.nested.count++
  obj.value.arr.push('baz')
}
```
**非原始值将通过 reactive() 转换为响应式代理**

也可以通过 **shallow ref** 来放弃深层响应性。对于浅层 ref，只有 .value 的访问会被追踪。浅层 ref 可以用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。
```js
const state = shallowRef({ count: 1 })

// 不会触发更改
state.value.count = 2
// 会触发更改
state.value = { count: 2 }
```

### DOM 更新时机
- 当你修改了响应式状态时，DOM 会被自动更新。
- 但是需要注意的是，DOM 更新不是同步的。
- Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。

要等待 DOM 更新完成后再执行额外的代码，可以使用 `nextTick()` 全局 API：
```js
import { nextTick } from 'vue'

async function increment() {
  count.value++
  await nextTick()
  // 现在 DOM 已经更新了
}
```

## reactive()
另一种声明响应式状态的方式，即使用 **reactive() API**。与将内部值包装在特殊对象中的 ref 不同，reactive() 将使对象本身具有响应性.

它只能用于**对象类型**

```js
import { reactive } from 'vue'
const state = reactive({ count: 0 })

<button @click="state.count++">
  {{ state.count }}
</button>
```
- reactive() 将深层地转换对象：当访问嵌套对象时，它们也会被 reactive() 包装。
- **当 ref 的值是一个对象时，ref() 也会在内部调用它。**
- 与浅层 ref 类似，这里也有一个 shallowReactive() API 可以选择退出深层响应性。

## Reactive Proxy 和 原始对象的区别
- reactive() 返回的是一个原始对象的 Proxy，它和原始对象是不相等的.
- 只有代理对象是响应式的，更改原始对象不会触发更新
- 为保证访问代理的一致性，对同一个原始对象调用 reactive() 会总是返回同样的代理对象，而对一个已存在的代理对象调用 reactive() 会返回其本身

## reactive() 的局限性
1. 有限的值类型：它只能用于对象类型 
2. 不能替换整个对象。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失
3. 对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接：
   ```js
    const state = reactive({ count: 0 })

    // 当解构时，count 已经与 state.count 断开连接
    let { count } = state
    // 不会影响原始的 state
    count++

    // 该函数接收到的是一个普通的数字
    // 并且无法追踪 state.count 的变化
    // 我们必须传入整个对象以保持响应性
    callSomeFunction(state.count)
   ```

## ref 的解包细节
### ref 作为 reactive 对象的属性
一个 ref 会在作为响应式对象的属性被访问或修改时自动解包。换句话说，它的行为就像一个普通的属性：
```js
const count = ref(0)
const state = reactive({
  count
})

console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1
```
- 如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref
- 只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当**其作为浅层响应式对象的属性被访问时不会解包**。

### 在数组和集合使用 ref
当 ref 作为响应式数组或原生集合类型(如 Map) 中的元素被访问时，它不会被解包。
```js
const books = reactive([ref('Vue 3 Guide')])
// 这里需要 .value
console.log(books[0].value)

const map = reactive(new Map([['count', ref(0)]]))
// 这里需要 .value
console.log(map.get('count').value)
```

### 在模板中使用 ref
在模板渲染上下文中，只有**顶级的 ref 属性**才会被解包。
```js
// count 为顶级属性，object 不是
const count = ref(0)
const object = { id: ref(0) }

{{ count + 1 }} // 渲染 1
{{ object.id + 1 }} // 渲染 [object Object]1

// 解决这种情况，可以将 id 解构为一个顶级属性
const { id } = object
{{ id + 1 }} // 渲染 2
```
如果 ref 是文本插值的最终计算值 (即 {{ }} 标签)，那么它将被解包。  
个人理解是 {{}} 只有 ref，那么它解包
```js
{{ object.id }} // 渲染 0
```

# 计算属性
通过 **computed()** API 实现。  
computed() 方法期望接收一个 getter 函数，**返回值为一个计算属性 ref**。
```js
<script setup>
import { reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide'
  ]
})

// 一个计算属性 ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})
</script>

<template>
  <p>Has published books:</p>
  <!-- 直接使用ref，自动解包 -->>
  <span>{{ publishedBooksMessage }}</span>
</template>

// Vue 的计算属性会自动追踪响应式依赖。它会检测到 publishedBooksMessage 依赖于 author.books，所以当 author.books 改变时，任何依赖于 publishedBooksMessage 的绑定都会同时更新。
```

## 计算属性缓存 vs 方法
- 计算属性缓存指通过 computed() 计算的值
- 方法指通过普通方法返回的值

两者的区别是：
- 计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。如果依赖不更新，那么就不用重新计算。好处是优化性能。
- 方法调用总是会在重渲染发生时再次执行函数。

```js
// 下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖
const now = computed(() => Date.now())
```

## 可写计算属性
计算属性默认是只读的。但是可以通过同时提供 getter 和 setter 来创建“可写”的计算属性
```js
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```

**注意点**：
1. Getter 不应有副作用
2. 避免直接修改计算属性值
   1. 不应该修改 computed() 返回的值，而是应该修改依赖的值

# 类与样式绑定
通过 v-bind 绑定 class 和 style

## 绑定 HTML class
### 绑定对象
绑定的对象一定是**响应式**的，不是普通对象。
```html
<!-- active 是否存在取决于数据属性 isActive 的真假值。 -->
<div :class="{ active: isActive }"></div>

<!-- 可以设置多个class -->
const isActive = ref(true)
const hasError = ref(false)
<!-- 绑定对象和正常设置class可以同时存在 -->
<div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
></div>

<!-- 也可以直接绑定一个对象 -->
const classObject = reactive({
  active: true,
  'text-danger': false
})

<div :class="classObject"></div>

<!-- 也可以绑定一个返回对象的计算属性 -->
const isActive = ref(true)
const error = ref(null)
const classObject = computed(() => ({
  active: isActive.value && !error.value
}))

<div :class="classObject"></div>
```

### 绑定数组
```js
const activeClass = ref('active')
const errorClass = ref('text-danger')

<div :class="[activeClass, errorClass]"></div>

// 渲染的结果是：
<div class="active text-danger"></div>
```

## 绑定内联样式
