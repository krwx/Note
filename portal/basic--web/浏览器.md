# 浏览器

- [浏览器](#浏览器)
  - [浏览器加载过程](#浏览器加载过程)
  - [浏览器加载资源的顺序](#浏览器加载资源的顺序)
  - [浏览器读取资源的顺序](#浏览器读取资源的顺序)
  - [MDN 关键渲染路径（Critical rendering path）](#mdn-关键渲染路径critical-rendering-path)
    - [理解 CRP](#理解-crp)
      - [文档对象模型](#文档对象模型)
      - [CSS 对象模型](#css-对象模型)
      - [渲染树](#渲染树)
      - [布局](#布局)
    - [绘制](#绘制)
    - [优化 CRP](#优化-crp)
  - [MDN 浏览器的工作原理](#mdn-浏览器的工作原理)
    - [导航](#导航)
      - [DNS 查询](#dns-查询)
      - [TCP 握手](#tcp-握手)
      - [TLS 协商](#tls-协商)
    - [响应](#响应)
    - [解析](#解析)
      - [构建 DOM 树](#构建-dom-树)
        - [预加载扫描器](#预加载扫描器)
      - [构建 CSSOM 树](#构建-cssom-树)
    - [渲染](#渲染)
      - [样式](#样式)
      - [布局](#布局-1)
        - [回流](#回流)
      - [绘制](#绘制-1)
      - [合成](#合成)
    - [交互](#交互)
  - [回流与重绘](#回流与重绘)

## 浏览器加载过程

简单版：  

```text
加载过程：
1. DNS解析 ：把域名变成IP地址，大型网站不同地区IP地址是不一样的
2. 浏览器根据IP地址向服务器发起Http请求 （包括三次握手）
3. 服务器处理http请求，并返回给浏览器

渲染过程
1. 浏览器根据 HTML 代码生成 DOM 树
2. 浏览器根据 css 代码生成 CSSOM
3. 将 DOM 树和 CSSOM 整合形成 Render 树（渲染树），只有 DOM 树是无法渲染的，因为有些标签的 css 属性是在 CSSOM 中的
4. 浏览器根据 render 树渲染页面
5. 如果遇到`<script>`则暂停渲染，优先加载并执行JS代码，完成在继续。因为JS进程和渲染进程共用一个线程，JS 有可能改变DOM结构，如果JS代码改变了DOM结构，那么如果提前渲染的DOM结构将是不正确的
6. 制止 render 树渲染完成
```

完全版：

```text
1. 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

2. 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

3. 下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

4. 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

5. 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

6. 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加

7. 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

8. 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

9. 最后一步是 TCP 断开连接的四次挥手过程。
```

## 浏览器加载资源的顺序

最高级：html,css,font  
然后：js，xhr  
然后是多媒体：图片-语音-视频  
最后：prefetch预加载的资源  

## 浏览器读取资源的顺序  

memory –> disk –> 服务器请求

## MDN 关键渲染路径（Critical rendering path）

**关键渲染路径是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列**。优化关键渲染路径可提高渲染性能。关键渲染路径包含了 `文档对象模型(DOM)`，`CSS 对象模型 (CSSOM)`，`渲染树`，`布局`和`绘制`。

在解析 `HTML` 时会创建文档对象模型。`HTML` 可以请求 `JavaScript`，而 `JavaScript` 反过来，又可以更改 `DOM`。`HTM`L 包含或请求样式，依次来构建 `CSS` 对象模型。浏览器引擎将两者结合起来以创建渲染树。布局确定页面上所有内容的大小和位置。确定布局后，将像素绘制到屏幕上。

### 理解 CRP

**CRP 大概流程（重要）**：

- 网页请求从 HTML 文件请求开始。服务器返回 HTML——响应头和数据。然后浏览器开始解析 HTML，转换收到的数据为 DOM 树。
- 浏览器每次发现外部资源就初始化请求，无论是样式、脚本或者嵌入的图片引用。有时请求会阻塞，这意味着解析剩下的 HTML 会被终止直到重要的资源被处理。
- 浏览器接着解析 HTML，发请求和构造 DOM 直到文件结尾，这时开始构造 CSS 对象模型。
- 等到 DOM 和 CSSOM 完成之后，浏览器构造渲染树，计算所有可见内容的样式。
- 一旦渲染树完成布局开始，定义所有渲染树元素的位置和大小。完成之后，页面被渲染完成，或者说是绘制到屏幕上。

#### 文档对象模型

- DOM 构建是增量的。
- HTML 响应变成令牌（token），令牌变成节点，而节点又变成 DOM 树。单个 DOM 节点以 startTag 令牌开始，以 endTag 令牌结束。
- 节点包含有关 HTML 元素的所有相关信息。该信息是使用令牌描述的。
- 节点根据令牌层次结构连接到 DOM 树中。如果另一组 startTag 和 endTag 令牌位于一组 startTag 和 endTag 之间，则你在节点内有一个节点，这就是我们定义 DOM 树层次结构的方式。

#### CSS 对象模型

- DOM 包含页面所有的内容。CSSOM 包含了页面所有的样式，也就是如何展示 DOM 的信息。
- DOM 构造是增量的，CSSOM 却不是。CSS 是渲染阻塞的：浏览器会阻塞页面渲染直到它接收和执行了所有的 CSS。
- CSS 是渲染阻塞是因为规则可以被覆盖，所以内容不能被渲染直到 CSSOM 的完成。

#### 渲染树

渲染树包括了内容和样式：`DOM` 和 `CSSOM` 树结合为渲染树。为了构造渲染树，浏览器检查每个节点，从 DOM 树的根节点开始，并且决定哪些 CSS 规则被添加。

渲染树只包含了可见内容。头部（通常）不包含任何可见信息，因此不会被包含在渲染树中。如果有元素上有 `display: none`;，它本身和其后代都不会出现在渲染树中。

#### 布局

一旦渲染树被构建，布局变成了可能。布局取决于屏幕的尺寸。布局这个步骤决定了在哪里和如何在页面上放置元素，决定了每个元素的宽和高，以及他们之间的相关性。

### 绘制

- 最后一步是将像素绘制在屏幕上。一旦渲染树创建并且布局完成，像素就可以被绘制在屏幕上。加载时，整个屏幕被绘制出来。
- **重绘**：之后，只有受影响的屏幕区域会被重绘，浏览器被优化为只重绘需要绘制的最小区域。

### 优化 CRP

1. 通过异步、延迟加载或者消除非关键资源来减少关键资源的请求数量，
2. 优化必须的请求数量和每个请求的文件体积，
3. 通过区分关键资源的优先级来优化被加载关键资源的顺序，来缩短关键路径长度。

## MDN 浏览器的工作原理

[链接](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)

### 导航

导航是加载 web 页面的第一步。它发生在以下情形：用户通过在地址栏输入一个 URL、点击一个链接、提交表单或者是其他的行为。

Web 性能优化的目标之一就是缩短导航完成所花费的时间，在理想情况下，它通常不会花费太多的时间，但是等待时间和带宽会导致它的延时。

#### DNS 查询

对于一个 web 页面来说导航的第一步是要去寻找页面资源的位置。

浏览器向名称服务器发起 DNS 查询请求，最终得到一个 IP 地址。第一次请求之后，这个 IP 地址可能会被缓存一段时间，这样可以通过从缓存里面检索 IP 地址而不是再通过名称服务器进行查询来加速后续的请求。

通过主机名加载一个页面通常仅需要一次 DNS 查询。但是，对于页面指向的不同的主机名，则需要多次 DNS 查询。如果字体（font）、图像（image）、脚本（script）、广告（ads）和网站统计（metric）都有不同的主机名，则需要对每一个主机名进行 DNS 查询。

#### TCP 握手

一旦获取到服务器 IP 地址，浏览器就会通过 TCP“三次握手” 与服务器建立连接。

#### TLS 协商

对于通过 HTTPS 建立的安全连接，还需要另一次 "握手"。这种握手，或者说 TLS 协商，决定使用哪种密码对通信进行加密，验证服务器，并在开始实际数据传输前建立安全连接。这就需要在实际发送内容请求之前，再往返服务器五次。

### 响应

一旦我们建立了到 web 服务器的连接，浏览器就代表用户发送一个初始的 `HTTP GET` 请求，对于网站来说，这个请求通常是一个 `HTML` 文件。一旦服务器收到请求，它将使用相关的响应头和 HTML 的内容进行回复。

初始请求的响应包含所接收数据的**第一个字节**。**首字节时间**（`TTFB`）是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间。第一个内容分块通常是 `14KB` 的数据。

浏览器在解析阶段遇到链接时才会去请求链接的资源

### 解析

一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。

**解析**是浏览器将通过网络接收的数据转换为 `DOM` 和 `CSSOM` 的步骤，通过渲染器把 DOM 和 CSSOM 在屏幕上绘制成页面。

即使请求页面的 HTML 大于初始的 14KB 数据包，浏览器也将开始解析并尝试根据其拥有的数据进行渲染。  
这就是为什么在前 14KB 中包含浏览器开始渲染页面所需的所有内容，或者至少包含页面模板（第一次渲染所需的 CSS 和 HTML）对于 web 性能优化来说是重要的。但是在渲染到屏幕上面之前，HTML、CSS、JavaScript 必须被解析完成。

#### 构建 DOM 树

**第一步**是处理 HTML 标记并构造 DOM 树。HTML 解析涉及到符号化和树的构造。HTML 标记包括开始和结束标记，以及属性名和值。如果文档格式良好，则解析它会简单而快速。解析器将标记化的输入解析到文档中，构建文档树。

**重要**：  
当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个 CSS 文件时，解析也可以继续进行，但是对于 `<script>` 标签（特别是没有 async 或者 defer 属性的）会阻塞渲染并停止 HTML 的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。

##### 预加载扫描器

- 浏览器构建 DOM 树时，这个过程占用了主线程。当这种情况发生时，预加载扫描仪将解析可用的内容并请求高优先级资源，如 CSS、JavaScript 和 web 字体。
- 多亏了预加载扫描器，我们不必等到解析器找到对外部资源的引用来请求它。它将在后台检索资源，以便在主 HTML 解析器到达请求的资源时，它们可能已经在运行，或者已经被下载。预加载扫描仪提供的优化减少了阻塞。

等待获取 CSS 不会阻塞 HTML 的解析或者下载，但是它确实会阻塞 JavaScript，因为 JavaScript 经常用于查询元素的 CSS 属性。

#### 构建 CSSOM 树

**第二步**是处理 CSS 并构建 CSSOM 树。CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM 是两棵树。它们是独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。

### 渲染

- 渲染步骤包括**样式、布局、绘制**，在某些情况下还包括**合成**。
- 在解析步骤中创建的 CSSOM 树和 DOM 树组合成一个渲染树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。
- 在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是 CPU 上绘制屏幕的一部分来提高性能，从而释放主线程。

#### 样式

关键呈现路径的**第三步**是将 DOM 和 CSSOM 组合成渲染树。计算样式树或渲染树的构建从 DOM 树的根开始，遍历每个可见节点。

不会被显示的元素，如 `<head>` 元素及其子元素，以及任何带有 display: none 的节点都不会包含在渲染树中，

#### 布局

- **第四步**是在渲染树上运行布局以计算每个节点的几何体。
- 布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。
- **回流**是对页面的任何部分或整个文档的任何后续大小和位置的确定。

##### 回流

- 第一次确定节点的大小和位置称为布局。
- 随后对节点大小和位置的重新计算称为回流。
- 在我们的示例中，假设初始布局发生在返回图像之前。由于我们没有声明图像的尺寸，因此一旦知道图像的尺寸，就会出现回流。

#### 绘制

**最后一步**是将各个节点绘制到屏幕上。

- 绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能。
- 有一些特定的属性和元素可以实例化一个层，包括 `<video>` 和 `<canvas>`，任何 CSS 属性为 `opacity` 、`3D transform`、`will-change` 的元素，还有一些其他元素。这些节点将与子节点一起绘制到它们自己的层上，

#### 合成

当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

- 当页面继续加载资源时，可能会发生回流（回想一下我们迟到的示例图像），回流会触发重新绘制和重新组合。
- 如果我们定义了图像的大小，就不需要重新绘制，只需要重新绘制需要重新绘制的层，并在必要时进行合成。
- 但我们没有包括图像大小！从服务器获取图像后，渲染过程将返回到布局步骤并从那里重新开始。

### 交互

一旦主线程绘制页面完成，仍没有完成。如果加载包含 JavaScript（并且延迟到 onload 事件触发后执行），则主线程可能很忙，无法用于滚动、触摸和其他交互。

在我们的示例中，可能图像加载很快，但其中一个 js 文件可能是 2MB，而且用户的网络连接很慢。在这种情况下，用户可以非常快地看到页面，但是在下载、解析和执行脚本之前，就无法滚动。

## 回流与重绘

- 回流 `reflow`
  - 当render树中的一部分或者全部因为大小边距等问题发生改变而需要重建的过程叫做回流。
- 重绘 `repaint`
  - 当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘。

其他解释：

- 回流（重排）指的是，当元素的布局或显示等信息改变时，引起 Render 树部分或整体的重新构建，即网页布局的调整。
- 重绘指的是，Render 树中节点属性的更新。因此，回流必然会引起重绘，重绘不一定引起重排。

如何避免：

- CSS
  - 避免使用table
  - 尽可能在DOM树的最末端改变class(可限制回流的范围)
  - 避免设置多层内联样式
  - 动画效果应该用position: absolute/fixed
  - 避免CSS表达式
- JS
  - 避免频繁操作DOM
  - document.fragment()文档碎片
  - display: none/block不会引发回流和重绘
  - 触发回流的属性放变量里读取，如：offsetTop/Left/Width/Height，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，width/height
- 集中改变样式
  - 我们往往通过改变class的方式来集中改变样式
