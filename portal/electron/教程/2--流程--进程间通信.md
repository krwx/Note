- [进程间通信](#进程间通信)
  - [IPC 通道](#ipc-通道)
  - [API总结](#api总结)
  - [模式 1：渲染器进程到主进程（单向）](#模式-1渲染器进程到主进程单向)
    - [1. 使用 `ipcMain.on` 监听事件](#1-使用-ipcmainon-监听事件)
    - [2. 通过预加载脚本暴露 ipcRenderer.send](#2-通过预加载脚本暴露-ipcrenderersend)
    - [3. 构建渲染器进程 UI](#3-构建渲染器进程-ui)
  - [模式 2：渲染器进程到主进程（双向）](#模式-2渲染器进程到主进程双向)
    - [流程](#流程)
    - [1. 使用 ipcMain.handle 监听事件](#1-使用-ipcmainhandle-监听事件)
    - [2. 通过预加载脚本暴露 ipcRenderer.invoke](#2-通过预加载脚本暴露-ipcrendererinvoke)
    - [3. 构建渲染器进程 UI](#3-构建渲染器进程-ui-1)
  - [模式 3：主进程到渲染器进程](#模式-3主进程到渲染器进程)
    - [1. 使用 `webContents` 模块发送消息](#1-使用-webcontents-模块发送消息)
    - [2. 通过预加载脚本暴露 `ipcRenderer.on`](#2-通过预加载脚本暴露-ipcrendereron)
    - [3. 构建渲染器进程 UI](#3-构建渲染器进程-ui-2)
    - [可选：返回一个回复](#可选返回一个回复)
  - [模式 4：渲染器进程到渲染器进程](#模式-4渲染器进程到渲染器进程)
  - [对象序列化（传递的对象通过克隆而得）](#对象序列化传递的对象通过克隆而得)
  - [renderer.js 不能使用 ipcRenderer 的理由](#rendererjs-不能使用-ipcrenderer-的理由)
  - [Electron 中的消息端口（`MessagePort`）](#electron-中的消息端口messageport)

# 进程间通信
## IPC 通道
进程间通讯 (inter-process communication, IPC)

进程使用 `ipcMain` 和 `ipcRenderer` 模块，通过开发人员定义的“通道”传递消息来进行通信。 这些通道是 **任意** （您可以随意命名它们）和 **双向** （您可以在两个模块中使用相同的通道名称）的。

## API总结
模式 1：渲染器进程到主进程（单向）
* `ipcRenderer.send`
* `ipcMain.on`

模式 2：渲染器进程到主进程（双向）
* `ipcRenderer.invoke`
* `ipcMain.handle`

模式 3：主进程到渲染器进程
* `webContents.send`
* `ipcRenderer.on`

## 模式 1：渲染器进程到主进程（单向）
要将单向 `IPC` 消息从渲染器进程发送到主进程，您可以使用 `ipcRenderer.send API` 发送消息，然后使用 `ipcMain.on API` 接收。

下面的例子是：用户在输入框输入内容，点击按钮后设置输入内容为窗口的标题

### 1. 使用 `ipcMain.on` 监听事件
```js
// 监听事件的回调函数
function handleSetTitle (event, title) {
  const webContents = event.sender
  const win = BrowserWindow.fromWebContents(webContents)
  // 给窗口设置 title
  win.setTitle(title)
}

app.whenReady().then(() => {
  // 监听 set-title 事件
  ipcMain.on('set-title', handleSetTitle)
  createWindow()
})
```
上面的 `handleSetTitle` 回调函数有两个参数：
* 一个 `IpcMainEvent` 结构
  * 该结构包含 `sender`属性，用于返回发送消息的 webContents
* 和一个 `title` 字符串。 

每当消息通过 `set-title` 通道传入时，此函数找到附加到消息发送方的 `BrowserWindow` 实例（通过 `BrowserWindow.fromWebContents()` ），并在该实例上使用 `win.setTitle API`。

### 2. 通过预加载脚本暴露 ipcRenderer.send
```js
// preload.js
const { contextBridge, ipcRenderer } = require('electron')

contextBridge.exposeInMainWorld('electronAPI', {
  // seetTitle 是一个接收 title 入参的箭头函数
  setTitle: (title) => ipcRenderer.send('set-title', title)
})
```
`ipcRenderer.send(channelName, ...args)`
* channelName：通道的名称
* args：传递的数据

**注意：如果通道需要传数据，箭头函数一定要加参数定义。不然调用 `send()` 时会报错**

### 3. 构建渲染器进程 UI
```html
<!-- index.html -->
    Title: <input id="title"/>
    <button id="btn" type="button">Set</button>
    <script src="./renderer.js"></script>
```

```js
// render.js
const setButton = document.getElementById('btn')
const titleInput = document.getElementById('title')
setButton.addEventListener('click', () => {
  const title = titleInput.value
  // 发送事件
  window.electronAPI.setTitle(title)
})
```

## 模式 2：渲染器进程到主进程（双向）
定义：双向 IPC 的一个常见应用是**从渲染器进程代码调用主进程模块并等待结果**。 这可以通过将 `ipcRenderer.invoke` 与 `ipcMain.handle` 搭配使用来完成。

### 流程
1. 渲染器通过 `channel` 通道发送 `ipcRender.invoke` 消息
2. 主进程通过 `ipcMain.handle` 监听 `channel` 通道，并返回值
3. 返回值将作为一个 `Promise` 返回到渲染器最初的 `invoke` 调用。
4. 渲染器是通过 `await` 调用 发送消息事件，这时解析 `Promise` 返回的数据，获取主进程返回的数据

下面的例子为：从渲染器进程打开一个原生的文件对话框，并返回所选文件的路径。

### 1. 使用 ipcMain.handle 监听事件
在主进程中，我们将创建一个 `handleFileOpen()` 函数，它调用 `dialog.showOpenDialog` 并返回用户选择的文件路径值。 每当渲染器进程通过 `dialog:openFile` 通道发送 `ipcRender.invoke` 消息时，此函数被用作一个回调。 然后，返回值将作为一个 `Promise` 返回到最初的 `invoke` 调用。

```js
// main.js (Main Process)
const { app, BrowserWindow, dialog, ipcMain } = require('electron')

async function handleFileOpen () {
  const { canceled, filePaths } = await dialog.showOpenDialog({})
  if (!canceled) {
    return filePaths[0]
  }
}

app.whenReady().then(() => {
  ipcMain.handle('dialog:openFile', handleFileOpen)
})
// ...
```

### 2. 通过预加载脚本暴露 ipcRenderer.invoke
```js
// preload.js
const { contextBridge, ipcRenderer } = require('electron')

contextBridge.exposeInMainWorld('electronAPI', {
  openFile: () => ipcRenderer.invoke('dialog:openFile')
})
```

### 3. 构建渲染器进程 UI
```html
<!-- index.html -->
<button type="button" id="btn">Open a File</button>
    File path: <strong id="filePath"></strong>
```
```js
const btn = document.getElementById('btn')
const filePathElement = document.getElementById('filePath')

btn.addEventListener('click', async () => {
  const filePath = await window.electronAPI.openFile()
  filePathElement.innerText = filePath
})
```

## 模式 3：主进程到渲染器进程
将消息从主进程发送到渲染器进程时，需要指定是哪一个渲染器接收消息。   
消息需要通过其 `WebContents` 实例发送到渲染器进程。   
此 `WebContents` 实例包含一个 `send` 方法，其使用方式与 `ipcRenderer.send` 相同。

下面的例子为：构建一个由原生操作系统菜单控制的数字计数器。（即通过自定义窗口上方的菜单栏，点击菜单项进行加减1）

### 1. 使用 `webContents` 模块发送消息
首先使用 `Electron` 的 `Menu` 模块在主进程中构建一个自定义菜单，该模块使用 `webContents.send API` 将 `IPC` 消息从主进程发送到目标渲染器。

```js
// main.js
const { app, BrowserWindow, Menu, ipcMain } = require('electron')
const path = require('node:path')

// 创建窗口函数
function createWindow () {
  const mainWindow = new BrowserWindow({
    webPreferences: {
      preload: path.join(__dirname, 'preload.js')
    }
  })

  // 定义菜单
  const menu = Menu.buildFromTemplate([
    {
      label: app.name,
      submenu: [
        {
          // 通过上面创建的窗口 mainWindow 的 webContents.send() 发送事件
          click: () => mainWindow.webContents.send('update-counter', 1),
          label: 'Increment'
        },
        {
          click: () => mainWindow.webContents.send('update-counter', -1),
          label: 'Decrement'
        }
      ]
    }
  ])
  // 设置自定义菜单
  Menu.setApplicationMenu(menu)

  mainWindow.loadFile('index.html')
}
// ...
```

### 2. 通过预加载脚本暴露 `ipcRenderer.on`
```js
const { contextBridge, ipcRenderer } = require('electron')

contextBridge.exposeInMainWorld('electronAPI', {
  // 这里要设置入参 callback 作为监听事件的回调
  onUpdateCounter: (callback) => ipcRenderer.on('update-counter', callback)
})
```

### 3. 构建渲染器进程 UI
```html
<!-- index.html -->
Current value: <strong id="counter">0</strong>
```

```js
// renderer.js
const counter = document.getElementById('counter')

// onUpdateCounter() 里面的参数是监听事件的回调函数
window.electronAPI.onUpdateCounter((_event, value) => {
  const oldValue = Number(counter.innerText)
  const newValue = oldValue + value
  counter.innerText = newValue
})
```

### 可选：返回一个回复
对于从主进程到渲染器进程的 IPC，可以从 `ipcRenderer.on` 回调中将回复发送回主进程。

通过 `event.sender.send()` 返回数据

```js
// renderer.js (Renderer Process)
const counter = document.getElementById('counter')

window.electronAPI.onUpdateCounter((event, value) => {
  const oldValue = Number(counter.innerText)
  const newValue = oldValue + value
  counter.innerText = newValue
  // 再原有基础加上这句话，返回数据
  event.sender.send('counter-value', newValue)
})

// main.js (Main Process)
ipcMain.on('counter-value', (_event, value) => {
  console.log(value) // will print value to Node console
})
```

## 模式 4：渲染器进程到渲染器进程
实现：
* 将主进程作为渲染器之间的消息代理。 这需要将消息从一个渲染器发送到主进程，然后主进程将消息转发到另一个渲染器。
* 从主进程将一个 MessagePort 传递到两个渲染器。 这将允许在初始设置后渲染器之间直接进行通信。

## 对象序列化（传递的对象通过克隆而得）
Electron 的 `IPC` 实现使用 `HTML` 标准的 **结构化克隆算法** 来序列化进程之间传递的对象，这意味着只有某些类型的对象可以通过 IPC 通道传递。

特别是 `DOM` 对象（例如 `Element，Location 和 DOMMatrix`），`Node.js` 中由 `C++` 类支持的对象（例如 `process.env，Stream` 的一些成员）和 `Electron` 中由 `C++` 类支持的对象（例如 `WebContents、BrowserWindow 和 WebFrame`）无法使用结构化克隆序列化。

## renderer.js 不能使用 ipcRenderer 的理由
`renderer.js` 不能使用 `Node.js API`，所以不能使用 `require` 把 `ipcRenderer` 导入进来。 
 
所以才需要在 `preload.js` 中通过 `contextBridge` 定义变量或函数供 `render.js` 使用，然后在函数内使用 `ipcRenderer` 来进行进程间的通信

## Electron 中的消息端口（`MessagePort`） 
`MessagePort` 是一个允许在不同上下文之间传递消息的Web功能。
