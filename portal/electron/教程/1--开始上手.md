- [Electron是什么？](#electron是什么)
- [创建你的应用程序](#创建你的应用程序)
  - [创建简单程序](#创建简单程序)
  - [管理窗口的生命周期](#管理窗口的生命周期)
    - [关闭所有窗口时退出应用 (Windows \& Linux)](#关闭所有窗口时退出应用-windows--linux)
    - [如果没有窗口打开则打开一个窗口 (macOS)](#如果没有窗口打开则打开一个窗口-macos)
  - [通过预加载脚本从渲染器访问Node.js。](#通过预加载脚本从渲染器访问nodejs)
  - [打包并分发您的应用程序](#打包并分发您的应用程序)

# Electron是什么？
`Electron` 是一个使用 `JavaScript、HTML 和 CSS` 构建桌面应用程序的框架。 嵌入 `Chromium` 和 `Node.js` 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux

# 创建你的应用程序
## 创建简单程序
1、在自定义项目的文件夹内运行 `npm init`。  
`author` 与 `description` 可为任意值，但对于应用打包是必填项。**如果这两个值没填，那么打包会报错，一定要填。**

2、安装 `electron` 包
```
npm install --save-dev electron

<!-- 安装失败就用 cnpm 下载 -->
npm install -g cnpm --registry=https://registry.npm.taobao.org
cnpm install --save-dev electron
```
3、添加启动命令
```
  "scripts": {
    "start": "electron ."
  },
```
4、创建主进程，在主目录创建入口文件 `main.js`  

5、创建页面，在主目录创建 `index.html` ，设置展示的 html 内容  

6、引入 `app` 和 `BrowserWindow` 模块
* `app` 模块，它控制应用程序的事件生命周期。
* `BrowserWindow` 模块，它创建和管理应用程序 窗口。
```js
const { app, BrowserWindow } = require('electron')
```

7、声明创建窗口函数  
将 `index.html` 加载进一个新的 `BrowserWindow` 实例。

您应用中的每个页面都在一个单独的进程中运行，我们称这些**进程**为 **渲染器 (renderer)** 。
```js
const createWindow = () => {
  const win = new BrowserWindow({
    width: 800,
    height: 600
  })

  win.loadFile('index.html')
}
```

8、打开窗口  
在 `Electron` 中，只有在 `app` 模块的 `ready` 事件被激发后才能创建浏览器窗口。 您可以通过使用 `app.whenReady() `API来监听此事件。 在 `whenReady()` 成功后调用`createWindow()`。
```js
app.whenReady().then(() => {
    createWindow()
})
```

## 管理窗口的生命周期
使用 **进程** 全局的 `platform` 属性来专门为某些操作系统运行代码。

`Electron` 目前只支持三个平台：`win32 (Windows), linux (Linux) 和 darwin (macOS)` 。

`Windows & Linux` 在关闭所有窗口后需退出应用，`macOS` 在关闭所有窗口后程序还是会在后台运行

### 关闭所有窗口时退出应用 (Windows & Linux)
在 Windows 和 Linux 上，关闭所有窗口通常会完全退出一个应用程序。

为了实现这一点，你需要监听 `app` 模块的 `'window-all-closed'` 事件。如果用户不是在 `macOS(darwin)` 上运行程序，则调用 `app.quit()`。
```js
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit()
})
```

### 如果没有窗口打开则打开一个窗口 (macOS)
当 `Linux` 和 `Windows` 应用在没有窗口打开时退出了，`macOS` 应用通常即使在没有打开任何窗口的情况下也继续运行，并且在没有窗口可用的情况下激活应用时会打开新的窗口。

为了实现这一特性，监听 `app` 模块的 `activate` 事件。如果没有任何浏览器窗口是打开的，则调用 `createWindow()` 方法。

因为窗口无法在 `ready` 事件前创建，你应当在你的应用初始化后仅监听 `activate` 事件。 通过在您现有的 `whenReady() `回调中附上您的事件监听器来完成这个操作。
```js
app.whenReady().then(() => {
  createWindow()

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})
```

## 通过预加载脚本从渲染器访问Node.js。
**背景知识：**   
Electron 进程分为主进程和渲染器进程（即 Browser 渲染进程）。主进程无法访问渲染器进程的文档上下文（即无法访问 DOM）， 它们存在于完全不同的进程！

**为什么预加载脚本：**  
预加载脚本在渲染器进程加载之前加载，并有权访问两个 渲染器全局 (例如 window 和 document) 和 Node.js 环境。

1、创建预加载脚本 `preload.js`
```js
// 监听 DOMContentLoaded 事件
window.addEventListener('DOMContentLoaded', () => {
  // 该函数的作用是替换 selector 元素的文本
  const replaceText = (selector, text) => {
    const element = document.getElementById(selector)
    if (element) element.innerText = text
  }

  // 这里是分别给 DOM 元素设置版本号
  // chrome、node 和 electron 的版本号通过 process.versions 属性获取
  for (const dependency of ['chrome', 'node', 'electron']) {
    replaceText(`${dependency}-version`, process.versions[dependency])
  }
})
```

2、将脚本附加到渲染器流程，通过 `webPreferences.preload` 选项
```js
const path = require('node:path')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 800,
    height: 600,
    // 设置预加载脚本的路径
    webPreferences: {
      preload: path.join(__dirname, 'preload.js')
    }
  })
  win.loadFile('index.html')
}
```

## 打包并分发您的应用程序
最快捷的打包方式是使用 `Electron Forge`。

1、将 `Electron Forge` 添加到您应用的开发依赖中，并使用其`"import"`命令设置 `Forge` 的脚手架：
```
npm install --save-dev @electron-forge/cli
npx electron-forge import
```

2、使用 Forge 的 make 命令来创建可分发的应用程序：
```
npm run make
// 即执行 electron-forge make
```
3、如果打包遇上 `ELIFECYCLE` 等连接超时的问题，设置 `electron mirror`
```
npm config set ELECTRON_MIRROR https://npmmirror.com/mirrors/electron/
```