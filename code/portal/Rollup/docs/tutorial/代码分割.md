# 代码分割

- [代码分割](#代码分割)
  - [一、处理动态依赖（动态 import）](#一处理动态依赖动态-import)
    - [1. 示例文件结构](#1-示例文件结构)
    - [2. 代码实现](#2-代码实现)
    - [3. 打包与运行](#3-打包与运行)
    - [4. 动态依赖的文件再依赖其他文件](#4-动态依赖的文件再依赖其他文件)
  - [二、多入口共享公共代码](#二多入口共享公共代码)
    - [1. 示例文件结构](#1-示例文件结构-1)
    - [2. 代码实现](#2-代码实现-1)
    - [3. 打包与结果](#3-打包与结果)
  - [三、多入口共享公共代码更多情况分析](#三多入口共享公共代码更多情况分析)
  - [手动拆分代码](#手动拆分代码)
  - [getModuleInfo](#getmoduleinfo)
    - [介绍](#介绍)
      - [核心定义](#核心定义)
      - [基础使用方式](#基础使用方式)
    - [用 getModuleInfo 处理多入口共享](#用-getmoduleinfo-处理多入口共享)
      - [1. 核心插件 + 配置](#1-核心插件--配置)
      - [2. 完整 Rollup 配置](#2-完整-rollup-配置)
      - [3. 运行结果](#3-运行结果)
    - [合并多个组件下的相同语言的 js 文件](#合并多个组件下的相同语言的-js-文件)
      - [问题分析](#问题分析)
      - [实现代码](#实现代码)
      - [实际情况分析](#实际情况分析)

代码分割是指
  
1. 有些情况下 `Rollup` 会自动将代码拆分成块，例如动态加载或多个入口点
2. 也可以通过 `output.manualChunks` 选项显式地告诉 Rollup 将哪些模块拆分成单独的块

## 一、处理动态依赖（动态 import）

动态依赖指的是通过 `import()` 语法异步加载的模块，`Rollup` 会自动将这类模块拆分为独立的 `chunk`（代码块），实现按需加载，避免把所有代码打包到一个文件里。

### 1. 示例文件结构

```txt
src/
├── main.js       # 主入口，包含动态导入
└── utils.js      # 被动态导入的依赖模块
rollup.config.js  # Rollup 配置文件
```

### 2. 代码实现

(1) 依赖模块：src/utils.js

```javascript
// 工具函数，作为动态依赖
export const formatDate = (date) => {
  return new Intl.DateTimeFormat('zh-CN').format(date);
};

export const sum = (a, b) => a + b;
```

(2) 主入口：src/main.js

```javascript
console.log('主模块加载完成');

// 动态导入 utils 模块（异步加载）
document.getElementById('load-utils').addEventListener('click', async () => {
  // 动态 import 是异步的，返回一个 Promise
  const utils = await import('./utils.js');
  console.log('utils 模块动态加载完成');
  console.log('格式化日期：', utils.formatDate(new Date()));
  console.log('求和：', utils.sum(10, 20));
});
```

(3) Rollup 配置：rollup.config.js

```javascript
export default {
  // 入口文件
  input: './src/main.js',
  output: {
    // 输出目录（动态依赖会生成多个文件，必须用 dir 而非 file）
    dir: './dist',
    // 输出格式：es 保持 ES 模块语法（适合浏览器原生支持或配合构建工具）
    format: 'es',
    // 生成的 chunk 文件名格式（[name] 是模块名，[hash] 是哈希值，避免缓存）
    entryFileNames: '[name].[hash].js',
    chunkFileNames: '[name].[hash].js'
  }
};
```

### 3. 打包与运行

(1) 安装 Rollup

```bash
npm install rollup --save-dev
```

(2) 执行打包

```bash
npx rollup -c rollup.config.js
```

(3) 打包结果

dist 目录下会生成两个文件：

- `main.xxx.js`：主入口代码（包含点击事件逻辑，但不包含 utils 代码）；
- `utils.xxx.js`：动态导入的 utils 模块代码（独立 chunk）。

(4) 验证效果

创建 `dist/index.html` 测试：

```html
<!DOCTYPE html>
<html>
<body>
  <button id="load-utils">加载 utils 模块</button>
  <script type="module" src="./main.xxx.js"></script>
</body>
</html>
```

打开页面后，初始只加载 `main.xxx.js`；点击按钮时，浏览器才会异步请求并加载 `utils.xxx.js`，实现按需加载。

### 4. 动态依赖的文件再依赖其他文件

```txt
src/
├── main.js           # 主入口，包含动态导入
├── utils.js          # 被动态导入的依赖模块
└── utils-shared.js   # 被 utils.js 导入的模块
rollup.config.js      # Rollup 配置文件
```

(1) `utils.js` 静态导入 `utils-shared.js`，生成 2 个文件：

- `main.xxx.js`：主入口代码（不包含 utils 代码）；
- `utils.xxx.js`：独立 chunk（包含 `utils-shared.js` 代码）。

(2) `utils.js` 动态导入 `utils-shared.js`，生成 3 个文件：

- `main.xxx.js`：主入口代码（不包含 utils 代码）；
- `utils.xxx.js`：独立 chunk（不包含 `utils-shared.js` 代码）。
- `utils-shared.xxx.js`：独立 chunk。

## 二、多入口共享公共代码

当项目有多个入口文件（如多页面应用），且多个入口依赖同一个公共模块时，`Rollup` 可以自动提取公共代码到独立的 `chunk`，避免重复打包，减小整体体积。

注意：**不管是动态导入或者静态导入都会被 `Rollup` 识别并提取公共代码**。

### 1. 示例文件结构

```txt
src/
├── entry1.js     # 入口1
├── entry2.js     # 入口2
└── common.js     # 公共依赖（entry1 和 entry2 都使用）
rollup.config.js  # Rollup 配置文件
```

### 2. 代码实现

(1) 公共模块：src/common.js

```javascript
// 多个入口共享的公共函数
export const logInfo = (msg) => {
  console.log(`[INFO] ${new Date().toLocaleTimeString()}: ${msg}`);
};

export const version = '1.0.0';
```

(2) 入口1：src/entry1.js

```javascript
import { logInfo, version } from './common.js';

logInfo('入口1加载完成，版本：' + version);
export const entry1Fn = () => '这是入口1的函数';
```

(3) 入口2：src/entry2.js

```javascript
import { logInfo, version } from './common.js';

logInfo('入口2加载完成，版本：' + version);
export const entry2Fn = () => '这是入口2的函数';
```

(4) Rollup 配置：rollup.config.js

```javascript
export default {
  // 多入口配置：对象形式，key 是输出的 chunk 名，value 是入口文件路径
  input: {
    entry1: './src/entry1.js',
    entry2: './src/entry2.js'
  },
  output: {
    dir: './dist',
    format: 'es',
    entryFileNames: '[name].js',
    // 关键：提取公共代码到 common.js（Rollup 会自动识别共享依赖）
    chunkFileNames: 'common.js'
  }
};
```

### 3. 打包与结果

(1) 执行打包

```bash
npx rollup -c rollup.config.js
```

(2) 打包结果

dist 目录下生成 3 个文件：

- `entry1.js`：入口1的代码（仅包含入口1特有逻辑，不再包含 common 代码）；
- `entry2.js`：入口2的代码（仅包含入口2特有逻辑）；
- `common.js`：提取的公共代码（common.js 的内容）。

(3) 验证共享效果

`entry1.js` 和 `entry2.js` 中会通过 `import './common.js'` 引入公共模块，而非重复打包 common 的代码，大幅减少了代码冗余。

## 三、多入口共享公共代码更多情况分析

项目结构：

```txt
src/
├── entry1.js     # 入口1
├── entry2.js     # 入口2
├── common1.js    # entry1 依赖
└── shared.js     # 公共依赖（entry1 和 entry2 都使用）
rollup.config.js  # Rollup 配置文件
```

下面对在默认配置下各种情况分析：

(1) `entry1.js` 和 `entry2.js` 都静态或动态导入 `shared.js`，但 `entry1.js` 还额外静态导入 `common1.js`。生成 3 个文件：

- `entry1.js`
- `entry2.js`
- `shared-[hash].js`

`entry1.js` 和 `entry2.js` 都会通过 `import './shared-[hash].js'` 引入共享的 `shared.js` 代码。  
`entry1.js` 会额外包含 `common1.js` 的代码。

(2) `entry1.js` 和 `entry2.js` 都静态或动态导入 `shared.js`，但 `entry1.js` 还额外动态导入 `common1.js`。生成 4 个文件：

- `entry1.js`
- `entry2.js`
- `shared-[hash].js`
- `common1-[hash].js`

`entry1.js` 和 `entry2.js` 都会通过 `import './shared-[hash].js'` 引入共享的 `shared.js` 代码。  
`entry1.js` 会额外通过 `import('./common1-[hash].js')` 异步加载 `common1.js`。

## 手动拆分代码

参考 [output.manualChunks](../API/Configuration%20Options.md#outputmanualChunks) 章节。
  
## getModuleInfo

### 介绍

#### 核心定义

`getModuleInfo` 是 Rollup 插件钩子中可通过 `this` 调用的方法，语法：

```javascript
this.getModuleInfo(moduleId: string): ModuleInfo | null
```

或者你可以在 `manualChunks` 的回调函数中通过其第二个参数获得：

```js
manualChunks(id, { getModuleInfo }) {
  // 使用 getModuleInfo(id) 获取模块信息
}
```

它接收**模块唯一 ID**（通常是文件路径），返回该模块的元信息对象（`ModuleInfo`），核心属性如下（重点关注和依赖/入口相关的）：

| 属性名                | 含义                                                                 |
| --------------------- | -------------------------------------------------------------------- |
| `id`                  | 模块唯一标识（绝对路径/相对路径）                                    |
| `importers`           | 静态导入当前模块的所有模块 ID 集合（数组）                           |
| `dynamicImporters`    | 动态导入（`import()`）当前模块的所有模块 ID 集合（数组）             |
| `isEntry`             | 当前模块是否是配置的入口模块（多入口时区分入口/非入口）              |
| `isDynamicEntry`      | 当前模块是否是动态导入的入口模块（被 `import()` 触发的独立 chunk）   |
| `dependencies`        | 当前模块静态依赖的所有模块 ID 集合（数组）                           |
| `dynamicDependencies` | 当前模块动态依赖的所有模块 ID 集合（数组）                           |

#### 基础使用方式

`getModuleInfo` 必须在 Rollup 插件的**异步/同步钩子**中使用（如 `buildEnd`、`generateBundle`、`resolveId` 等），基础插件框架：

```javascript
const moduleAnalysisPlugin = {
  name: 'module-analysis-plugin', // 插件名（必填，用于调试/报错）
  async buildEnd() { // 打包结束后触发的钩子
    // 1. 获取所有被处理的模块 ID
    const allModuleIds = this.getModuleIds();
    
    // 2. 遍历每个模块，获取元信息
    for (const moduleId of allModuleIds) {
      const moduleInfo = this.getModuleInfo(moduleId);
      if (!moduleInfo) continue;

      // 3. 分析模块信息（示例：打印动态依赖）
      if (moduleInfo.dynamicDependencies.length > 0) {
        console.log(`模块 [${moduleId}] 有动态依赖：`, moduleInfo.dynamicDependencies);
      }
    }
  }
};
```

### 用 getModuleInfo 处理多入口共享

Rollup 默认会自动提取多入口公共代码，但通过 `getModuleInfo`，你可以**精细化分析公共依赖、定制更灵活的公共 chunk 拆分规则**（比如按“被多少个入口依赖”来决定是否拆分、按模块类型拆分公共代码）。

***

假如实现以下需求：

1. 找出被**超过 1 个入口**依赖的模块（核心公共依赖），将其拆分并命名成 `common-core.js`；
   1. 默认配置下也会实现该功能，但这里通过 `getModuleInfo` 来手动实现，便于理解和扩展。
2. 被 1 个入口依赖的文件 默认会包含在入口文件，但是也将其拆分并命名为 `common-other.js`。

项目结构：

```txt
src/
├── entry1.js (入口1)
├── entry2.js (入口2)
├── common-core.js (被 entry1、entry2 都依赖 → 核心公共)
└── common-other.js (仅被 entry1 依赖 → 普通公共)
```

#### 1. 核心插件 + 配置

```javascript
// rollup-multi-entry-plugin.js
export default function multiEntryPlugin() {
  let entryModules = []; // 存储所有入口模块ID
  let coreCommonModules = new Set(); // 核心公共模块（被>1个入口依赖）

  return {
    name: 'multi-entry-plugin',
    // 第一步：在 buildStart 钩子中获取所有入口模块ID
    buildStart(options) {
      // 多入口的 input 是对象，提取所有入口路径
      entryModules = Array.isArray(options.input) 
        ? options.input 
        : Object.values(options.input);
    },

    // 第二步：在 generateBundle 前分析公共依赖
    async generateBundle() {
      const allModuleIds = this.getModuleIds();

      // 遍历所有模块，分析被多少个入口依赖
      for (const moduleId of allModuleIds) {
        const moduleInfo = this.getModuleInfo(moduleId);
        if (!moduleInfo || moduleInfo.isEntry) continue; // 跳过入口模块

        // 计算当前模块被多少个入口依赖（静态导入）
        const entryImporterCount = moduleInfo.importers.filter(importerId => 
          entryModules.includes(importerId)
        ).length;

        // 被>1个入口依赖 → 标记为核心公共模块
        if (entryImporterCount > 1) {
          coreCommonModules.add(moduleId);
          console.log(`核心公共模块：${moduleId}（被${entryImporterCount}个入口依赖）`);
        }
      }
    },

    // 第三步：定制 manualChunks，基于分析结果拆分公共代码
    manualChunks(id) {
      const moduleInfo = this.getModuleInfo(id);
      if (!moduleInfo) return;

      // 核心公共模块 → 拆到 common-core.js
      if (coreCommonModules.has(id)) {
        return 'common-core';
      }

      // 普通公共模块（被1个入口依赖）→ 拆到 common-other.js
      const entryImporterCount = moduleInfo.importers.filter(importerId => 
        entryModules.includes(importerId)
      ).length;
      if (entryImporterCount === 1 && !moduleInfo.isEntry) {
        return 'common-other';
      }
    }
  };
}
```

#### 2. 完整 Rollup 配置

```javascript
// rollup.config.js
import multiEntryPlugin from './rollup-multi-entry-plugin.js';

export default {
  input: {
    entry1: './src/entry1.js',
    entry2: './src/entry2.js'
  },
  output: {
    dir: './dist',
    format: 'es',
    entryFileNames: '[name].js',
    chunkFileNames: '[name].js'
  },
  plugins: [multiEntryPlugin()]
};
```

#### 3. 运行结果

执行 `npx rollup -c` 后，dist 目录会生成：

- `entry1.js`、`entry2.js`：入口代码（无冗余公共代码）；
- `common-core.js`：核心公共模块（common-core.js）；
- `common-other.js`：普通公共模块（common-other.js）；

### 合并多个组件下的相同语言的 js 文件

#### 问题分析

需求：假设有像下面的 `foo` 组件那样的多个组件，每个组件的文件夹下有相同语言的 `js` 文件（如 `en.js`），并且组件动态导入这些 `js` 文件，那么打包结构会有多个 `en.js`。现在希望将这些相同语言的 `js` 文件合并成一个公共的 `js`，例如 `en.js`。

**代码**：

**foo/index.js**：

```javascript
// 示例中的函数
function getTranslatedStrings(currentLanguage) {
    switch (currentLanguage) {
        case 'en':
            return import('./foo.strings.en.js');
        case 'de':
            return import('./foo.strings.de.js');
        case 'fr':
            return import('./foo.strings.fr.js');
        default:
            return import('./foo.strings.en.js');
    }
}

export default function FooComponent() {
    // 组件逻辑
}
```

**foo.strings.en.js**：

```javascript
export default {
    title: "Hello",
    description: "Welcome to our application",
    button: "Click me"
};
```

**项目结构**：

```txt
src/
├── components/
│   ├── foo/
│   │   ├── index.js           # 包含示例中的 getTranslatedStrings 函数
│   │   ├── foo.strings.en.js  # 英语字符串
│   │   ├── foo.strings.de.js  # 德语字符串
│   │   └── foo.strings.fr.js  # 法语字符串
│   ├── bar/
│   │   ├── index.js
│   │   ├── bar.strings.en.js
│   │   ├── bar.strings.de.js
│   │   └── bar.strings.fr.js
│   ├── baz/
│   │   ├── index.js
│   │   ├── baz.strings.en.js
│   │   └── baz.strings.de.js
└── main.js                    # 入口文件
```

使用默认配置打包后，Rollup 可能会生成如下的 chunk 文件：

```txt
dist/
├── main.js                    # 主 chunk
├── chunks/
│   ├── foo.strings.en.js     # 独立 chunk
│   ├── foo.strings.de.js     # 独立 chunk
│   ├── bar.strings.en.js     # 独立 chunk
│   ├── bar.strings.de.js     # 独立 chunk
│   ├── baz.strings.en.js     # 独立 chunk
│   ├── baz.strings.de.js     # 独立 chunk
│   └── ...                   # 更多小 chunk
```

**问题详细分析**

**假设场景：**

1. 有 10 个组件
2. 每个组件支持 5 种语言
3. 每个语言文件约 1KB

**默认 Rollup 打包结果：**

- **总 chunk 数**：`10 组件 × 5 语言 = 50 个 chunk`
- **每个 chunk 大小**：约 1KB
- **HTTP 请求数**：最多 50 个（如果用户切换语言，实际上只会加载一种语言的 10 个文件）

**理想打包结果（手动配置后）：**

- **总 chunk 数**：5 个（每种语言一个 chunk）
- **每个 chunk 大小**：约 10KB（合并了所有组件的同种语言字符串）
- **HTTP 请求数**：1 个（只需加载用户当前语言的 chunk）

***

#### 实现代码

```js
function manualChunks(id, { getModuleInfo }) {
	const match = /.*\.strings\.(\w+)\.js/.exec(id);
	if (match) {
		const language = match[1]; // 例如 “en”
		const dependentEntryPoints = [];

		// 在这里，我们使用 Set 一次性处理每个依赖模块
		// 它可以阻止循环依赖中的无限循环
		const idsToHandle = new Set(getModuleInfo(id).dynamicImporters);

		for (const moduleId of idsToHandle) {
			const { isEntry, dynamicImporters, importers } =
				getModuleInfo(moduleId);
			if (isEntry || dynamicImporters.length > 0)
				dependentEntryPoints.push(moduleId);

			// Set 迭代器足够智能，可以处理
			// 在迭代过程中添加元素
			for (const importerId of importers) idsToHandle.add(importerId);
		}

		// 如果仅有一个入口，那么我们会根据入口名
		// 将它放到独立的 chunk 中
		if (dependentEntryPoints.length === 1) {
			return `${
				dependentEntryPoints[0].split('/').slice(-1)[0].split('.')[0]
			}.strings.${language}`;
		}
		// 对于多个入口，我们会把它放到“共享”的 chunk 中
		if (dependentEntryPoints.length > 1) {
			return `shared.strings.${language}`;
		}
	}
}
```

#### 实际情况分析

**场景：单入口应用**

假设结构如下：

```txt
main.js → 导入 FooComponent → FooComponent 动态导入 foo.strings.en.js
       → 导入 BarComponent → BarComponent 动态导入 bar.strings.en.js
```

1. **对于 `foo.strings.en.js`**：
   - `dynamicImporters` = `[FooComponent]`
   - `FooComponent` 的 `isEntry` = `false`
   - `FooComponent` 的 `dynamicImporters` = `[main.js]`（因为 main.js 可能动态导入 FooComponent，或者直接导入但不是动态导入）
   - 如果 `main.js` 是静态导入 `FooComponent`，则 `FooComponent` 的 `dynamicImporters.length` = `0`
   - 因此 `FooComponent` 不会被加入 `dependentEntryPoints`

2. **查找链向上**：
   - 通过 `importers` 找到 `main.js`
   - `main.js` 的 `isEntry` = `true`
   - 所以 `main.js` 被加入 `dependentEntryPoints`

3. **最终结果**：
   - `dependentEntryPoints` = `[main.js]`
   - `dependentEntryPoints.length === 1`
   - 返回 `main.strings.en`（而不是 `shared.strings.en`）

**场景：多入口应用**

```txt
src/
├── app1/
│   ├── index.js (入口1) → 导入 FooComponent
│   └── ...
├── app2/
│   ├── index.js (入口2) → 导入 BarComponent
│   └── ...
└── shared/
    ├── FooComponent/    → 动态导入 foo.strings.en.js
    └── BarComponent/    → 动态导入 bar.strings.en.js
```

**分析**：

1. `foo.strings.en.js` 被 `FooComponent` 动态导入
2. `FooComponent` 被 `app1/index.js` 和 `app2/index.js` 都导入
3. 向上查找会找到两个入口：`app1/index.js` 和 `app2/index.js`
4. `dependentEntryPoints` = `[app1/index.js, app2/index.js]`
5. `dependentEntryPoints.length > 1`
6. 返回 `shared.strings.en`

***

**总结**：

- **单入口应用（只有一个 main.js）**：
  - 生成 `main.strings.en.js`（或以入口文件命名的 chunk）
  - **不会**生成 `shared.strings.en.js`

- **多入口应用（多个入口共享组件）**：
  - 生成 `shared.strings.en.js`
  - 这是为了避免代码重复，让多个入口共享同一个语言 chunk
