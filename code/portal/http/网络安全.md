# 前端常见攻击模式与防范方法

- [前端常见攻击模式与防范方法](#前端常见攻击模式与防范方法)
  - [1. XSS（跨站脚本攻击）](#1-xss跨站脚本攻击)
    - [攻击模式](#攻击模式)
      - [1. 反射型 XSS](#1-反射型-xss)
      - [2. 存储型 XSS](#2-存储型-xss)
      - [3. DOM型 XSS](#3-dom型-xss)
    - [防范方法](#防范方法)
  - [2. CSRF（跨站请求伪造）](#2-csrf跨站请求伪造)
    - [攻击模式](#攻击模式-1)
    - [防范方法](#防范方法-1)
  - [3. 点击劫持（Clickjacking）](#3-点击劫持clickjacking)
    - [攻击模式](#攻击模式-2)
    - [防范方法](#防范方法-2)
  - [4. SQL注入](#4-sql注入)
    - [攻击模式](#攻击模式-3)
    - [防范方法](#防范方法-3)
  - [5. 中间人攻击](#5-中间人攻击)
    - [攻击模式](#攻击模式-4)
    - [防范方法](#防范方法-4)
  - [6. 不安全的第三方依赖](#6-不安全的第三方依赖)
    - [攻击模式](#攻击模式-5)
    - [防范方法](#防范方法-5)
  - [综合安全措施](#综合安全措施)
    - [1. 安全响应头配置](#1-安全响应头配置)
    - [2. 使用 输入验证框架](#2-使用-输入验证框架)
    - [3. 安全编码规范](#3-安全编码规范)
    - [4. 监控和日志](#4-监控和日志)

## 1. XSS（跨站脚本攻击）

在 XSS 攻击（Cross-Site Scripting）中，攻击者向受信任的网站注入恶意脚本代码，当其他用户访问该网站时，这些脚本会在用户的浏览器中执行，从而窃取用户信息、劫持会话或进行其他恶意操作。

基本工作流程：

1. 攻击者发现网站存在 `XSS` 漏洞
2. 构造恶意脚本并注入到目标网站
3. 用户访问包含恶意脚本的页面
4. 恶意脚本在用户浏览器中执行
5. 攻击者可以窃取用户数据、劫持会话、重定向用户等

### 攻击模式

#### 1. 反射型 XSS

恶意脚本作为请求的一部分发送到服务器，服务器立即将其反射回响应中，并在用户浏览器中执行。

```js
// 攻击者构造恶意URL
http://vulnerable-site.com/search?q=<script>alert('XSS')</script>

// 服务器返回的HTML（未过滤）
<p>搜索结果：<script>alert('XSS')</script></p>
```

#### 2. 存储型 XSS

恶意脚本永久存储在目标服务器上（如数据库），每次用户访问包含该数据的页面时都会执行。

```js
// 1. 攻击者在评论区注入脚本
评论内容：<script>stealCookie()</script>

// 2. 脚本存储到数据库
// 3. 其他用户访问评论页面时执行脚本
```

#### 3. DOM型 XSS

漏洞存在于客户端 JavaScript 代码中，不涉及服务器端。

恶意脚本通过修改 DOM 树来实施攻击。通常是在用户修改 DOM 树的代码恶意注入脚本实现。

```js
// 脆弱的代码
const urlParams = new URLSearchParams(window.location.search);
const name = urlParams.get('name');
document.getElementById('welcome').innerHTML = `欢迎, ${name}`;

// 攻击者构造URL
// http://example.com?name=<img src=x onerror=alert('XSS')>
```

常见漏洞函数：

- `innerHTML`
- `outerHTML`
- `document.write()`
- `eval()`
- `setTimeout()/setInterval()` 中使用字符串
- `location/document.location` 的不安全使用

### 防范方法

1、输入过滤与转义

```javascript
function escapeHTML(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}
```

2、使用Content Security Policy（CSP）

```js
// HTTP响应头设置
Content-Security-Policy: default-src 'self'; script-src 'self' trusted.com
```

3、设置 HttpOnly 和 Secure Cookie

```js
Set-Cookie: sessionId=abc123; HttpOnly; Secure

// 客户端无法通过 JavaScript 访问 HttpOnly Cookie
console.log(document.cookie); // 不会显示标记为HttpOnly的cookie
```

## 2. CSRF（跨站请求伪造）

### 攻击模式

CSRF（Cross-Site Request Forgery） 是一种攻击方式，攻击者利用受害者已登录的会话来伪造请求，在受害者不知情的情况下执行非预期的操作。

基本工作流程：

1. 用户登录并信任了某个网站（如银行网站）
2. 服务器向用户浏览器设置了认证 `Cookie`
3. 用户在没有退出登录的情况下访问了恶意网站
4. 用户点击了恶意网站的表单、链接或按钮
5. 恶意网站发送请求到目标网站
6. 浏览器自动发送带有认证Cookie的请求
7. 服务器误认为这是用户的合法请求

具体例子：

1. 以银行转钱为例。`img` 标签的 `src` 属性原来是图片的url，但是被改成了银行转钱的url，这样页面加载时就访问url，转钱了。
2. 对于 Post 请求，页面被恶意注入一个 form 表单，当页面加载时，提交表单发送一个 Post 请求，进行转钱。

### 防范方法

```javascript
// 1. 使用CSRF Token
// 后端生成Token，前端提交时携带，后端接收到请求便验证 Token 的有效性
fetch('/api/data', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': getCSRFToken()
  }
});

// 2. SameSite Cookie属性。设置以下的值：
// - 'Strict'，仅在同站请求中发送Cookie
// - 'Lax': 允许部分跨站请求（如导航）发送Cookie
// Set-Cookie: session=value; SameSite=Strict

// 3. 验证 Referer/Origin 头部（headers.origin、headers.referer）
app.use((req, res, next) => {
  const origin = req.headers.origin || req.headers.referer;
  if (isValidOrigin(origin)) {
    next();
  } else {
    res.status(403).send('Invalid request origin');
  }
});

// 4. 通过自定义请求头验证请求来源
```

## 3. 点击劫持（Clickjacking）

### 攻击模式

使用透明 `iframe` 覆盖页面，诱导用户点击隐藏的恶意按钮或链接。

这可以用来窃取登录凭据或在用户无意中获得安装恶意软件的许可。

### 防范方法

```javascript
// 1. 设置X-Frame-Options头部
// X-Frame-Options: DENY 或 SAMEORIGIN

// 2. 使用CSP的frame-ancestors指令
// Content-Security-Policy: frame-ancestors 'self'

// 3. JavaScript防御（后备方案）
if (window.top !== window.self) {
  window.top.location = window.self.location;
}
```

## 4. SQL注入

### 攻击模式

攻击者通过输入恶意 SQL 代码，操纵前端发送的请求参数，进而影响后端数据库查询。

![sql injection](./imgs/Sql%20Injection.png)

### 防范方法

```javascript
// 1. 对输入字段进行验证和过滤，防止用户在输入的字段中包含恶意 SQL 语句
function validateInput(input) {
  // 限制特殊字符
  const dangerousChars = /['"\\;()]/;
  if (dangerousChars.test(input)) {
    return false;
  }
  return true;
}

// 2. 使用参数化查询（后端实现）
// 3. ORM框架自动处理参数转义
```

## 5. 中间人攻击

中间人攻击即 `Man-in-the-middle (MitM)`

### 攻击模式

第三方拦截网络服务器和客户端（浏览器）之间的交互，并模拟网络服务器以获取数据（如登录凭据或信用卡信息）。

开放式 `Wi-Fi` 网络是执行这种攻击的典型手段。

### 防范方法

1. 连接安全的 Wi-Fi 网络，避免使用公共 Wi-Fi 网络进行敏感操作（如登录、支付等）。
2. 使用 HTTPS 和 TLS 加密通信，确保数据传输安全。

## 6. 不安全的第三方依赖

### 攻击模式

某个第三方库有一个安全漏洞，允许攻击者执行远程代码。使用了这个第三方库的应用程序都会成为此攻击的受害者

### 防范方法

1. 定期更新依赖库
2. 使用可信的第三方库

## 综合安全措施

### 1. 安全响应头配置

```nginx
# Nginx配置示例
add_header X-Frame-Options "SAMEORIGIN";
add_header X-XSS-Protection "1; mode=block";
add_header X-Content-Type-Options "nosniff";
add_header Referrer-Policy "strict-origin-when-cross-origin";
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' cdn.example.com";
```

### 2. 使用 输入验证框架

```javascript
// 使用验证库如validator.js
import validator from 'validator';

function sanitizeInput(input) {
  return validator.escape(input);
}

function validateEmail(email) {
  return validator.isEmail(email);
}
```

### 3. 安全编码规范

- 始终对用户输入进行验证和转义
- 使用参数化查询或ORM
- 最小权限原则
- 定期安全审计和代码审查

### 4. 监控和日志

```javascript
// 前端错误监控
window.addEventListener('error', (event) => {
  fetch('/api/log-error', {
    method: 'POST',
    body: JSON.stringify({
      message: event.message,
      url: event.filename,
      line: event.lineno
    })
  });
});

// 可疑行为检测
function detectSuspiciousActivity() {
  const rapidClicks = detectClickSpam();
  const formSpam = detectFormSpam();
  
  if (rapidClicks || formSpam) {
    // 添加验证码或暂时限制
  }
}
```
