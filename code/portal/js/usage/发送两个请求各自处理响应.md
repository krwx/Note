# 发送两个请求各自处理响应

需求：发送两个请求，并且每个请求都有各自的响应处理逻辑，并且返回响应后立刻执行处理逻辑，并且当都各自处理完响应后执行某个最终的操作。

你可以使用 `Promise.all()` 或 `Promise.allSettled()` 来实现这个需求。这样既能保持请求的独立性，又能在两个请求都完成后执行统一的操作。

## 方法一：使用 Promise.all() + 独立处理

```javascript
// 同时发送两个独立的请求
Promise.all([
  fetch('/api/user/1')
    .then(response => response.json())
    .then(userData => {
      // 请求1的独立操作
      console.log('用户数据:', userData);
      displayUserInfo(userData);
      return userData; // 返回数据供后续使用
    }),
    
  fetch('/api/products')
    .then(response => response.json())
    .then(productsData => {
      // 请求2的独立操作
      console.log('产品数据:', productsData);
      renderProducts(productsData);
      return productsData; // 返回数据供后续使用
    })
])
.then(([userData, productsData]) => {
  // 两个请求都完成后的统一操作
  console.log('两个请求都完成了!');
  performFinalOperation(userData, productsData);
})
.catch(error => {
  console.error('某个请求失败了:', error);
});

// 各自的处理函数
function displayUserInfo(user) {
  // ...
}

function renderProducts(products) {
  // ...
}

function performFinalOperation(user, products) {
  // 两个请求都完成后的统一操作
  // ...
}
```

## 方法二：使用 async/await

```javascript
async function fetchData() {
  try {
    // 同时发起两个请求
    const userPromise = fetch('/api/user/1')
      .then(response => response.json())
      .then(userData => {
        // 请求1的独立操作
        handleUserData(userData);
        return userData;
      });
    
    const productsPromise = fetch('/api/products')
      .then(response => response.json())
      .then(productsData => {
        // 请求2的独立操作
        handleProductsData(productsData);
        return productsData;
      });
    
    // 等待两个请求都完成
    const [userData, productsData] = await Promise.all([userPromise, productsPromise]);
    
    // 两个请求都完成后的统一操作
    handleFinalOperation(userData, productsData);
    
  } catch (error) {
    console.error('请求失败:', error);
  }
}

function handleUserData(user) {
  console.log('处理用户数据:', user);
  // 用户相关的独立操作
}

function handleProductsData(products) {
  console.log('处理产品数据:', products);
  // 产品相关的独立操作
}

function handleFinalOperation(user, products) {
  console.log('两个请求都完成了，执行最终操作');
  // 最终的统一操作
}

// 调用函数
fetchData();
```

## 方法三：使用 Promise.allSettled()（推荐用于错误处理）

如果你希望即使某个请求失败，另一个请求的结果也能被处理，并且最终操作仍然执行：

```javascript
Promise.allSettled([
  fetch('/api/user/1')
    .then(response => response.json())
    .then(userData => {
      console.log('用户数据:', userData);
      displayUserInfo(userData);
      return userData;
    })
    .catch(error => {
      console.error('用户请求失败:', error);
      return null; // 返回默认值
    }),
    
  fetch('/api/products')
    .then(response => response.json())
    .then(productsData => {
      console.log('产品数据:', productsData);
      renderProducts(productsData);
      return productsData;
    })
    .catch(error => {
      console.error('产品请求失败:', error);
      return []; // 返回默认值
    })
])
.then(([userResult, productsResult]) => {
  // 无论成功失败，都会执行这里
  const userData = userResult.status === 'fulfilled' ? userResult.value : null;
  const productsData = productsResult.status === 'fulfilled' ? productsResult.value : [];
  
  // 两个请求都完成后的统一操作
  performFinalOperation(userData, productsData);
});
```
