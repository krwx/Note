# 简单数组操作

- [简单数组操作](#简单数组操作)
  - [数组去重](#数组去重)
  - [数组截断](#数组截断)
  - [创建一个包含 0~99 的数组](#创建一个包含-099-的数组)
  - [随机打乱数组顺序](#随机打乱数组顺序)
  - [找到数组中最大值的索引](#找到数组中最大值的索引)
  - [转置矩阵的行和列](#转置矩阵的行和列)

## 数组去重

`arr = [...new Set(arr)]`

## 数组截断

```js
if (searchHistory.value.length > 10) {
  searchHistory.value.length = 10;
}
```

## 创建一个包含 0~99 的数组

```js
const arr = Array.from({ length: 100 }, (_, index) => index);

// or
const arr = Array(100).fill(0).map((_, index) => index);
// 要调用 fill() 方法，因为直接使用 Array(100) 创建的数组是空数组，map() 方法不会遍历未赋值的索引。
```

## 随机打乱数组顺序

```js
const randomArray = arr => arr.sort(() => Math.random() - 0.5);
```

## 找到数组中最大值的索引

```js
const findMaxIndex = arr => arr.indexOf(Math.max(...arr));

// or use reduce
const findMaxIndex = arr => 
  arr.reduce((maxIndex, currentValue, currentIndex, array) => 
    currentValue > array[maxIndex] ? currentIndex : maxIndex, 0);
```

## 转置矩阵的行和列

思路：

1. 矩阵的第一个数组调用 `map()`，转换数组的每一个元素为 它所在列的所有元素组成的新数组。即 1 会转换为 `[1,4,7]`
2. 怎么实现转换？矩阵调用 `map()`，根据 `colIndex` （列索引）提取每一行对应列的元素，形成一个新的数组。

```js
function transpose(matrix) {
  return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
}

console.log((transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]])));
// 输出: [[1,4,7],[2,5,8],[3,6,9]]
```
