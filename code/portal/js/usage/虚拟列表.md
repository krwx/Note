# 虚拟列表

## 原理

![虚拟列表](../img/虚拟列表.png)

假设列表原始长度为15（也可能数十万），绿色区域为包裹列表的容器，紫色窗口为可视区域。

- 图1
  - 展示了未使用虚拟长列表的原始状态。
- 图2
  - 我们**设置列表容器的高度**（绿色背景）使其和图1（未使用虚拟列表）保持一致，但实际存放的 DOM 节点只有紫色窗口能容纳的个数(图中是4个)。
- 图3
  - 当用户滚动一小段距离后，第1行和第2行的一半被遮盖，第5行之后后的空白漏出。此时，可**获取滚动的距离(`scrollTop`)，根据滚动距离和每行的高度计算出被滚出可视区域的行数**。
- 图4
  - 我们需要**删除被滚出可视区的 DOM（第1行）**，同时**新增需要展现的 DOM（第6行）**。
- 图5
  - 在删除隐藏的 DOM 后**设置绿色容器的上 `padding`**，来填充删除 DOM 留下的空缺(图5灰色部分为新增的 `paddingTop`)，来保证透过可视区域的 DOM 节点视觉上没有发生位置变动。
  - `paddingTop` 的值 = 被删除的 DOM 个数 * 每行的高度。
  - 如果不设置 `paddingTop` 的话，假设 `scrollTop` 为 `100px`，当删除第 1 行 DOM 后，第 2 行会立刻顶上来，`scrollTop` 变为 `20px`，浏览器会当作往上滚动，然后触发 `scroll` 事件，添加第 1 行 DOM，删除第 6 行 DOM 。但是浏览器记得最开始的 `scrollTop` 为 `100px`，会设置 `scrollTop` 为 `100px`，再触发滚动事件，此时又会删除第 1 行 DOM，添加第 6 行 DOM。导致不停地删除 DOM 和新增 DOM，形成死循环。

如果使用了 Vue 或者 React，删除隐藏的 DOM，同时新增需要展现的 DOM 的操作只需要设置数据即可(如：`[1,2,3,4,5]` 换成 `[2,3,4,5,6]` )。

## vue3 实现

数据：

1. `dataList`：构造的长列表原始数据
2. `visualList`：根据起点和终点获取要渲染的数据（计算属性）
3. `start`：从长列表数组总截取数据的起点
4. `end`：从长列表数组总截取数据的终点
5. `itemHeight`：单个列表项的高度
6. `paddingTop`：列表容器的上内边距
7. `containerRef`：列表容器 DOM 引用
8. `panelRef`：列表面板 DOM 引用
9. `buffTop`：上缓冲区，防止滚动时出现空白。渲染的 DOM 包含上缓冲区和下缓冲区，避免滚动时出现空白
10. `buffBottom`：下缓冲区，防止滚动时出现空白
11. `count`：实际渲染 DOM 的列表数量

元素层级:

1. `container`：列表容器。设置 `height` 为固定值，设置 `overflow` 为 `scroll` 或 `auto`，绑定 `scroll` 事件
2. `panel`：列表面板。包含所有列表项
3. `item`：列表项。单个列表元素

步骤：

1. 初始化变量
   1. 设置 `visualList` 为 `computed` 属性，用 `start` 和 `end` 截取原始数组。当 `start` 或 `end` 变化时， `visualList` 会自动更新
2. 在 `onMounted` 生命周期钩子中：
   1. 获取单个列表项的高度
   2. 设置列表面板的高度为 原始数据全部渲染后的高度。因为高度超过容器高度，才会出现滚动条，当用户滚动时，`container` 才会触发 `scroll` 事件
   3. 计算可视区域能容纳的列表项数量
   4. 设置初始的 `end` 值： 可视区域能容纳的列表项数量 + 下缓冲区
3. 在 `onScroll` 事件处理函数中：
   1. 获取滚动距离
   2. 计算能容纳的列表项数量的 `newStart` 值
   3. 当 `newStart` 值大于默认上缓冲区时，设置 `start` 值为 `newStart` - 上缓冲区，否则为 0
   4. 更新 `end` 值： `newStart` 值 + 可视区域能容纳的列表项数量 + 下缓冲区
   5. 设置容器的 `paddingTop` 值： `start` 值 * 单个列表项的高度

vue 实现：

```vue
<template>
    <div id="container" class="container" @scroll="onScroll" ref="containerRef">
        <div class="panel" ref="panelRef" :style="{ paddingTop: paddingTop + 'px' }">
            <div v-for ="item in visibleList" :key="item" class="item">{{ item }}</div>
        </div>
    </div>
</template>

<script setup>
import { ref, computed, onMounted } from "vue";

// 原始数据
let raw = Array(100000)
    .fill(0)
    .map((v, i) => `item-${i}`);

//列表容器 DOM
const containerRef = ref(null);
const panelRef = ref(null);
//实际渲染 DOM 的列表数量
let itemCount = 0;

const start = ref(0); // 从长列表数组总截取数据的起点 
const end = ref(1); // 从长列表数组总截取数据的终点
const paddingTop = ref(0); // 列表容器的上内边距
let itemHeight = 1; // 单个列表项的高度
let buffTop = 10; // 上缓冲区
let buffBottom = 10; // 下缓冲区

// 根据起点和终点获取要渲染的数据
const visibleList = computed(() => raw.slice(start.value, end.value));

// 在 mounted 后设置列表容器的高度
onMounted(() => {
    if (containerRef.value) {
        const containerHeight = containerRef.value.clientHeight;
        // 获取单个列表项的高度
        itemHeight = panelRef.value.firstElementChild.offsetHeight;
        // 计算可视区域能容纳的列表项数量
        itemCount = Math.floor(containerHeight / itemHeight);
        end.value = itemCount + buffBottom;

        // 设置列表面板的高度
        panelRef.value.style.height = raw.length * itemHeight + "px";
    }
});

let timer = null;

// 滚动-->根据滚动距离计算起点和终点的下标-->计算属性得到visibleList-->真实DOM被替换 同时设置paddingTop让元素视觉上没跳动
const onScroll = (e) => {
    console.log(e);
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
        // 获取滚动距离
        const scrollTop = e.target.scrollTop;

        // 计算能容纳的列表项数量
        const newStart = Math.floor(scrollTop / itemHeight);

        // 当 newStart 值大于默认上缓冲区时，才需要上缓冲区
        let buff = newStart > buffTop ? buffTop : newStart;
        start.value = newStart - buff; //当滚动后，重新计算起点的位置

        // 设置终点的位置
        end.value = newStart + itemCount + buffBottom;  

        // 设置列表容器的上内边距
        paddingTop.value = start.value * itemHeight;
    }, 200);
}
</script>

<style scoped>
.container {
    height: 100vh;
    overflow: auto;
    border: 2px solid #ccc;
}
</style>
```
