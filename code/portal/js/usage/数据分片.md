# 数据分片

- [数据分片](#数据分片)
  - [js 实现](#js-实现)
  - [vue 实现](#vue-实现)

可以使用分批渲染数据的方式，避免一次性插入大量 DOM 元素导致浏览器主线程阻塞，从而引起页面卡顿。

可以利用 `requestAnimationFrame` 或 `setTimeout` 来分批插入元素，让浏览器有机会在每次插入后进行渲染和响应用户交互。

思路：

1. 设置一个批次大小，比如每次插入 100 个元素。
2. 使用 `requestAnimationFrame` 或 `setTimeout` 在每一帧或指定时间间隔内先计算当前要插入的数据，然后再插入这一批数据。
3. 循环这个过程，直到所有数据都被插入。

## js 实现

- 使用文档片段（`DocumentFragment`）创建DOM元素，然后一次性插入到文档中。
- 使用 `requestAnimationFrame` 或 `setTimeout` 分批插入元素，给浏览器重绘的机会。

```js
function createAndInsertElements(count) {
  const fragment = document.createDocumentFragment();
  const container = document.getElementById('container');
 
  for (let i = 0; i < count; i++) {
    const element = document.createElement('div');
    element.textContent = 'Element ' + i;
    fragment.appendChild(element);
  }
 
  container.appendChild(fragment);
}
 
function batchInsertElements(count, batchSize, callback) {
  let index = 0;
 
  function insertBatch() {
    if (index < count) {
      const batchEnd = Math.min(index + batchSize, count);
      for (; index < batchEnd; index++) {
        createAndInsertElements(1);
      }
      requestAnimationFrame(insertBatch);
    } else {
      callback();
    }
  }
 
  insertBatch();
}
 
// 使用示例
batchInsertElements(10000, 100, () => {
  console.log('All elements inserted');
});
```

在这个示例中， `createAndInsertElements` 函数创建单个元素并将其插入容器中。 `batchInsertElements` 函数接受元素总数、批次大小和回调函数作为参数，它使用 `requestAnimationFrame` 分批插入元素。这种方法可以有效地处理大量 `DOM` 操作，避免 `UI` 冻结。

## vue 实现

- `visibleItems` 为渲染的列表
- 使用 `v-for` 渲染 `visibleItems`
- 使用 `requestAnimationFrame` 分批添加数据到 `visibleItems`

```vue
<template>
  <div class="container">
    <div class="controls">
      <button @click="startRender" :disabled="isRendering">
        {{ isRendering ? '渲染中...' : '开始渲染' }}
      </button>
      <button @click="reset" :disabled="isRendering">重置</button>
      <span class="progress">进度: {{ renderedCount }} / {{ totalCount }}</span>
    </div>
    
    <ul ref="listContainer" class="list-container">
      <li v-for="item in visibleItems" :key="item.id" class="list-item">
        Item #{{ item.id }} - {{ item.text }}
      </li>
    </ul>
    
    <div v-if="isRendering" class="loading">
      正在渲染，请稍候...
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted, onUnmounted } from 'vue'

// 配置参数
const config = {
  totalCount: 100000,      // 总数据量
  batchSize: 100,          // 每批渲染数量
}

// 响应式数据
const listContainer = ref(null)
const visibleItems = ref([])  // 当前已渲染的项目
const isRendering = ref(false)
const renderedCount = ref(0)

// 所有数据
const allItems = Array.from({ length: config.totalCount }, (_, index) => ({
  id: index + 1,
  text: `内容 ${index + 1}`,
}))

// 时间分片渲染
let animationFrameId = null
let startTime = 0

const renderBatch = () => {
  if (renderedCount.value >= config.totalCount) {
    isRendering.value = false
    console.log('渲染完成')
    return
  }

  // 计算本帧应该渲染的数量
  const startIndex = renderedCount.value
  const endIndex = Math.min(
    startIndex + config.batchSize,
    config.totalCount
  )
  
  // 添加新批次到可见列表
  visibleItems.value.push(...allItems.slice(startIndex, endIndex))
  renderedCount.value = endIndex
  
  // 使用 requestAnimationFrame 安排下一批次
  animationFrameId = requestAnimationFrame(renderBatch)
}

const startRender = () => {
  if (isRendering.value) return
  
  isRendering.value = true
  renderedCount.value = 0
  visibleItems.value = []
  startTime = performance.now()
  
  // 开始时间分片渲染
  animationFrameId = requestAnimationFrame(renderBatch)
}

const reset = () => {
  // 停止当前渲染
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId)
    animationFrameId = null
  }
  
  isRendering.value = false
  renderedCount.value = 0
  visibleItems.value = []
}

// 清理
onUnmounted(() => {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId)
  }
})

// 自动开始渲染（可选）
// onMounted(() => {
//   startRender()
// })
</script>

<style scoped>
.container {
  padding: 20px;
}

.controls {
  margin-bottom: 20px;
  padding: 10px;
  background: #f5f5f5;
  border-radius: 4px;
}

button {
  margin-right: 10px;
  padding: 8px 16px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:disabled {
  background: #c0c4cc;
  cursor: not-allowed;
}

.progress {
  margin-left: 20px;
  font-size: 14px;
  color: #666;
}

.list-container {
  height: 600px;
  overflow-y: auto;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  padding: 0;
  margin: 0;
}

.list-item {
  padding: 8px 12px;
  border-bottom: 1px solid #ebeef5;
  list-style: none;
}

.list-item:nth-child(even) {
  background-color: #fafafa;
}

.list-item:hover {
  background-color: #f0f9ff;
}

.loading {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 20px 40px;
  border-radius: 8px;
  z-index: 1000;
}
</style>
```
