# 相等（==）

- [相等（==）](#相等)
  - [介绍](#介绍)
  - [`![] == []` 为 true 的解析](#---为-true-的解析)

## 介绍

相等（==）运算符检查其两个操作数是否相等，返回一个布尔值结果。与严格相等运算符（===）不同，它会尝试转换不同类型的操作数，并进行比较。

## `![] == []` 为 true 的解析

1、**运算符优先级和求值顺序**

`!` 的优先级高于 `==`，所以先计算 `![]`

2、**计算 `![]`（逻辑 NOT 运算符）**

[ECMA规范](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal)

根据规范 **12.5.9 Logical NOT Operator (`!`)**：

- 取子表达式 `[]`
- 对 `[]` 进行 **ToBoolean** 转换
- **ToBoolean** 规则（7.1.2）：
  - 对象（包括数组）转换为 `true`
- 因此 `ToBoolean([])` = `true`
- `!true` = `false`

所以 `![]` 的值为 `false`

3、**比较 `false == []`（抽象相等比较算法）**

根据规范 **7.2.14 Abstract Equality Comparison** 算法：

```txt
1. If Type(x) is the same as Type(y), then
   Return the result of performing Strict Equality Comparison x === y.
   - 这里 Type(x) 是 Boolean，Type(y) 是 Object，类型不同
2. If x is null and y is undefined, return true.
   - 不适用
3. If x is undefined and y is null, return true.
   - 不适用
4. If Type(x) is Number and Type(y) is String,
   return the result of the comparison x == ToNumber(y).
   - 不适用
5. If Type(x) is String and Type(y) is Number,
   return the result of the comparison ToNumber(x) == y.
   - 不适用
6. **If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.**
   - 适用！将布尔值转换为数字
```

进入第 6 步：

- `x` = `false`
- `ToNumber(false)` = `0`（根据 7.1.3）
- 现在比较 `0 == []`

4、**比较 `0 == []`**

现在 `x` 是 Number，`y` 是 Object。根据算法：

```txt
7. If Type(x) is either String, Number, or Symbol and Type(y) is Object,
   return the result of the comparison x == ToPrimitive(y).
```

进入第 7 步：

- `x` = `0` (Number)
- `y` = `[]` (Object)
- 需要计算 `ToPrimitive([])`

5、**计算 `ToPrimitive([])`**

根据 **7.1.1 ToPrimitive** 算法：

- 首选类型未提供，默认为 `default`（即 `"default"`）
- 对于 Object，`hint` 为 `"default"` 时，行为与 `"number"` 相同
- 调用 `OrdinaryToPrimitive([], "number")`

**OrdinaryToPrimitive** 算法（7.1.1.1）：

1. 如果 `hint` 是 `"string"`：先调用 `toString`，再调用 `valueOf`
2. **如果 `hint` 是 `"number"`：先调用 `valueOf`，再调用 `toString`**

对于数组 `[]`：

1. 先调用 `valueOf()`：
   - `[].valueOf()` 返回 `[]`（对象本身，不是原始值）
2. 再调用 `toString()`：
   - `[].toString()` 返回空字符串 `""`

所以 `ToPrimitive([])` = `""`

6、**比较 `0 == ""`**

现在比较 `0 == ""`，其中：

- Type(x) = Number
- Type(y) = String

根据算法的第 4 条规则：

```txt
4. If Type(x) is Number and Type(y) is String,
   return the result of the comparison x == ToNumber(y).
```

所以：

- `ToNumber("")` = `0`（根据 7.1.3.1，空字符串转换为 0）
- 比较 `0 == 0`

7、**比较 `0 == 0`**

现在 Type(x) 和 Type(y) 都是 Number，回到第 1 步规则：

```txt
1. If Type(x) is the same as Type(y), then
   Return the result of performing Strict Equality Comparison x === y.
```

根据 **7.2.15 Strict Equality Comparison**：

- `0 === 0` 返回 `true`

**最终结论**:

根据 ECMAScript 规范，`![] == []` 的求值过程是：

```txt
![] == []
↓
false == []
↓
ToNumber(false) == []   // 0 == []
↓
0 == ToPrimitive([])    // 0 == ""
↓
0 == ToNumber("")       // 0 == 0
↓
0 === 0
↓
true
```

所以根据规范 `![] == []` 应该是 `true`。
