# 实例方法

- [实例方法](#实例方法)
  - [requestAnimationFrame()](#requestanimationframe)
  - [btoa() 和 atob()](#btoa-和-atob)
  - [matchMedia()](#matchmedia)
    - [常用媒体查询示例](#常用媒体查询示例)
      - [响应式设计检测](#响应式设计检测)
    - [实际应用示例](#实际应用示例)

## requestAnimationFrame()

`window.requestAnimationFrame()` 告诉浏览器**你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画**。

**1、核心特点**：

1. **与浏览器刷新率同步**
   - 自动匹配显示器的刷新率（通常是 60Hz，即每秒 60 帧，每一帧就会执行一次，即每秒执行 60 次）
   - 在每次浏览器重绘前执行回调，确保动画流畅
2. **智能节能**
   - 当页面隐藏或最小化时，自动暂停动画
   - 减少 CPU、GPU 和电池消耗
3. **时间戳参数**
   - 回调函数接收一个高精度时间戳参数，便于计算动画进度
4. 执行顺序
   - 当前宏任务 → 微任务 → `requestAnimationFrame` → 渲染 → `requestIdleCallback`

> 注意：**若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 `requestAnimationFrame()`。`requestAnimationFrame()` 是一次性的**

**2、何时使用 requestAnimationFrame**：

- **创建流畅的 UI 动画**：
  - 元素移动、缩放、旋转等变换
  - 颜色渐变和透明度变化
- 游戏开发中的主循环
- 数据可视化动画
- 滚动动画和视差效果
- 需要高性能的连续更新场景

**3、与 setTimeout/setInterval 的对比**：

```javascript
// ❌ 使用 setTimeout/setInterval 的问题
function animateWithTimeout() {
    element.style.left = (left + 1) + 'px';
    setTimeout(animateWithTimeout, 1000 / 60); // 固定16.7ms
}
// 问题：不精确，可能丢帧，不在重绘周期内执行

// ✅ 使用 requestAnimationFrame
function animateWithRAF() {
    element.style.left = (left + 1) + 'px';
    requestAnimationFrame(animateWithRAF);
}
// 优势：精确同步，自动调节，节能
```

***

**4、语法**：

```JS
requestAnimationFrame(callback)
```

参数：

- `callback`
  - 当你的动画需要更新时，为下一次重绘所调用的函数。
  - `callback` 接收一个 `DOMHighResTimeStamp` 时间戳参数，该参数与 `performance.now()` 的返回值相同，它表示 `requestAnimationFrame()` 开始执行回调函数的时刻，单位为毫秒（ms）。

返回值：

- 一个 `long` 整数，请求 `ID`，是回调列表中唯一的标识。是个非零值，没有别的意义。你可以传这个值给 `window.cancelAnimationFrame()` 以取消回调函数请求。

***

**5、示例**：

创建一个动画，时间为 2 秒（2000 毫秒）。动画效果为元素以 `0.1px/ms` 的速度向右移动，最终移动了`200px（0.1 * 2000）`

```js
const element = document.getElementById("some-element-you-want-to-animate");
let start, previousTimeStamp;
let done = false;

function step(timestamp) {
  if (start === undefined) {
    start = timestamp;
  }
  const elapsed = timestamp - start;

  if (previousTimeStamp !== timestamp) {
    // 这里使用 Math.min() 确保元素在恰好位于 200px 时停止运动
    const count = Math.min(0.1 * elapsed, 200);
    element.style.transform = `translateX(${count}px)`;
    if (count === 200) done = true;
  }

  if (elapsed < 2000) {
    // 2 秒之后停止动画
    previousTimeStamp = timestamp;
    if (!done) {
      window.requestAnimationFrame(step);
    }
  }
}

window.requestAnimationFrame(step);
```

**5、优势所在**：

1. 平滑执行
   - `requestAnimationFrame` 会把每一帧中的所有 `DOM` 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。所以每次回调中的内容执行的间隔都是和用户屏幕刷新率相关的，这样动画看起来就会非常平滑。使用 `setInterval` 不可避免会有些抖动的现象出现

2. 执行间隔稳定
   - 了解微任务、宏任务相关知识的同学应该知道， `setInterval` 在任务队列中是会被阻塞的，这就导致即使我们设定了 17 毫秒，实际上每次的间隔并不会是刚好17毫秒。但是 `requestAnimationFrame` 可以保证在每一帧都完成回调中的内容渲染。

3. 性能提升
   - `requestAnimationFrame` 是由浏览器专门为实现动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU和电池的开销。这也能避免使用 `setInterval` 的时候出现任务积压的问题。

## btoa() 和 atob()

`btoa()`方法可以将一个二进制字符串（例如，**将字符串中的每一个字节都视为一个二进制数据字节**）编码为 `Base64` 编码的 `ASCII` 字符串。

> `binary to ASCII`

`atob()` 函数会对经过 `Base64` 编码的字符串进行解码。

> `ASCII to binary`

例子：

```js
const encodedData = window.btoa("Hello, world"); // 编码字符串
const decodedData = window.atob(encodedData); // 解码字符串
```

## matchMedia()

`window.matchMedia()` 是 JavaScript 中用于检测 CSS 媒体查询的 API，它允许你在 JavaScript 中检查当前文档是否匹配特定的媒体查询条件。

基本语法:

```javascript
const mediaQuery = window.matchMedia('(media-feature)');
```

注意事项

1. **单位一致性**：在 JavaScript 中使用像素，而 CSS 中可能使用 em 或 rem
2. **性能考虑**：避免频繁检查媒体查询
3. **内存泄漏**：记得移除不再需要的监听器
4. **服务器端渲染**：`matchMedia` 仅在客户端可用

**基本用法**：

1、简单检测

```javascript
// 检测视口宽度是否至少为 768px
const mediaQuery = window.matchMedia('(min-width: 768px)');

if (mediaQuery.matches) {
  console.log('视口宽度至少为 768px');
} else {
  console.log('视口宽度小于 768px');
}
```

2、监听媒体查询变化

```javascript
const mediaQuery = window.matchMedia('(max-width: 600px)');

// 定义变化处理函数
function handleTabletChange(e) {
  if (e.matches) {
    console.log('屏幕宽度 ≤ 600px');
  } else {
    console.log('屏幕宽度 > 600px');
  }
}

// 添加监听器
mediaQuery.addEventListener('change', handleTabletChange);

// 或者使用旧的 addListener 方法（已废弃但仍可用）
// mediaQuery.addListener(handleTabletChange);

// 移除监听器（需要时）
// mediaQuery.removeEventListener('change', handleTabletChange);
```

### 常用媒体查询示例

#### 响应式设计检测

```javascript
// 检测设备类型
const isMobile = window.matchMedia('(max-width: 768px)');
const isTablet = window.matchMedia('(min-width: 769px) and (max-width: 1024px)');
const isDesktop = window.matchMedia('(min-width: 1025px)');

// 检测横屏/竖屏
const isPortrait = window.matchMedia('(orientation: portrait)');
const isLandscape = window.matchMedia('(orientation: landscape)');

// 检测深色模式
const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
const prefersLightMode = window.matchMedia('(prefers-color-scheme: light)');

// 检测运动偏好（减少动画）
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
```

### 实际应用示例

1、根据屏幕尺寸加载不同组件

```javascript
class ResponsiveComponent {
  constructor() {
    this.mediaQuery = window.matchMedia('(max-width: 768px)');
    this.init();
  }
  
  init() {
    // 初始检测
    this.handleChange(this.mediaQuery);
    
    // 监听变化
    this.mediaQuery.addEventListener('change', this.handleChange);
  }
  
  handleChange = (e) => {
    if (e.matches) {
      this.loadMobileComponent();
    } else {
      this.loadDesktopComponent();
    }
  }
  
  destroy() {
    this.mediaQuery.removeEventListener('change', this.handleChange);
  }
}
```

2、暗色/亮色模式切换

```javascript
class ThemeManager {
  constructor() {
    this.darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');
    this.setupTheme();
  }
  
  setupTheme() {
    // 设置初始主题
    this.updateTheme(this.darkModeQuery);
    
    // 监听系统主题变化
    this.darkModeQuery.addEventListener('change', this.updateTheme);
    
    // 监听用户手动切换
    document.getElementById('theme-toggle').addEventListener('click', () => {
      this.toggleTheme();
    });
  }
  
  updateTheme = (e) => {
    if (e.matches) {
      document.body.classList.add('dark-theme');
    } else {
      document.body.classList.remove('dark-theme');
    }
  }
}
```

3、性能优化 - 按需加载资源

```javascript
const imageLoader = {
  init() {
    const isRetina = window.matchMedia('(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)');
    
    document.querySelectorAll('[data-src]').forEach(img => {
      if (isRetina.matches) {
        img.src = img.dataset.srcRetina || img.dataset.src;
      } else {
        img.src = img.dataset.src;
      }
    });
  }
};
```
