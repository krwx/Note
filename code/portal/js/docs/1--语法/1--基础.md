# 概念

- [概念](#概念)
  - [内存管理](#内存管理)
    - [垃圾回收](#垃圾回收)
      - [引用](#引用)
      - [引用计数垃圾收集（不用了）](#引用计数垃圾收集不用了)
      - [标记 - 清除算法](#标记---清除算法)
    - [内存泄漏的情形](#内存泄漏的情形)
      - [不合理的闭包为什么会发生内存泄漏](#不合理的闭包为什么会发生内存泄漏)
        - [怎么避免使用闭包发生的内存泄露](#怎么避免使用闭包发生的内存泄露)
  - [并发模型与事件循环](#并发模型与事件循环)
    - [相关概念](#相关概念)
  - [类](#类)
    - [静态方法](#静态方法)
    - [原型和静态方法绑定 this](#原型和静态方法绑定-this)
    - [继承](#继承)
  - [箭头函数](#箭头函数)
    - [语法](#语法)
    - [描述](#描述)
      - [不绑定this](#不绑定this)
        - [正常函数绑定 this 的情形](#正常函数绑定-this-的情形)
        - [箭头函数继承 this](#箭头函数继承-this)
  - [First-class Function（头等函数）](#first-class-function头等函数)
    - [把函数赋值给变量](#把函数赋值给变量)
    - [回调函数](#回调函数)
    - [高阶函数](#高阶函数)
    - [数组的高阶函数](#数组的高阶函数)
  - [console](#console)

## 内存管理

JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。

### 垃圾回收

#### 引用

垃圾回收算法主要依赖于引用的概念。  
在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

#### 引用计数垃圾收集（不用了）

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

该算法有个限制：无法处理循环引用的事例。

#### 标记 - 清除算法

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

保留所有可以获得的对象。清除所有不能获得的对象。

解决了循环引用：因为从根对象开始找，不会找到出现循环引用的地方去，那么就会回收发生循环引用的地方的内存。

### 内存泄漏的情形

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

1. 意外的全局变量
   1. 由于使用**未声明**的变量，而意外的创建了一个全局变量，**在函数执行完毕后，无法回收该变量**。
   2. 使用 this 也可以创建全局变量，例如：

      ```js
        function foo() {
            this.variable = "potential accidental global";
        }
        // Foo 调用自己，this 指向了全局对象（window）
        // 而不是 undefined
        foo();
      ```

   3. 如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义
   4. 内存泄漏的原因：**全局变量直到程序运行结束前都不会被回收**
2. 被遗忘的计时器或回调函数
   1. 设置了 `setInterval` 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
   2. 当不需要 `interval` 或者 `timeout` 时，最好调用 `clearInterval` 或者 `clearTimeout`。
3. 脱离 `DOM` 的引用
   1. 获取一个 `DOM` 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。需要解除引用
   2. 还要考虑 `DOM` 树内部或子节点的引用问题。例如：代码中保存了表格某一个 `<td>` 的引用，当回收时，`<td>` 所在的表格不会参与回收
4. 不合理的使用闭包  
   1. 不合理的使用闭包，从而导致某些变量一直被留在内存当中。

#### 不合理的闭包为什么会发生内存泄漏

[链接](https://www.cnblogs.com/forcheng/p/12828941.html)

```js
var theThing = null;
var replaceThing = function () {
    // originalThing 保存上一次设置的 theThing 变量
    var originalThing = theThing;

    // unused 方法不写也没问题，replaceThing 作用域始终没有回收
    var unused = function () {
        if (originalThing)
            console.log("hi");
        };
    }

    // 重点是这里，设置全局变量为一个带有闭包的对象
    theThing = {
        someMethod: function () {
            console.log("data");
        }
    };
};
setInterval(replaceThing, 1000);
```

上面代码片段做了一件事情：每隔1秒后调用 replaceThing 函数，全局变量 theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。

**泄露的原因：全局变量与外部函数内的闭包有联系。导致回收时，不能回收闭包，从而不能回收闭包的外部函数的作用域。**

过程解析：

0. 理解的重点是：垃圾回收是从全局变量 `theThing` 开始，寻找 `theThing` 变量引用的对象
1. 第一次运行
   1. `replaceThing` 函数第一次调用完，通过全局变量 `theThing`，可以访问到闭包函数 `someMehtod1`，因此其作用域链也会被保留，即 `replaceThing1.[[Scope]]` 将被保留，所以闭包函数 `unused1` 就算没有被使用，也不会被回收。（全局变量直到程序运行结束前都不会被回收）
2. 第二次运行
   1. 在 `replaceThing` 函数第二次调用完，通过全局变量 `theThing`，可以访问到闭包函数 `someMehtod2`，因此其作用域链也会被保留，即 `replaceThing2.[[Scope]]` 将被保留，所以闭包函数 `unused2` 与对象 `originalThing2` 也将被保留，不会被回收。
   2. 由于 `originalThing2` 可以访问到闭包函数 `someMehtod1`，因此之前第一次被保留的作用域链仍将继续被保留。
3. 当 `replaceThing` 函数继续重复调用时， `originalThing` 相互之间类似形成一个链表，通过全局变量 `theThing` 可以顺着链表到查找到第一次调用产生的对象 `[Object1]`，这也就导致了垃圾回收器无法回收每次产生的新对象（里面包含一个大数组和一个闭包），造成严重的内存泄漏。

##### 怎么避免使用闭包发生的内存泄露

1. 及时释放引用：在不再需要闭包时，**手动将引用置为 `null`** ，这样可以解除对外部作用域的引用，帮助垃圾回收机制回收内存。

2. 使用立即执行函数：将闭包封装在立即执行函数中，当立即执行函数执行完毕后，其中的变量就会被销毁，从而避免了内存泄漏。

3. 将需要保持引用的变量进行拷贝：如果闭包只需要引用外部函数中的某个变量，而不是整个作用域，可以将该变量进行拷贝，避免对整个作用域的引用。

4. 使用 `WeakMap` 或 `WeakSet` ：如果闭包中引用的外部变量是对象，可以使用 `WeakMap` 或 `WeakSet` 来存储对象的引用。 `WeakMap` 和 `WeakSet` 是弱引用的集合，当对象没有其他引用时，垃圾回收机制会自动回收对象。

5. 避免循环引用：闭包中的内部函数如果引用了外部函数的变量，而外部函数的变量又引用了闭包中的内部函数，就会形成循环引用，导致内存泄漏。要避免循环引用，需要注意变量的引用关系，确保没有形成闭环。

## 并发模型与事件循环

JavaScript 有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。

### 相关概念

- 栈
  - 函数调用形成了一个由若干帧（frame）组成的栈。
  - 调用一个函数总是会为其创造一个**新的栈帧**
- 堆
  - 对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。
- 队列/消息队列
  - 一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。

在 事件循环 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。

函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。

每一个消息完整地执行后，其他消息才会被执行。缺点在于当一个消息需要太长时间才能处理完毕时，Web 应用程序就无法处理与用户的交互。

一个 web worker 或者一个跨域的 iframe 都有自己的栈、堆和消息队列。

JavaScript 的事件循环模型**永不阻塞**。处理 I/O 通常通过事件和回调来执行，所以当一个应用正等待一个 IndexedDB 查询返回或者一个 XHR 请求返回时，它仍然可以处理其他事情，比如用户输入。

## 类

### 静态方法

类（class）通过 static 关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。

类继承。子类会继承父类的静态方法。

私有静态字段有一个限制：只有定义该私有静态字段的类能访问该字段。其他类访问则报错，即使是子类调用也会报错。

### 原型和静态方法绑定 this

当调用静态或原型方法时没有指定 this 的值，那么方法内的 this 值将被置为 undefined。即使你未设置 "use strict" ，因为 class 体内部的代码总是在严格模式下执行。

如果上述代码通过传统的基于函数的语法来实现，那么依据初始的 this 值，在非严格模式下方法调用会发生自动装箱。若初始值是 undefined，this 值会被设为全局对象。

总结：
当调用静态或原型方法时没有指定 this 的值时

- 严格模式，`this` 的值为 `undefined`
- 非严格模式，`this` 的值为 全局对象

```js
// 严格模式
class Animal {
  speak() {
    return this;
  }
  static eat() {
    return this;
  }
}
let obj = new Animal();
obj.speak(); // Animal {}
let speak = obj.speak;
speak(); // undefined

Animal.eat(); // class Animal
let eat = Animal.eat;
eat(); // undefined

// 非严格模式
function Animal() {}
Animal.prototype.speak = function () {
  return this;
};
Animal.eat = function () {
  return this;
};
let obj = new Animal();
let speak = obj.speak;
speak(); // global object

let eat = Animal.eat;
eat(); // global object
```

严格模式通过在 js 文件第一行添加 `"use strict"` 开启

### 继承

js 没有多继承，只有单继承

## 箭头函数

箭头函数表达式没有自己的 `this，arguments，super或new.target` 。不能用作构造函数。

### 语法

```js
(param1, param2, …, paramN) => { statements }
(param1, param2, …, paramN) => expression
//相当于：(param1, param2, …, paramN) =>{ return expression; }

// 当只有一个参数时，圆括号是可选的：
(singleParam) => { statements }
singleParam => { statements }

// 没有参数的函数应该写成一对圆括号。
() => { statements }

//加括号的函数体返回对象字面量表达式：
params => ({foo: bar})

//支持剩余参数和默认参数
(param1, param2, ...rest) => { statements }
(param1 = defaultValue1, param2, …, paramN = defaultValueN) => {
statements }

//同样支持参数列表解构
let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
f();  // 6
```

### 描述

#### 不绑定this

##### 正常函数绑定 this 的情形

每一个新函数根据它是被如何调用的来定义这个函数的 this 值：

- 如果该函数是一个构造函数，this 指针指向一个新的对象
- 在严格模式下的函数调用下，this 指向 undefined。这里指的是 直接调用方法，里面 this 的指向
- 如果该函数是一个对象的方法，则它的 this 指针指向这个对象
- 等等  

例子：

```js
function Person() {
  // Person() 构造函数定义 `this`作为它自己的实例。
  this.age = 0;

  setInterval(function growUp() {
    // 在非严格模式，growUp() 函数定义 `this`作为全局对象，
    // 与在 Person() 构造函数中定义的 `this`并不相同。
    this.age++;
  }, 1000);
}

var p = new Person();
```

##### 箭头函数继承 this

**箭头函数不会创建自己的 `this` ，它只会从自己的作用域链的上一层继承 `this`**。  
因此，在下面的代码中，传递给 setInterval 的函数内的 this 与封闭函数中的 this 值相同：

```js
function Person() {
  this.age = 0;

  this.testOut = () => {
    console.log(this.age);
  }

  setInterval(() => {
    console.log(this);
    this.age++; // |this| 正确地指向 p 实例
  }, 1000);
}
var p = new Person();

// 第一个例子
let obj = {
    b: () => {
        console.log("b: ", this) // 这里输出全局对象。
    }
}
obj.b()
// 这里输出和上面输出的 this 不同的原因是：上面的例子中的箭头函数的上一个作用域是 Person 函数的函数作用域，所以 this 指向对象实例。下面的例子中箭头函数的上一个作用域为全局作用域，所以 this 指向全局对象。

// 第二个例子
var adder = {
  add: function (a) {
    var f = (v) => { 
        console.log(this);
    }
    return f(a); // 这里返回了箭头函数
  },
};
adder.add(1); // this 指向 adder。add 属性是一个方法，因为有对象调用，所以该函数的函数作用域中 this 指向的是 adder，然后箭头函数继承了 adder 函数的函数作用域，所以 箭头函数里面 this 指向的是adder

let add = adder.add;
add(1); // this 指向全局对象。因为 add 函数的函数作用域中 this 指向全局对象，所以箭头函数中的 this 也指向全局对象。
```

箭头函数中，严格模式中与 this 相关的规则都将被忽略。即 this 会指向全局对象。但是严格模式的其他规则依然不变。

```js
// 这里即使使用了严格模式，还是返回全局对象
var f = () => { 'use strict'; return this; };
f() === window; // 或者 global
```

- 通过 call 或 apply 调用：  
  由于 箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，**只能传递参数（不能绑定 this），他们的第一个参数会被忽略**。（这种现象对于 bind 方法同样成立）。例子：

```js
var adder = {
  base: 1,
  addThruCall: function (a) {
    var f = (v) => v + this.base;
    var b = {
      base: 2,
    };
    return f.call(b, a);
  },
};
console.log(adder.addThruCall(1)); // 仍然输出 2，call() 忽略第一个参数
```

- 不绑定arguments：  
  意思指的是 箭头函数没有自身的 arguments 属性，但是可以隐形使用别的函数的 arguments。例子如下：

```js
function foo(n) {
  var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象。arguments[0] 是 n，即传给 foo 函数的第一个参数
  return f();
}

foo(1); // 2
foo(2); // 4
```

- 箭头函数没有prototype属性。
- yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。

## First-class Function（头等函数）

当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有**头等函数**。

### 把函数赋值给变量

在JavaScript中，函数是一种数据类型，就像字符串、数字和数组是数据类型一样。因此，函数可以作为值分配给变量，但与所有其他数据类型不同，因为它们可以被调用。

### 回调函数

在JavaScript中，**回调函数是作为参数传递给另一个函数的函数**。

在执行高阶函数的过程中，回调函数作为高阶函数的入参可以被调用。

> JavaScript 中的回调函数的参数名称通常为 `cb` 。

### 高阶函数

`HOF：Higher-order function`

**高阶函数**是：接受函数作为参数和/或返回函数的函数。

**高阶函数是一个函数**，它至少会：

- 将一个或多个函数作为参数
- 返回一个函数作为其结果

例子：

```js
// 使用变量调用高阶函数
const sayHello = function () {
  return function () {
    console.log("Hello!");
  };
};
const myFunc = sayHello();
myFunc(); // Hello!

// 使用双括号调用高阶函数：()()
function sayHello() {
  return function () {
    console.log("Hello!");
  };
}
sayHello()();
```

### 数组的高阶函数

- reduce()
- forEach()
- filter()
- map()
- sort()

## console

`console.table`

```js
const data = [
  { id: 1, name: 'Alice', age: 25 },
  { id: 2, name: 'Bob', age: 30 },
  { id: 3, name: 'Charlie', age: 35 }
];

console.table(data);
```

***

`console.log()`可以接受任何类型的参数，包括字符串、数字、布尔值、对象、数组、函数等。最厉害的是，它支持占位符!

常用的占位符：

- %s - 字符串
- %d or %i - 整数
- %f - 浮点数
- %o - 对象
- %c - CSS 样式

添加样式。可以使用 `%c` 占位符添加 `CSS` 样式，使输出内容更加美观。

```js
console.log('%c This is a styled message', 'color: red; font-size: 20px;');
```
