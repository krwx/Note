# 继承与原型链

- [继承与原型链](#继承与原型链)
  - [简单介绍](#简单介绍)
  - [获取原型](#获取原型)
  - [基于原型链的继承](#基于原型链的继承)
    - [使用继承属性](#使用继承属性)
    - [使用继承方法](#使用继承方法)
  - [构造函数（Constructor）](#构造函数constructor)
  - [梳理原型关系](#梳理原型关系)
    - [构建更长的原型链](#构建更长的原型链)
  - [创建对象和改变原型链的方法](#创建对象和改变原型链的方法)
  - [遍历属性](#遍历属性)

## 简单介绍

- JavaScript 使用**对象**实现继承。
- 原型的定义：每个对象（`object`）都有一个私有属性指向一个名为**原型（prototype）的对象**。
- 原型对象有自己的原型，层层向上直到一个对象的原型为 `null`。这样形成的链结构为 **原型链**（`prototype chain`）
- 根据定义，`null` 没有原型，并作为这个原型链中的最后一个环节。

## 获取原型

方法：

1. 使用 `Object.getPrototypeOf()` 获取对象的原型
2. 通过构造函数的 `prototype` 属性获取

`[[Prototype]]` 说明：

- 符号 `someObject.[[Prototype]]` 用于标识 someObject 的原型。它是一个对象，也称为**原型对象**
- 内部插槽 `[[Prototype]]` 可以通过 `Object.getPrototypeOf()` 和 `Object.setPrototypeOf()` 函数来访问。
- 避免使用 `obj.__proto__`，因为是非标准的。

## 基于原型链的继承

### 使用继承属性

当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

`__proto__` 语法:

- 在像 `{ a: 1, b: 2, __proto__: c }` 这样的对象字面量中，c 值（必须为 null 或另一个对象）将变成字面量所表示的对象的 `[[Prototype]]`

```js
const o = {
  a: 1,
  b: 2,
  // __proto__ 设置了 [[Prototype]]。它在这里被指定为另一个对象字面量。
  __proto__: {
    b: 3,
    c: 4,
  },
};
// 完整的原型链看起来像这样：
// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null
```

### 使用继承方法

当继承的函数被调用时，`this` 值**指向的是当前继承的对象**，而不是拥有该函数属性的原型对象。

```js
const parent = {
  value: 2,
  method() {
    return this.value + 1;
  },
};

console.log(parent.method()); // 3
// 当调用 parent.method 时，“this”指向了 parent

// child 是一个继承了 parent 的对象
const child = {
  __proto__: parent,
};
console.log(child.method()); // 3
// 调用 child.method 时，“this”指向了 child。
// 又因为 child 继承的是 parent 的方法，
// 首先在 child 上寻找属性“value”。
// 然而，因为 child 没有名为“value”的自有属性，
// 该属性会在 [[Prototype]] 上被找到，即 parent.value。

child.value = 4; 
// 将 child 上的属性“value”赋值为 4。这会遮蔽 parent 上的“value”属性。
// child 对象现在看起来是这样的：
// { value: 4, __proto__: { value: 2, method: [Function] } }
console.log(child.method()); // 5
// 因为 child 现在拥有“value”属性，“this.value”现在表示 child.value
```

## 构造函数（Constructor）

构造函数是使用 `new` 调用的函数，它使用自己的 `prototype` 属性为每个构造的对象实例设置原型（`[[Prototype]]`）。

假设 `Box()` 是构造函数，那么 `Box.prototype === Object.getPrototypeOf(new Box())`

```js
// 一个构造函数
function Box(value) {
  this.value = value;
}

// 使用 Box() 构造函数创建的所有盒子都将具有的属性
Box.prototype.getValue = function () {
  return this.value;
};
const boxes = [new Box(1), new Box(2), new Box(3)];
boxes[0].getValue(); // 1。直接使用 prototype 上的方法


// 这样不是继承 getValue() 了，这相当于给每个对象实例都创建了一份函数副本
function Box(value) {
  this.value = value;
  this.getValue = function () {
    return this.value;
  };
}
```

所有对象实例共享同一个 `prototype`。修改构造函数的 `prototype` 属性会影响所有通过该构造函数创建的实例。

```js
function Box(value) {
  this.value = value;
}
Box.prototype.getValue = function () {
  return this.value;
};
const box = new Box(1);

// 在创建实例后修改 Box.prototype
Box.prototype.getValue = function () {
  return this.value + 1;
};
box.getValue(); // 2
```

`Constructor.prototype` 默认具有一个自有属性：`constructor`，它引用了构造函数本身。即，`Box.prototype.constructor === Box`

***

`Constructor.prototype` 与 `Constructor.[[Prototype]]` 的区别：

- `Constructor.prototype` 是构造的对象实例的原型对象。
- `Constructor.[[Prototype]]` 是构造函数本身的原型对象, 即 `Function.prototype`。
  - `Object.getPrototypeOf(Constructor) === Function.prototype`

***

类是构造函数的语法糖。

```js
// 使用类表示
class Box {
  constructor(value) {
    this.value = value;
  }
  // 在 Box.prototype 上创建方法
  getValue() {
    return this.value;
  }
}
```

一些内置构造函数的 prototype 属性本身就是其自身的实例。
例如，Number.prototype 是数字 0，Array.prototype 是一个空数组，RegExp.prototype 是 /(?:)/。

```js
Number.prototype + 1; // 1
Array.prototype.map((x) => x + 1); // []
String.prototype + "a"; // "a"
RegExp.prototype.source; // "(?:)"
Function.prototype(); // Function.prototype 本身就是一个无操作函数
```

## 梳理原型关系

`obj` 指对象实例，`Constructor` 指构造函数，`Object` 指 `Object` 类

原型图：

![原型图](../原型图/原型图.png)

1. `Object.getPrototypeof(obj) === Constructor.prototype`
2. `Constructor.prototype.constructor === Constructor`
3. `Object.getPrototypeOf(Constructor) === Function.prototype`
4. `Object.getPrototypeOf(Constructor.prototype) === Object.prototype`
5. `Object.getPrototypeOf(Object.prototype) === null`
6. `Object.getPrototypeOf(Function.prototype) === Object.prototype`

> ps：箭头函数没有默认的原型属性

一个典型的构造函数将构建以下原型链：

```js
function Constructor() {}
const obj = new Constructor();
// obj ---> Constructor.prototype ---> Object.prototype ---> null
```

### 构建更长的原型链

使用 `Object.setPrototypeOf()` 函数设置 `Constructor.prototype` 的原型为其他构造函数的原型来延长原型链

```js
Object.setPrototypeOf(obj, prototype)
//obj：要设置其原型的对象。
// prototype：该对象的新原型（一个对象或 null）。
```

原理：  

- 实现更长的原理就是要将 `Constructor.prototype` 的原型指向别的构造函数的原型，即：`Constructor.prototype` 的 `[[Prototype]]` 为 `OtherConstructor.prototype`

例子：

```js
function Base() {}
function Derived() {}
// 将 `Derived.prototype` 的 `[[Prototype]]`
// 设置为 `Base.prototype`
Object.setPrototypeOf(Derived.prototype, Base.prototype);

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null
```

在类的术语中，这等同于使用 `extends` 语法。

```js
class Base {}
class Derived extends Base {}

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null
```

## 创建对象和改变原型链的方法

1. 使用语法结构创建对象
   1. 使用 `{}` 创建对象，使用 `{..., __proto__: {}}`设置原型
2. 使用构造函数
3. 使用 `Object.create()`

   `Object.create()` 会创建一个新对象，该新对象的原型就是函数的第一个参数。

   ```js
    const a = { a: 1 };
    // a ---> Object.prototype ---> null
    const b = Object.create(a);
    // b 的原型就是 a，不是 a 的原型
    // b ---> a ---> Object.prototype ---> null
   ```

4. 使用类

## 遍历属性

在遍历对象的属性时，原型链中的每个可枚举属性都将被枚举。

可以使用 `hasOwnProperty` 或 `Object.hasOwn` 检查对象是否具有**自己定义**的属性：

```js
const obj = {
  a: 1,
  b: 2,
  __proto__: {
    c: 3,
  },
};
console.log(obj.hasOwnProperty("a")); // true
console.log(obj.hasOwnProperty("c")); // false
console.log(Object.hasOwn(obj, "a")); // true
console.log(Object.hasOwn(obj, "c")); // false
```
