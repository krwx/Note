# 闭包

**定义：闭包（closure）是由函数以及函数声明所在的词法环境组合而成的。** 该环境包含了这个闭包创建时作用域内的任何局部变量。

- 闭包让开发者可以从内部函数访问外部函数的作用域。
- 在 JavaScript 中，闭包会随着函数的创建而被同时创建。

例子1：

```js
function init() {
  var name = "Mozilla"; // name 是 init 创建的局部变量
  function displayName() {
    // displayName() 是内部函数，它创建了一个闭包
    console.log(name); // 使用在父函数中声明的变量
  }
  displayName();
}
init();
```

例子2：

```js
function makeFunc() {
  const name = "Mozilla";
  function displayName() {
    console.log(name);
  }
  return displayName;
}

const myFunc = makeFunc();
myFunc();
// 在本例中，myFunc 是执行 makeFunc 时创建的 displayName 函数的实例引用。displayName 的实例有一个它的词法环境的引用，而 name 变量位于这个词法环境中。因此，当 myFunc 被调用时，name 变量仍然可用，其值 Mozilla 就被传递到 console.log 中。
```

***

`当前函数的作用域链[[Scope]] = VO / AO + 父级函数的作用域链[[Scope]]`

> 补充说明：`VO` 和 `AO` 分别表示变量对象和活动对象，而变量对象可以理解为保存了当前上下文数据（变量、函数声明、函数参数）的一个对象，而活动对象是特殊的变量对象，简单理解就是函数的变量对象我们一般称之为活动对象，而在全局上下文里，全局对象自身就是变量对象。点击查看详细解释
>
> 在JS内部实现中，每个函数都会有一个 `[[Scope]]` 属性，表示当前函数的可以访问的作用域链。其实质上就是一个对象数组，包含了函数能够访问到的所有标识符（变量、函数等），用以查找函数所使用的到的标识符。而数组中从左到右的对象依次对应了由内到外的其他函数（或全局）的活动（变量）对象。另外，在 ECMAScript 中，同一个父上下文中创建的闭包是共用一个 `[[Scope]]` 属性的。换句话说，**同一个函数内部的所有闭包共用这个函数的 `[[Scope]]` 属性**。
>
> **对于闭包函数来说，为了实现其所引用的变量不会被回收，会保留它的作用域链（即 `[[Scope]]` 属性），不会被垃圾回收器回收**。

***

闭包有两个常用的用途：

1. 第一个用途是**使我们在函数外部能够访问到函数内部的变量**。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
2. 另一个用途是**使已经运行结束的函数上下文中的变量对象继续留在内存中**，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

## 用闭包模拟私有方法

```js
var Counter = (function () {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function () {
      changeBy(1);
    },
    decrement: function () {
      changeBy(-1);
    },
    value: function () {
      return privateCounter;
    },
  };
})();

console.log(Counter.value()); /* logs 0 */
Counter.increment();
Counter.increment();
console.log(Counter.value()); /* logs 2 */
Counter.decrement();
console.log(Counter.value()); /* logs 1 */
```

`increment()、decrement()、value()` 这三个公共方法是共享同一个环境的闭包

## 闭包作用域链

有一系列的嵌套函数，所有的嵌套函数都能访问外部函数的作用域

```js
// 全局作用域
const e = 10;
function sum(a) {
  return function (b) {
    return function (c) {
      // 外部函数作用域
      return function (d) {
        // 局部作用域
        return a + b + c + d + e;
      };
    };
  };
}

console.log(sum(1)(2)(3)(4)); // 20
```

闭包也能捕获块作用域和模块作用域中的变量。例如，下面的示例创建了块级作用域变量 y 的闭包：

```js
function outer() {
  let getY;
  {
    const y = 6;
    getY = () => y;
  }
  console.log(typeof y); // undefined
  console.log(getY()); // 6
}

outer();
```
