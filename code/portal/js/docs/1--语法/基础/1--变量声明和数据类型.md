# 变量声明和数据类型

- [变量声明和数据类型](#变量声明和数据类型)
  - [变量声明](#变量声明)
    - [let、const、var 的区别](#letconstvar-的区别)
    - [作用域](#作用域)
      - [作用域链查找顺序](#作用域链查找顺序)
    - [Hoisting（变量提升）](#hoisting变量提升)
      - [只会提升声明，不会提升其初始化](#只会提升声明不会提升其初始化)
      - [函数声明的提升](#函数声明的提升)
    - [全局对象和全局变量](#全局对象和全局变量)
  - [数据类型](#数据类型)

## 变量声明

JavaScript 有三种变量声明方式。

- var
  - 声明一个**变量**，可选择将其初始化为一个值。
- let
  - 声明一个块级作用域的局部**变量**，可选择将其初始化为一个值。
- const
  - 声明一个块级作用域的只读命名**常量**。

```js

// 声明变量
let x;
console.log(x); // 输出“undefined”

// 初始化变量
x = 10;
console.log(x); // 输出“10”

// 同时声明和初始化变量
let y = 20;
console.log(y); // 输出“20”
```

### let、const、var 的区别

- 变量作用域：
  - `var` 声明的变量作用域是全局作用域或者函数作用域.
  - `let` 和 `const` 则拥有块级作用域。
- 变量提升：
  - `var` 声明的变量会有“变量提升”的行为，可以在声明之前使用，值为 `undefined`。
  - `let` 和 `const` 不支持变量提升，因此在声明变量之前不能使用它们。
- 重复声明：
  - `var` 可以被重复声明。
  - `let` 和 `const` 不允许重复声明。

### 作用域

作用域是当前的执行上下文，值和表达式在其中“可见”或可被访问。子作用域可以访问父作用域，反过来则不行。

**JavaScript 的作用域分以下三种**：

- 全局作用域：脚本模式运行所有代码的默认作用域
- 模块作用域：模块模式中运行代码的作用域
  - 在 Node.js 中，每个文件默认都是模块作用域
- 函数作用域：由函数创建的作用域

此外，用 `let` 或 `const` 声明的变量属于额外的作用域：

- 块级作用域：**用一对花括号（一个代码块）创建出来的作用域**

**var 声明的变量的作用域**：

- 如果在函数内声明，那属于函数作用域
- 如果在全局范围内声明，那属于全局作用域

var 作用域例子：

```js
if (true) {
  var x = 5;
}
console.log(x); 
// x 是 5
// 因为 x 的作用域是全局上下文（如果代码是函数的一部分的话，就是函数上下文）。x 的作用域不受附近的 if 语句块的限制。
```

#### 作用域链查找顺序

当在函数内部访问变量时，JavaScript 会按以下顺序查找：

- 当前函数作用域（使用 var 声明的局部变量）
- 外层函数作用域（如果有嵌套函数）
- 全局作用域

当找到变量则不会继续查找。

```js
var a = 10; // 全局作用域
function outerFunction() {
  var b = 20; // 外层函数作用域
  var c = 40;

  function innerFunction() {
    var c = 30; // 当前函数作用域
    console.log(a); // 访问全局变量 a，输出 10
    console.log(b); // 访问外层函数变量 b，输出 20
    console.log(c); // 访问当前函数变量 c，输出 30
  }

  innerFunction();
}
outerFunction();
```

作用域链：

- 如果在自己作用域找不到所需变量就去父级作用域查找，依次向上级作用域查找，直到访问到 `window` 对象就被终止，这一层层的关系就是作用域链。

作用域链的作用：

- 保证有序访问 执行环境中能访问的所有变量和函数。
- 可以访问到外层环境的变量和函数。

作用域链的原理：

- 作用域链的本质上是一个指向变量对象的指针列表。  
- 作用域链的前端始终都是当前执行上下文的变量对象（一个包含了执行环境中所有变量和函数的对象）。
- 全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

### Hoisting（变量提升）

变量提升是 JavaScript 中变量和函数声明在代码执行前被"提升"到作用域顶部的行为。

**只有声明被提升，初始化不被提升**。

以下是变量提升的具体规则：

1. **变量声明提升**：
   - 使用 `var` 声明的变量会被提升到其作用域的顶部，但只提升声明，不提升赋值。初始值为 `undefined`。
   - 使用 `let` 和 `const` 声明的变量也存在提升，但不会初始化，在声明之前访问会抛出 `ReferenceError`（**暂时性死区**）。
2. **函数声明提升**：
   - 函数声明（使用 `function` 关键字）会被整体提升，包括函数体。因此，可以在函数声明之前调用该函数。
   - 函数表达式（无论是命名的还是匿名的）不会被整体提升。如果使用 `var` 声明函数表达式，则变量声明会提升，但函数体不会提升。
3. **类声明提升**：
   - 类声明（使用 `class` 关键字）不会被提升。在声明之前访问会抛出 `ReferenceError`。
4. **函数和变量声明的优先级**：
   - 函数声明提升优先于变量声明提升。如果同一个标识符既有函数声明又有变量声明，那么函数声明会覆盖变量声明（但变量赋值会覆盖函数声明，因为赋值发生在执行阶段）。
5. **相同标识符的多次声明**：
   - 使用 `var` 重复声明同一个变量，不会导致错误，但后面的声明会被忽略（赋值操作仍会执行）。
   - 使用 `let` 和 `const` 重复声明同一个变量会抛出 `SyntaxError`。

#### 只会提升声明，不会提升其初始化

JavaScript **只会提升声明，不会提升其初始化**。如果一个变量先被使用再被声明和赋值的话，使用时的值是 undefined

```js
console.log(a)  // undefinned
console.log(b)  // 报错：Uncaught ReferenceError ReferenceError: Cannot access 'b' before initialization
var a = 1;
let b = 2
```

多个相同 var 声明：

```js
// 同一个作用域内多次声明同一个var变量
console.log(x); // undefined
var x = 1;
var x = 2;
console.log(x); // 2

// 相当于：
// var x;
// console.log(x);
// x = 1;
// x = 2;
```

let/const 不允许重复声明：

```js
let y = 1;
let y = 2; // SyntaxError: Identifier 'y' has already been declared
```

#### 函数声明的提升

函数声明的提升：

```js
// 函数声明被完全提升
foo(); // "Hello"
function foo() {
  console.log("Hello");
}
```

函数表达式的提升：

```js
// 函数表达式遵循变量提升规则
bar(); // TypeError: bar is not a function
var bar = function() {
  console.log("World");
};

// 相当于：
// var bar;
// bar(); // bar是undefined
// bar = function() { ... }
```

函数提升优先于变量提升：

```js
console.log(typeof myFunc); // "function"

var myFunc;
function myFunc() {
  return "I'm a function";
}

// 实际顺序：
// 1. 函数声明 function myFunc() {...} 被提升
// 2. var myFunc 被提升，但函数声明优先
```

相同名称的声明处理：

```js
// 变量声明不会覆盖函数声明
function test() {
  console.log("function");
}
var test;
console.log(typeof test); // "function"

// 但赋值会覆盖
var test = "variable";
console.log(typeof test); // "string"
```

### 全局对象和全局变量

**全局对象**:

一个全局对象是一个永远存在于 `global scope` 的 object.

全局对象取决于脚本在其中运行的执行上下文：

- 在 Web 浏览器中， `Window` 为全局对象
- 在 Worker 中运行的代码， `WorkerGlobalScope` 对象为全局对象。
- 在 Node.js 环境下运行的脚本, `globalThis` 对象为全局对象。

**全局变量**:

全局变量是在全局作用域中声明的变量。它是全局对象的一个属性。

node.js 环境访问全局变量：

```js
var foo = "foobar";
globalThis.foo = foo;
console.log(foo === globalThis.foo); // Console: true

function greeting() {
  console.log("Hi!");
}
globalThis.greeting = greeting;
globalThis.greeting(); // Console: Hi!

// 第一行声明的 foo 不会放到全局对象中。
// 因为在 Node.js 中，每个文件默认都是模块作用域，var foo = "foobar"; 只会被放在该模块的局部作用域
// 显式赋值给 globalThis（globalThis.foo = foo）才能成为全局对象的属性
```

## 数据类型

js 一共有五种**基本数据类型**，分别是 `Undefined、Null、Boolean、Number、String`

还有在 ES6 中新增的 `Symbol` 和 ES10 中新增的 `BigInt` 类型。

JavaScript 中的**引用数据类型**：对象（Object）、数组（Array）、函数（Function）。
