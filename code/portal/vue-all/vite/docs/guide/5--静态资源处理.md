# 静态资源处理

- [静态资源处理](#静态资源处理)
  - [将资源导入为 URL](#将资源导入为-url)
    - [显式 URL 导入](#显式-url-导入)
    - [显式内联处理](#显式内联处理)
    - [将资源导入为资源源码字符串](#将资源导入为资源源码字符串)
    - [导入脚本作为 Worker](#导入脚本作为-worker)
    - [`public` 目录](#public-目录)
    - [通过 `url()` 内联 SVG](#通过-url-内联-svg)
  - [new URL(url, import.meta.url)](#new-urlurl-importmetaurl)

## 将资源导入为 URL

服务时导入一个静态资源会返回解析后的公共路径（`URL`）：

```js
import imgUrl from './img.png'
document.getElementById('hero-img').src = imgUrl
```

例如，`imgUrl` 在开发时会是 `/src/img.png`，在生产构建后会是 `/assets/img.2d8efhg.png`。

***

- 行为类似于 `Webpack` 的 `file-loader`。区别在于导入既可以使用绝对公共路径（基于开发期间的项目根路径），也可以使用相对路径。
- `url()` 在 CSS 中的引用也以同样的方式处理。
- 如果 Vite 使用了 Vue 插件，Vue SFC 模板中的资源引用都将自动转换为导入。
- 常见的图像、媒体和字体文件类型被自动检测为资源。你可以使用 `assetsInclude` 选项扩展内部列表。
- 较小的资源体积小于 `assetsInlineLimit` 选项值则会被内联为 `base64 data` URL。
- 默认情况下，`TypeScript` 不会将静态资源导入视为有效的模块。

### 显式 URL 导入

可以使用 `?url` 后缀显式导入 _未被包含在内部列表或 `assetsInclude` 中的资源_ 为一个 `URL`。

例如，要导入 `Houdini Paint Worklets` 时：

```js
import workletURL from 'extra-scalloped-border/worklet.js?url'
CSS.paintWorklet.addModule(workletURL)
```

或者强制 资源大小 小于阈值 的资源作为 URL 导入。

```js
import fontUrl from './my-font.woff2?url'
```

### 显式内联处理

可以分别使用 `?inline` 或 `?no-inline` 后缀，明确导入带内联（`base 64` 编码）或不带内联（`url` 字符串）的静态资源。

```js
import imgUrl1 from './img.svg?no-inline' // imgUrl1 是解析后的 URL 字符串
import imgUrl2 from './img.png?inline' // imgUrl2 是 base64 编码字符串
```

### 将资源导入为资源源码字符串

资源可以使用 `?raw` 后缀声明作为字符串导入。

```js
import shaderString from './shader.glsl?raw' // shaderString 是资源源码的字符串
```

### 导入脚本作为 Worker

脚本可以通过 `?worker` 或 `?sharedworker` 后缀导入为 `web worker`。

```js
// 在生产构建中将会分离出 chunk
import Worker from './shader.js?worker'
const worker = new Worker()

import SharedWorker from './shader.js?sharedworker'
const sharedWorker = new SharedWorker()
```

也可以将 worker 内联为 `base64` 字符串：

```js
// 内联为 base64 字符串
import InlineWorker from './shader.js?worker&inline'
```

### `public` 目录

`public` 目录应位于你的项目根目录。该目录中的资源在开发时能直接通过 `/` 根路径访问到，并且打包时会被完整复制到目标目录的根目录下。

`public` 目录可以放入下述资源：

- 不会被源码引用（例如 `robots.txt`）
- 必须保持原有文件名（没有经过 hash）
- ...或者你压根不想导入该资源，只是想得到其 URL。

目录默认是 `<root>/public`，但可以通过 `publicDir` 选项来配置。

举个例子，`public/icon.png` 应该在源码中被引用为 `/icon.png`。

### 通过 `url()` 内联 SVG

当在 JS 中手动构造 `url()` 并传入一个 SVG 的 URL 时，应该用双引号将变量包裹起来。

```js
import imgUrl from './img.svg'
document.getElementById('hero-img').style.background = `url("${imgUrl}")`
```

## new URL(url, import.meta.url)

作用：构成一个完整解析的静态资源 `URL`

说明：

- [import.meta.url](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta) 是一个 ESM 的原生功能，会暴露当前模块的 `URL`。
- `url` 为一个相对路径
- 用原生的 [URL 构造器](https://developer.mozilla.org/en-US/docs/Web/API/URL) 将它们组合使用**得到一个被完整解析的静态资源 `URL`**
- 在生产构建时，Vite 才会进行必要的转换保证 URL 在打包和资源哈希后仍指向正确的地址。

```js
const imgUrl = new URL('./img.png', import.meta.url).href

document.getElementById('hero-img').src = imgUrl
```

可以通过 _字符串模板_ 支持动态 URL：

```js
function getImageUrl(name) {
  return new URL(`./dir/${name}.png`, import.meta.url).href
}
```

这个 URL 字符串必须是静态的，不能使用字符串变量。否则代码将被原样保留。

```js
// Vite 不会转换这个
const imgUrl = new URL(imagePath, import.meta.url).href
```

> 注意：无法在 SSR 中使用  
> 如果你正在以服务端渲染模式使用 Vite 则此模式不支持，因为 `import.meta.url` 在浏览器和 Node.js 中有不同的语义。服务端的产物也无法预先确定客户端主机 URL。
