# 视口

- [视口](#视口)
  - [视口（Viewport）](#视口viewport)
    - [主要视口类型](#主要视口类型)
      - [布局视口和视觉视口取值的说明](#布局视口和视觉视口取值的说明)
        - [桌面端](#桌面端)
        - [移动端](#移动端)
    - [视口 Meta 标签](#视口-meta-标签)
    - [常见应用场景](#常见应用场景)
  - [CSS 的 vw 和 vh 单位](#css-的-vw-和-vh-单位)
    - [`svh/lvh/dvh`](#svhlvhdvh)
    - [注意事项和常见问题](#注意事项和常见问题)
    - [最佳实践建议](#最佳实践建议)

## 视口（Viewport）

视口是**浏览器窗口中用于显示网页内容的可视区域**，它是前端响应式设计的基础概念。理解视口对于移动端适配和响应式开发至关重要。

### 主要视口类型

1、**布局视口（Layout Viewport）**

- 网页实际布局的尺寸
- **桌面浏览器** 中等于浏览器窗口大小
- **移动设备** 上通常默认为 `980px` 或类似宽度
- `vw、vh` 基于此视口计算

```js
// 布局视口（不包含滚动条）
const layoutWidth = document.documentElement.clientWidth; // 宽度
const layoutHeight = document.documentElement.clientHeight; // 高度
```

2、**视觉视口（Visual Viewport）**

- 用户当前看到的屏幕区域
- 会受到缩放操作影响
- 在移动设备上可以比布局视口小

```javascript
// 视觉视口（包含滚动条）
const viewportWidth = window.innerWidth; // 宽度
const viewportHeight = window.innerHeight; // 高度

// 或使用更精确的Visual Viewport API
window.visualViewport?.width
window.visualViewport?.height
```

3、**理想视口（Ideal Viewport）**

- 设备理想的显示宽度
- 通过设置 `<meta name="viewport">` 实现

#### 布局视口和视觉视口取值的说明

##### 桌面端

在桌面端，**布局视口**和**视觉视口**的大小是一样的

**工具栏包含情况**：

- 都不包含浏览器UI，只包含网页内容区域。
- 按 `F11` 全屏时，布局视口和视觉视口会变大，占满整个屏幕。

**缩放影响**：

- 在桌面端，当用户进行缩放时，浏览器会同时改变**布局视口**和**视觉视口**的大小（以CSS像素为单位）。这是因为桌面端的缩放通常被视为“缩放整个页面”，包括布局。

**缩放具体机制**：

1. 缩放大于 `100%`（放大）：
   - 布局视口和视觉视口的尺寸（CSS像素）会**减小**。
   - 例如：一个宽度为 `1200px` 的窗口，当放大到 `150%` 时，布局视口变为 `800px`（`1200/1.5`）。每个 CSS 像素被放大到 `1.5` 个物理像素，所以 `800px` 的 CSS 像素宽度仍然填满窗口。
2. 缩放小于 `100%`（缩小）：
   - 布局视口和视觉视口的尺寸（CSS像素）会**变大**。
   - 每个 CSS 像素占用更少的物理像素，因此看起来缩小了。

```js
// 浏览器窗口实际宽度：1200物理像素
// 无缩放（100%）时：
document.documentElement.clientWidth = 1200 // 布局视口
window.innerWidth = 1200 // 视觉视口

// 缩放150%（放大）时：
document.documentElement.clientWidth = 800  // 1200/1.5 = 800
window.innerWidth = 800                     // 也变为800

// 缩放50%（缩小）时：
document.documentElement.clientWidth = 2400 // 1200/0.5 = 2400
window.innerWidth = 2400                    // 也变为2400
```

##### 移动端

> js 取值方式与桌面端一样

**1、默认情况（无 `viewport meta` 标签）**：

- 布局视口：通常为 `980px`（iOS）或类似固定宽度
- 视觉视口：设备屏幕宽度。可能比布局视口小
- 结果：视觉视口比布局视口小时，因为要展示所有的网页，所以网页被缩小以适应屏幕

```js
// 设备：iPhone 12
布局视口：980px（默认）
视觉视口：390px（屏幕宽度）
初始缩放比例：390/980 ≈ 0.4 // 网页缩小了
```

**2、设置了 `width=device-width`**：

```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```

- 布局视口宽度 = 设备逻辑像素宽度（如 `375px for iPhone 12`）
- 视觉视口初始等于布局视口

**3、缩放影响**：

- **放大时**：视觉视口变小（CSS像素减少），布局视口不变
- **缩小时**：视觉视口变大，布局视口不变

这是因为移动端的 **布局视口** 通常被设置为与设备宽度相匹配（通过`viewport meta`标签），并且缩放只是放大或缩小已经布局好的页面，而不是重新布局。

```js
// 设备：iPhone 12（390×844逻辑像素）
布局视口：390×844px（CSS像素）
视觉视口（初始）：390×大约724px（减去地址栏）
visualViewport.height: ≈724px

// 滚动后地址栏隐藏
visualViewport.height: ≈802px（减去底部工具栏）

// 缩放至200%
visualViewport.width: 195px（390/2）
visualViewport.height: 约401px（802/2）
```

**4、工具栏影响**：

通常视觉视口会考虑工具栏，以 `iOS Safari` 为例：

```javascript
// 地址栏显示时（页面初始加载）
visualViewport.height ≈ screen.height - 地址栏高度 - 底部工具栏

// 滚动后地址栏隐藏
visualViewport.height ≈ screen.height - 底部工具栏

// 底部输入框弹出时
visualViewport.height ≈ screen.height - 输入框高度
```

### 视口 Meta 标签

```html
<!-- 最常用的视口设置 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- 其他可用属性 -->
<meta name="viewport" content="
  width=device-width,      // 视口宽度等于设备宽度
  initial-scale=1.0,       // 初始缩放比例
  maximum-scale=1.0,       // 最大缩放比例
  minimum-scale=1.0,       // 最小缩放比例
  user-scalable=no,        // 禁止用户缩放
  viewport-fit=cover       // 全面屏适配
">
```

### 常见应用场景

1、**移动端适配**

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

2、**响应式设计断点**

```css
/* 移动设备优先 */
@media (min-width: 768px) { /* 平板 */ }
@media (min-width: 992px) { /* 桌面 */ }
@media (min-width: 1200px) { /* 大屏幕 */ }
```

3、**防止移动端缩放**

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
```

4、**全面屏适配**

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
```

5、**JavaScript监听视口变化**

```javascript
// 监听视口大小变化
window.addEventListener('resize', () => {
  console.log(`视口尺寸: ${window.innerWidth} x ${window.innerHeight}`);
});

// 使用ResizeObserver监听元素尺寸变化
const observer = new ResizeObserver(entries => {
  for (let entry of entries) {
    console.log('元素尺寸变化:', entry.contentRect);
  }
});
```

## CSS 的 vw 和 vh 单位

`vw` 和 `vh` 是 CSS 中的**视口相对长度单位**，它们根据**视觉视口**（`viewport`）的尺寸进行计算。

**基本定义**:

1. **vw (Viewport Width)**
    - **含义**：视口宽度的百分比
    - **1vw** = 视口宽度的 1%
    - **100vw** = 视口宽度的 100%
2. **vh (Viewport Height)**
    - **含义**：视口高度的百分比
    - **1vh** = 视口高度的 1%
    - **100vh** = 视口高度的 100%

**使用示例**:

```css
/* 元素宽度为视口宽度的一半 */
.element {
  width: 50vw;
}

/* 元素高度为整个视口高度 */
.full-height {
  height: 100vh;
}

/* 字体大小随视口宽度变化 */
.responsive-text {
  font-size: 4vw; /* 在1200px宽的屏幕上为48px */
}

/* 创建全屏背景 */
.hero-section {
  width: 100vw;
  height: 100vh;
  background: linear-gradient(blue, purple);
}
```

**vmin 和 vmax**:

- **vmin**：取 `vw` 和 `vh` 中**较小值**的百分比
- **vmax**：取 `vw` 和 `vh` 中**较大值**的百分比

```css
/* 在手机竖屏时：vmin 基于宽度，vmax 基于高度 */
.box {
  width: 50vmin;  /* 视口较小尺寸的50% */
  height: 50vmax; /* 视口较大尺寸的50% */
}
```

### `svh/lvh/dvh`

为解决移动端浏览器UI（地址栏、工具栏）变化问题，CSS引入了大型/小型/动态视口单位

| 单位 | 含义 | 适用场景 |
| ------ | ------ | ---------- |
| **svh** | Small Viewport Height（小型视口高度） | 浏览器UI展开时（地址栏可见） |
| **lvh** | Large Viewport Height（大型视口高度） | 浏览器UI收起时（全屏） |
| **dvh** | Dynamic Viewport Height（动态视口高度） | 自动适应UI状态变化（推荐） |

```css
/* 传统方案（可能被地址栏遮挡） */
.modal {
  height: 100vh; /* 可能超出可见区域 */
}

/* 现代方案（更好的移动端支持） */
.modal {
  height: 100dvh; /* 动态适应浏览器UI变化 */
}

/* 渐进增强写法 */
.modal {
  height: 100vh; /* 回退值 */
  height: 100dvh; /* 现代浏览器 */
}
```

### 注意事项和常见问题

1、**移动端视口问题**

```css
/* iOS Safari 的100vh问题 */
.mobile-fix {
  /* 传统方法（可能有滚动条问题） */
  height: 100vh;
  
  /* 更好的解决方案 */
  height: 100dvh; /* 动态视口高度 */
  height: 100svh; /* 小视口高度 */
  height: 100lvh; /* 大视口高度 */
}
```

2、**滚动条考虑**

```css
/* 100vw 可能包含滚动条宽度，导致水平滚动 */
.problematic {
  width: 100vw; /* 可能导致水平滚动 */
  padding: 0 20px; /* 加上内边距更糟 */
}

/* 解决方案：使用百分比或 calc() */
.solution {
  width: 100%; /* 更安全 */
  /* 或者 */
  width: calc(100vw - 20px);
}
```

3、**组合使用示例**

```css
/* 响应式正方形 */
.square {
  width: 50vmin;  /* 基于较小尺寸 */
  height: 50vmin; /* 保持正方形 */
}

/* 保持宽高比 */
.video-container {
  width: 80vw;
  height: calc(80vw * 9 / 16); /* 16:9 比例 */
}
```

### 最佳实践建议

1. **混合使用单位**：结合 `px、rem、vw` 获得最佳效果

   ```css
   .container {
     max-width: min(90vw, 1200px);
     margin: 0 auto;
   }
   ```

2. **渐进增强**：为不支持 `vw/vh` 的浏览器提供回退

   ```css
   .element {
     width: 800px; /* 回退值 */
     width: 80vw;
   }
   ```

3. **使用 clamp() 限制范围**

   ```css
   .responsive-text {
     font-size: clamp(16px, 4vw, 32px);
   }
   ```
