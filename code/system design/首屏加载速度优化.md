# 首屏加载速度优化

- [首屏加载速度优化](#首屏加载速度优化)
  - [一、网络传输优化](#一网络传输优化)
    - [1. 减少请求数量和大小](#1-减少请求数量和大小)
    - [2. 启用压缩](#2-启用压缩)
    - [3. 使用CDN加速](#3-使用cdn加速)
  - [二、资源加载优化](#二资源加载优化)
    - [1. 优化关键渲染路径](#1-优化关键渲染路径)
    - [2. 预加载关键资源](#2-预加载关键资源)
  - [三、代码层面优化](#三代码层面优化)
    - [1. 代码分割与懒加载](#1-代码分割与懒加载)
    - [2. Tree Shaking](#2-tree-shaking)
    - [3. 减少第三方依赖](#3-减少第三方依赖)
  - [四、浏览器缓存策略](#四浏览器缓存策略)
    - [1. 合理设置缓存头](#1-合理设置缓存头)
    - [2. 使用Service Worker](#2-使用service-worker)
  - [五、服务器优化](#五服务器优化)
    - [1. 启用HTTP/2或HTTP/3](#1-启用http2或http3)
    - [2. 服务器端渲染（SSR）](#2-服务器端渲染ssr)
    - [3. 边缘计算](#3-边缘计算)
  - [六、性能监控与度量](#六性能监控与度量)
    - [1. 核心指标监控](#1-核心指标监控)
      - [FCP](#fcp)
      - [LCP](#lcp)
    - [2. 使用工具分析](#2-使用工具分析)
  - [注意事项](#注意事项)

首屏加载速度慢是常见的性能问题，可以从多个层面进行优化。以下是系统的优化方案：

## 一、网络传输优化

### 1. 减少请求数量和大小

- **资源合并**：合并CSS、JavaScript文件
- **图片优化**：
  - 使用WebP格式（兼容性考虑可配合picture标签）
  - 实现懒加载（Intersection Observer API）
  - 使用CSS Sprite合并小图标
  - 设置合适的图片尺寸，避免加载过大图片
- 减小 js 文件大小：
  - 利用 webpack、vite 代码分割

### 2. 启用压缩

- 开启 Gzip/Brotli 压缩（现代浏览器支持Brotli效果更好）
- 压缩 HTML/CSS/JS 文件（去除注释、空格等）

### 3. 使用CDN加速

- 静态资源部署到CDN
- 选择靠近用户的CDN节点

## 二、资源加载优化

### 1. 优化关键渲染路径

- **CSS优化**：
  - 内联关键 CSS（Critical CSS）
  - 异步加载非关键 CSS

  ```html
  <link rel="preload" href="non-critical.css" as="style" onload="this.rel='stylesheet'">
  ```
  
- **JS优化**：
  - 使用`async`或`defer`属性
  - 避免渲染阻塞的 JavaScript
  
### 2. 预加载关键资源

```html
<!-- 预加载关键资源 -->
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="hero-image.jpg" as="image">

<!-- DNS预解析 -->
<link rel="dns-prefetch" href="//cdn.example.com">

<!-- 预连接 -->
<link rel="preconnect" href="https://api.example.com">
```

## 三、代码层面优化

### 1. 代码分割与懒加载

- **路由级懒加载**（React Router、Vue Router等）
- **组件级懒加载**：

  ```javascript
  // React
  const LazyComponent = React.lazy(() => import('./LazyComponent'));
  
  // Vue
  const LazyComponent = () => import('./LazyComponent.vue')
  ```

### 2. Tree Shaking

- 确保ES6模块语法
- 配置构建工具移除未使用代码

### 3. 减少第三方依赖

- 评估第三方库的必要性
- 按需引入（如lodash的单个函数引入）

## 四、浏览器缓存策略

### 1. 合理设置缓存头

```nginx
# Nginx配置示例
location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}
```

### 2. 使用Service Worker

- 实现离线缓存
- 缓存策略控制（NetworkFirst、CacheFirst等）

## 五、服务器优化

### 1. 启用HTTP/2或HTTP/3

- 多路复用减少连接数
- 头部压缩

### 2. 服务器端渲染（SSR）

- Next.js（React）
- Nuxt.js（Vue）
- 减少首屏白屏时间

### 3. 边缘计算

- 使用边缘函数处理部分逻辑
- 就近生成内容

## 六、性能监控与度量

### 1. 核心指标监控

- **FCP**（First Contentful Paint）
- **LCP**（Largest Contentful Paint）
- **CLS**（Cumulative Layout Shift）
- **TTI**（Time to Interactive）

|指标|全称|用户感知|
|--|--|--|
|FCP|First Contentful Paint|“页面开始有内容了吗？”|
|LCP|Largest Contentful Paint|“主要内容加载完了吗？”|
|CLS|Cumulative Layout Shift|“页面会突然跳动吗？”|
|TBT|Total Blocking Time|“页面卡不卡？”|
|SI|Speed Index|“整体加载快不快？”|

**一个典型的场景：**

一个新闻网站，`FCP` 可能是导航栏的文字先显示出来（~0.8秒），告诉用户页面在加载。而 `LCP` 则是文章的大标题和首张大图完成渲染（~2.2秒），此时用户会觉得可以开始阅读了。

#### FCP

FCP（First Contentful Paint，首次内容绘制）

**定义：**

FCP 测量**从页面开始加载到屏幕上渲染出第一个内容元素**所需的时间。这个“内容”指的是来自 DOM 的元素，例如：

- 第一段文本
- 第一张图片（包括背景图）
- 非白色的 `<canvas>` 元素
- SVG 元素

**它所衡量的：**

FCP 衡量的是用户感知的**页面开始加载的“速度感”**。如果 FCP 时间短，用户会立刻感觉到“有东西出来了，页面在加载”，从而减少焦虑感。

**指标阈值（以移动设备为基准）：**

- **良好：** ≤ 1.0 秒
- **需要改进：** 1.0 秒 ~ 2.5 秒
- **差：** > 2.5 秒

**影响因素和优化建议：**

1. **消除阻塞渲染的资源：** 检查并优化或延迟加载阻塞页面渲染的 CSS 和 JavaScript。
2. **减少服务器响应时间：** 优化服务器、使用 CDN、缓存等。
3. **最小化关键资源大小：** 压缩 CSS/JS/HTML 文件。
4. **移除未使用的 CSS/JS：** 减少需要下载和解析的代码量。
5. **优化首屏内容：** 确保首屏所需的资源优先级最高。

---

#### LCP

LCP（Largest Contentful Paint，最大内容绘制）

**定义：**

LCP 测量**从页面开始加载到视口内最大内容元素（通常是用户最关注的元素）完成渲染**所需的时间。最大内容元素通常是：

- 大尺寸图片（如横幅图、英雄图）
- 大段文本块（如文章标题、段落）
- 视频的封面图
- 带有背景图的元素

**它所衡量的：**

LCP 衡量的是用户感知的**主要内容加载完成的“时间点”**。一个快速的 LCP 能让用户确信页面是**有用的**。这是 Google **Core Web Vitals** 中最核心的加载指标。

**指标阈值（以移动设备为基准）：**

- **良好：** ≤ 2.5 秒
- **需要改进：** 2.5 秒 ~ 4.0 秒
- **差：** > 4.0 秒

**影响因素和优化建议（许多与 FCP 重叠，但更聚焦于最大元素）：**

1. **优化和懒加载图片/视频：**
    - 使用现代图片格式（WebP/AVIF）。
    - 压缩图片，设置合适的尺寸。
    - 使用 `loading=”lazy”` 懒加载非首屏图片，但对 LCP 元素**不要懒加载**，应优先加载。
    - 使用 `<img>` 的 `width` 和 `height` 属性避免布局偏移。
2. **服务器优化：**
    - 升级服务器主机，减少 TTFB。
    - 使用 CDN 分发静态资源。
    - 启用服务器端压缩和缓存。
3. **优化关键渲染路径：**
    - 减少 JavaScript 和 CSS 的阻塞时间。
    - 内联关键 CSS。
    - 延迟非关键的 JavaScript。
4. **移除或延迟第三方脚本：** 广告、分析、聊天插件等第三方资源通常是 LCP 变差的主因。
5. **使用预连接/预加载：** 对最重要的 LCP 资源（如字体、英雄图）使用 `<link rel=”preload”>`。

### 2. 使用工具分析

- Lighthouse
- WebPageTest
- Chrome DevTools Performance面板

## 注意事项

1. **衡量标准**：优先优化LCP（最大内容绘制）指标
2. **用户体验**：使用骨架屏、加载动画缓解等待感
3. **渐进增强**：确保基础功能在慢速网络下可用
4. **A/B测试**：优化前后进行性能对比测试
5. **持续监控**：建立性能预算和报警机制

建议从最容易实现的优化开始，逐步深入，每次优化后都要进行效果评估。性能优化是一个持续的过程，需要结合业务特点和用户实际访问情况不断调整。
