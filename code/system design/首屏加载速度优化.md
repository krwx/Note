# 首屏加载速度优化

- [首屏加载速度优化](#首屏加载速度优化)
  - [一、网络传输优化](#一网络传输优化)
    - [1. 减少请求数量和大小](#1-减少请求数量和大小)
    - [2. 启用压缩](#2-启用压缩)
    - [3. 使用CDN加速](#3-使用cdn加速)
  - [二、资源加载优化](#二资源加载优化)
    - [1. 优化关键渲染路径](#1-优化关键渲染路径)
    - [2. 预加载关键资源](#2-预加载关键资源)
  - [三、代码层面优化](#三代码层面优化)
    - [1. 代码分割与懒加载](#1-代码分割与懒加载)
    - [2. Tree Shaking](#2-tree-shaking)
    - [3. 减少第三方依赖](#3-减少第三方依赖)
  - [四、浏览器缓存策略](#四浏览器缓存策略)
    - [1. 合理设置缓存头](#1-合理设置缓存头)
    - [2. 使用Service Worker](#2-使用service-worker)
  - [五、服务器优化](#五服务器优化)
    - [1. 启用HTTP/2或HTTP/3](#1-启用http2或http3)
    - [2. 服务器端渲染（SSR）](#2-服务器端渲染ssr)
    - [3. 边缘计算](#3-边缘计算)
  - [六、性能监控与度量](#六性能监控与度量)
    - [1. 核心指标监控](#1-核心指标监控)
    - [2. 使用工具分析](#2-使用工具分析)
  - [注意事项](#注意事项)

首屏加载速度慢是常见的性能问题，可以从多个层面进行优化。以下是系统的优化方案：

## 一、网络传输优化

### 1. 减少请求数量和大小

- **资源合并**：合并CSS、JavaScript文件
- **图片优化**：
  - 使用WebP格式（兼容性考虑可配合picture标签）
  - 实现懒加载（Intersection Observer API）
  - 使用CSS Sprite合并小图标
  - 设置合适的图片尺寸，避免加载过大图片
- 减小 js 文件大小：
  - 利用 webpack、vite 代码分割

### 2. 启用压缩

- 开启 Gzip/Brotli 压缩（现代浏览器支持Brotli效果更好）
- 压缩 HTML/CSS/JS 文件（去除注释、空格等）

### 3. 使用CDN加速

- 静态资源部署到CDN
- 选择靠近用户的CDN节点

## 二、资源加载优化

### 1. 优化关键渲染路径

- **CSS优化**：
  - 内联关键 CSS（Critical CSS）
  - 异步加载非关键 CSS

  ```html
  <link rel="preload" href="non-critical.css" as="style" onload="this.rel='stylesheet'">
  ```
  
- **JS优化**：
  - 使用`async`或`defer`属性
  - 避免渲染阻塞的 JavaScript
  
### 2. 预加载关键资源

```html
<!-- 预加载关键资源 -->
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="hero-image.jpg" as="image">

<!-- DNS预解析 -->
<link rel="dns-prefetch" href="//cdn.example.com">

<!-- 预连接 -->
<link rel="preconnect" href="https://api.example.com">
```

## 三、代码层面优化

### 1. 代码分割与懒加载

- **路由级懒加载**（React Router、Vue Router等）
- **组件级懒加载**：

  ```javascript
  // React
  const LazyComponent = React.lazy(() => import('./LazyComponent'));
  
  // Vue
  const LazyComponent = () => import('./LazyComponent.vue')
  ```

### 2. Tree Shaking

- 确保ES6模块语法
- 配置构建工具移除未使用代码

### 3. 减少第三方依赖

- 评估第三方库的必要性
- 按需引入（如lodash的单个函数引入）

## 四、浏览器缓存策略

### 1. 合理设置缓存头

```nginx
# Nginx配置示例
location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}
```

### 2. 使用Service Worker

- 实现离线缓存
- 缓存策略控制（NetworkFirst、CacheFirst等）

## 五、服务器优化

### 1. 启用HTTP/2或HTTP/3

- 多路复用减少连接数
- 头部压缩

### 2. 服务器端渲染（SSR）

- Next.js（React）
- Nuxt.js（Vue）
- 减少首屏白屏时间

### 3. 边缘计算

- 使用边缘函数处理部分逻辑
- 就近生成内容

## 六、性能监控与度量

### 1. 核心指标监控

- **FCP**（First Contentful Paint）
- **LCP**（Largest Contentful Paint）
- **CLS**（Cumulative Layout Shift）
- **TTI**（Time to Interactive）

### 2. 使用工具分析

- Lighthouse
- WebPageTest
- Chrome DevTools Performance面板

## 注意事项

1. **衡量标准**：优先优化LCP（最大内容绘制）指标
2. **用户体验**：使用骨架屏、加载动画缓解等待感
3. **渐进增强**：确保基础功能在慢速网络下可用
4. **A/B测试**：优化前后进行性能对比测试
5. **持续监控**：建立性能预算和报警机制

建议从最容易实现的优化开始，逐步深入，每次优化后都要进行效果评估。性能优化是一个持续的过程，需要结合业务特点和用户实际访问情况不断调整。
