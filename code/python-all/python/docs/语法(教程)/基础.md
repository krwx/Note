# 基础

- [基础](#基础)
  - [语法](#语法)
    - [变量赋值](#变量赋值)
      - [多个变量赋值](#多个变量赋值)
      - [删除对象引用](#删除对象引用)
    - [注释](#注释)
      - [文档字符串](#文档字符串)
    - [行与缩进](#行与缩进)
    - [多行语句](#多行语句)
    - [同一行显示多条语句](#同一行显示多条语句)
    - [print 输出](#print-输出)
    - [import 与 from...import](#import-与-fromimport)
  - [基本数据类型](#基本数据类型)
    - [数字(Number)类型](#数字number类型)
    - [字符串(String)](#字符串string)
      - [字符串前缀](#字符串前缀)
      - [字符串格式化](#字符串格式化)
      - [f-string](#f-string)
    - [bool（布尔类型）](#bool布尔类型)
    - [List（列表）](#list列表)
      - [拼接 list](#拼接-list)
    - [Tuple（元组）](#tuple元组)
    - [Set（集合）](#set集合)
    - [Dictionary（字典）](#dictionary字典)
    - [遍历技巧](#遍历技巧)
    - [解构](#解构)
  - [数据类型转换](#数据类型转换)
  - [运算符](#运算符)
    - [海象运算符](#海象运算符)
  - [if 语句](#if-语句)
  - [match...case 语句](#matchcase-语句)
  - [循环语句](#循环语句)
    - [while 循环](#while-循环)
    - [for 循环](#for-循环)
    - [pass 语句](#pass-语句)
  - [推导式](#推导式)
    - [列表推导式](#列表推导式)
    - [字典推导式](#字典推导式)
    - [集合推导式](#集合推导式)
    - [元组推导式（生成器表达式）](#元组推导式生成器表达式)
  - [迭代器与生成器](#迭代器与生成器)
    - [迭代器](#迭代器)
      - [创建一个迭代器](#创建一个迭代器)
    - [生成器](#生成器)
  - [函数](#函数)
    - [使用](#使用)
    - [不定长参数](#不定长参数)
    - [other](#other)
  - [lambda（匿名函数）](#lambda匿名函数)
  - [装饰器](#装饰器)
    - [使用](#使用-1)
    - [类装饰器](#类装饰器)
      - [函数形式的类装饰器](#函数形式的类装饰器)
      - [类形式的类装饰器（实现 `__call__` 方法）](#类形式的类装饰器实现-__call__-方法)
    - [内置装饰器](#内置装饰器)
    - [多个装饰器的堆叠](#多个装饰器的堆叠)
    - [保留被装饰函数的元数据](#保留被装饰函数的元数据)
  - [模块](#模块)
    - [`__name__` 属性](#__name__-属性)
  - [错误和异常](#错误和异常)
    - [异常处理](#异常处理)
      - [try/except](#tryexcept)
      - [try/except...else](#tryexceptelse)
      - [try-finally](#try-finally)
      - [except、else、finally](#exceptelsefinally)
    - [抛出异常](#抛出异常)
    - [用户自定义异常](#用户自定义异常)
    - [with 关键字](#with-关键字)
  - [面向对象](#面向对象)
    - [使用](#使用-2)
    - [继承](#继承)
      - [子类继承父类构造函数](#子类继承父类构造函数)
    - [多继承](#多继承)
    - [方法重写](#方法重写)
    - [类属性与方法](#类属性与方法)
    - [@dataclass](#dataclass)
  - [枚举（Enum）](#枚举enum)
  - [Flag](#flag)
  - [派生的枚举](#派生的枚举)
    - [IntEnum](#intenum)
    - [other](#other-1)

## 语法

### 变量赋值

变量的名字遵从 `snake_case` 规范：字母小写，单词之间通过 `_` 连接

注意：Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。

赋值后相当于创建了一个对象，变量为对象

注意：`python 中一切都是对象`

**不可更改对象**的理解：变量赋值 `a=5` 后再赋值 `a=10`，这里实际是新生成一个 `int` 值对象 `10`，再让 `a` 指向它，而 `5` 被丢弃，不是改变 `a` 的值，相当于新生成了 `a`。

#### 多个变量赋值

Python允许你同时为多个变量赋值。例如：

```py
a = b = c = 1
```

以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。

您也可以为多个对象指定多个变量。例如：

```py
a, b, c = 1, 2, "runoob"
```

以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 "runoob" 分配给变量 c。

#### 删除对象引用

您也可以使用 `del` 语句删除一些对象引用。

`del` 语句的语法是：

```py
del var1[,var2[,var3[....,varN]]]
```

您可以通过使用del语句删除单个或多个对象。例如：

```py
del var
del var_a, var_b
```

### 注释

```py
# 单行注释

'''
多行注释
多行注释
'''
 
"""
多行注释
"""

print ("Hello, Python!")
```

#### 文档字符串

文档字符串（`Docstrings`）‌是一种特殊的字符串，用于为模块、类、函数或方法提供文档说明。它通过在定义的开头使用三引号来书写。

注意：**文档字符串要放在用于提供说明的代码的下面一行**

```py
def my_function():
    """这是一个文档字符串的例子，用于解释函数的功能和用法。"""
    pass

print(my_function.__doc__)
# 输出：这是一个文档字符串的例子，用于解释函数的功能和用法。
```

### 行与缩进

python 最具特色的就是使用缩进来表示代码块，不需要使用大括号 `{}` 。

缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。如果不同会导致程序报错

### 多行语句

可以使用反斜杠 `\` 来实现多行语句，例如：

```py
total = item_one + \
        item_two + \
        item_three
```

在 `[]`, `{}`, 或 `()` 中的多行语句，不需要使用反斜杠 `\`，例如：

```py
total = ['item_one', 'item_two', 'item_three',
        'item_four', 'item_five']
```

### 同一行显示多条语句

Python 可以在同一行中使用多条语句，语句之间使用分号 `;` 分割，以下是一个简单的实例：

```py
import sys; x = 'runoob'; sys.stdout.write(x + '\n')
```

### print 输出

`print` 默认输出是换行的，如果要实现不换行需要在变量末尾加上 `end=""`：

```py
x="a"
y="b"
# 换行输出
print( x )
print( y )
 
# 不换行输出
print( x, end=" " )
print( y, end=" " )
```

### import 与 from...import

在 python 用 `import` 或者 `from...import` 来导入相应的模块。

- 将整个模块(somemodule)导入，格式为： `import somemodule`
- 从某个模块中导入某个函数,格式为： `from somemodule import somefunction`
- 从某个模块中导入多个函数,格式为： `from somemodule import firstfunc, secondfunc, thirdfunc`
- 将某个模块中的全部函数导入，格式为： `from somemodule import *`

## 基本数据类型

- Number（数字）
- String（字符串）
- bool（布尔类型）
- List（列表）
- Tuple（元组）
- Set（集合）
- Dictionary（字典）

None，null

### 数字(Number)类型

python 中数字有四种类型：整数、布尔型、浮点数和复数。

- `int` (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。
- `bool` (布尔), 如 True。
- `float` (浮点数), 如 1.23、3E-2
- `complex` (复数), 如 1 + 2j、 1.1 + 2.2j

**注意：Python3 中，`bool` 是 `int` 的子类，`True` 和 `False` 可以和数字相加， `True==1`、`False==0` 会返回 `True`，但可以通过 `is` 来判断类型。**

```py
>>> 5 + 4  # 加法
9
>>> 4.3 - 2 # 减法
2.3
>>> 3 * 7  # 乘法
21
>>> 2 / 4  # 除法，得到一个浮点数
0.5
>>> 2 // 4 # 除法，得到一个整数
0
>>> 17 % 3 # 取余 
2
>>> 2 ** 5 # 乘方
32
```

### 字符串(String)

- Python 中单引号 `'` 和双引号 `"` 使用完全相同。
- 使用三引号(`'''` 或 `"""`)可以指定一个多行字符串。
- 转义符 `\`。
- 反斜杠可以用来转义，使用 `r` 可以让反斜杠不发生转义。 如 `r"this is a line with \n"` 则 `\n` 会显示，并不是换行。
- 按字面意义级联字符串，如 `"this " "is " "string"` 会被自动转换为 `this is string`。
- 字符串可以用 `+` 运算符连接在一起，用 `*` 运算符重复。
- Python 中的字符串有两种索引方式，从左往右以 `0` 开始，从右往左以 `-1` 开始。
- Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。
- 字符串切片 `str[start:end]`，其中 `start` （包含）是切片开始的索引， `end` （不包含）是切片结束的索引。
- 字符串的切片可以加上步长参数 `step` ，语法格式如下：`str[start:end:step]`
- **Python 字符串不能被改变**。向一个索引位置赋值，比如 `word[0] = 'm'` 会导致错误。

```py
str='123456789'
 
print(str)                 # 输出字符串
print(str[0:-1])           # 输出第一个到倒数第二个的所有字符
print(str[0])              # 输出字符串第一个字符
print(str[2:5])            # 输出从第三个开始到第六个的字符（不包含）
print(str[2:])             # 输出从第三个开始后的所有字符
print(str[1:5:2])          # 输出从第二个开始到第五个且每隔一个的字符（步长为2）
print(str * 2)             # 输出字符串两次
print(str + '你好')         # 连接字符串
print(str[-3:])         # 输出最后的三个字符
 
print('------------------------------')
 
print('hello\nrunoob')      # 使用反斜杠(\)+n转义特殊字符
print(r'hello\nrunoob')     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义
```

字符串过长，通过 `\` 拆成多行展示。注意拆分后的行前面不能有空格，不然会算在字符串里面

```py
def test():
    s = "德国 10 11 16\n意大利 10 10 20\n荷兰 10 12 14\n法国 10 12 11\n\
英国 22 21 22\n中国 38 32 18\n日本 27 14 17\n美国 39 41 33\n\
俄罗斯奥委会 20 28 23\n澳大利亚 17 7 22\n匈牙利 6 7 7\n加拿大 7 6 11\n古巴 7 3 5\n巴西 7 6 8\n新西兰 7 6 7"
```

判断字符串是否包含关键字：

```py
keyword = "123"
if keyword in "123fasdf":
    print("include keyword")
```

#### 字符串前缀

- `r''`
  - `r` 前缀表示原始字符串（raw string），它会取消字符串中的转义字符（如\n、\t）的特殊含义
  - `path = r'C:\Users\Username\Documents'`
- `b''`
  - `b` 前缀表示字节字符串（bytes string），它用于处理二进制数据，而不是文本数据。字节字符串是不可变的。
  - `binary_data = b'\x48\x65\x6c\x6c\x6f'  # 字母 'Hello' 的字节表示`
  - 字符串和字节字符串是不同的数据类型。
  - `print(type(binary_data))  # 输出 <class 'bytes'>`
- `f''`
  - `f` 前缀表示格式化字符串（formatted string）

#### 字符串格式化

例子：

```py
print ("我叫 %s 今年 %d 岁!" % ('小明', 10))
```

python字符串格式化符号:

|符号| 描述|
|--|--|
|%c|  格式化字符及其ASCII码|
|%s|  格式化字符串|
|%d|  格式化整数|
|%u|  格式化无符号整型|
|%o|  格式化无符号八进制数|
|%x|  格式化无符号十六进制数|
|%X|  格式化无符号十六进制数（大写）|
|%f|  格式化浮点数字，可指定小数点后的精度|
|%e|  用科学计数法格式化浮点数|
|%E|  作用同 %e，用科学计数法格式化浮点数|
|%g|  %f 和 %e 的简写|
|%G|  %f 和 %E 的简写|
|%p|  用十六进制数格式化变量的地址|

#### f-string

`f-string` 是 `python3.6` 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。

`f-string` 格式化字符串以 `f` 开头，后面跟着字符串，字符串中的表达式用大括号 `{}` 包起来，它会将变量或表达式计算后的值替换进去，实例如下：

```py
>>> name = 'Runoob'
>>> f'Hello {name}'  # 替换变量
'Hello Runoob'

>>> f'{1+2}'         # 使用表达式
'3'

>>> w = {'name': 'Runoob', 'url': 'www.runoob.com'}
>>> f'{w["name"]}: {w["url"]}'
'Runoob: www.runoob.com'
```

在 `Python 3.8` 的版本中可以使用 `=` 符号来拼接运算表达式与结果：

```py
>>> x = 1
>>> print(f'{x+1}')   # Python 3.6
2

>>> x = 1
>>> print(f'{x+1=}')   # Python 3.8
x+1=2
```

### bool（布尔类型）

可以使用 `bool()` 函数将其他类型的值转换为布尔值。

所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 0、空字符串、空列表、空元组等被视为 False

### List（列表）

列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。

列表是写在方括号 `[]` 之间、用逗号分隔开的元素列表。

和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。

列表截取的语法格式：`变量[头下标:尾下标]`

索引值以 `0` 为开始值，`-1` 为从末尾的开始位置。

加号 + 是列表连接运算符，星号 * 是重复操作。如下实例：

```py
list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]  # 定义一个列表
tinylist = [123, 'runoob']

print (list)            # 打印整个列表
print (list[0])         # 打印列表的第一个元素
print (list[1:3])       # 打印列表第二到第四个元素（不包含第四个元素）
print (list[2:])        # 打印列表从第三个元素开始到末尾
print (tinylist * 2)    # 打印tinylist列表两次
print (list + tinylist)  # 打印两个列表拼接在一起的结果
print (list[-1])        # 打印列表最后一个元素
```

列表中的元素是可以改变的：

```py
>>> a = [1, 2, 3, 4, 5, 6]
>>> a[0] = 9
>>> a[2:5] = [13, 14, 15]
>>> a
[9, 2, 13, 14, 15, 6]
>>> a[2:5] = []   # 将对应的元素值设置为 []
>>> a
[9, 2, 6]
```

**Python 列表截取可以接收第三个参数，参数作用是截取的步长**，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：

```py
>>> letters = [1, 2, 3, 4, 5, 6]
>>> letters = [1:4:2]
>>> [2, 4]
```

如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：

```py
def reverseWords(input):
     
    # 通过空格将字符串分隔符，把各个单词分隔为列表
    inputWords = input.split(" ")
 
    # 翻转字符串
    # 假设列表 list = [1,2,3,4],  
    # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)
    # inputWords[-1::-1] 有三个参数
    # 第一个参数 -1 表示最后一个元素
    # 第二个参数为空，表示移动到列表末尾
    # 第三个参数为步长，-1 表示逆向
    inputWords=inputWords[-1::-1]
 
    # 重新组合字符串
    output = ' '.join(inputWords)
     
    return output
 
if __name__ == "__main__":
    input = 'I like runoob'
    rw = reverseWords(input)
    print(rw)

# 输出结果为: runoob like I
```

将列表转换成字符串（注意列表中的元素要为字符串类型，不然会报错）：

```py
data_list = ["1", "2", "3"]
data_str = ",".join(data_list)
```

求交集：

```py
a = [1, 2, 3]
b = [2, 3, 4]
result = list(set(a).intersection(set(b)))
result = list(set(a) & (set(b)))
# [2, 3]
```

求并集

```py
a = [1, 2, 3]
b = [2, 3, 4]
result = list(set(a).union(set(b)))
result = list(set(a) | (set(b)))
# [1, 2, 3, 4]
```

在 a 中不在 b 中：

```py
a = [1, 2, 3]
b = [2, 3, 4]
result = list(set(a).difference(set(b)))
result = list(set(a) - (set(b)))
# [1]
```

#### 拼接 list

1、使用加号（+）

```py
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined_list = list1 + list2
print(combined_list)  # 输出: [1, 2, 3, 4, 5, 6]
```

2、直接在原列表上进行操作，使用 `extend()` 方法。

```py
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list3 = [4, 5, 6]
list1.extend(list2)
list1.extend(list3)
print(list1)  # 输出: [1, 2, 3, 4, 5, 6, 4, 5, 6]
```

3、使用*运算符（解包）

```py
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined_list = [*list1, *list2]
print(combined_list)  # 输出: [1, 2, 3, 4, 5, 6]
```

4、使用 `itertools.chain()`

```py
import itertools
 
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined_list = list(itertools.chain(list1, list2))
print(combined_list)  # 输出: [1, 2, 3, 4, 5, 6]
```

### Tuple（元组）

元组（tuple）与列表类似，**不同之处在于元组的元素不能修改**。元组写在小括号 () 里，元素之间用逗号隔开。

元组中的元素类型也可以不相同：

```py
tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )
tinytuple = (123, 'runoob')

print (tuple)             # 输出完整元组
print (tuple[0])          # 输出元组的第一个元素
print (tuple[1:3])        # 输出从第二个元素开始到第三个元素
print (tuple[2:])         # 输出从第三个元素开始的所有元素
print (tinytuple * 2)     # 输出两次元组
print (tuple + tinytuple) # 连接元组
```

### Set（集合）

Python 中的集合（Set）是一种**无序、可变**的数据类型，用于存储唯一的元素。**不能通过索引去访问 Set 中的元素**

集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。

在 Python 中，集合使用大括号 `{}` 表示，元素之间用逗号 , 分隔。

另外，也可以使用 `set()` 函数创建集合。

**注意**：

- 创建一个空集合必须用 `set()` 而不是 `{ }`，因为 `{ }` 是用来创建一个空字典。
- 将集合作为参数传递给函数，是传递指针地址，在函数中更改集合会实际影响集合的（好像是不会的）

创建格式：

```py
parame = {value01,value02,...}
set(value)
```

```py
sites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}

print(sites)   # 输出集合，重复的元素被自动去掉

# 成员测试
if 'Runoob' in sites :
    print('Runoob 在集合中')
else :
    print('Runoob 不在集合中')

# set可以进行集合运算
a = set('abracadabra')
b = set('alacazam')

print(a - b)     # a 和 b 的差集
print(a | b)     # a 和 b 的并集
print(a & b)     # a 和 b 的交集
print(a ^ b)     # a 和 b 中不同时存在的元素
```

操作：

```py
sites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}

sites.add("hello")

print("hello" in sites)
```

### Dictionary（字典）

字典是一种映射类型，字典用 `{ }` 标识，它是一个无序的 键(key) : 值(value) 的集合。

键(key)必须使用不可变类型。

在同一个字典中，键(key)必须是唯一的。

```py
dict = {}
dict['one'] = "1 - 菜鸟教程"
dict[2]     = "2 - 菜鸟工具"

tinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}

print (dict['one'])       # 输出键为 'one' 的值
print (dict[2])           # 输出键为 2 的值
print (tinydict)          # 输出完整的字典
print (tinydict.keys())   # 输出所有键
print (tinydict.values()) # 输出所有值
```

构造函数 `dict()` 可以直接从键值对序列中构建字典如下：

```py
>>> dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])
{'Runoob': 1, 'Google': 2, 'Taobao': 3}

>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}

>>> dict(Runoob=1, Google=2, Taobao=3)
{'Runoob': 1, 'Google': 2, 'Taobao': 3}
```

`{x: x**2 for x in (2, 4, 6)}` 该代码使用的是**字典推导式**

`len()` 函数可以直接用来获取字典中键的数量。

```py
my_dict = {'a': 1, 'b': 2, 'c': 3}
print(len(my_dict))  # 输出: 3
```

用 `in` 判断某个 key 是否在字典里：

```py
print("test_key" in my_dict)
```

> None 不能使用 `**` 解构

### 遍历技巧

在**字典**中遍历时，关键字和对应的值可以使用 `items()` 方法同时解读出来：

```py
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
```

在序列中遍历时，索引位置和对应值可以使用 `enumerate()` 函数同时得到：

```py
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
```

同时遍历两个或更多的序列，可以使用 `zip()` 组合：

```py
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
```

要反向遍历一个序列，首先指定这个序列，然后调用 `reversed()` 函数：

```py
>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
```

要按顺序遍历一个序列，使用 `sorted()` 函数返回一个已排序的序列，并不修改原值：

```py
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
```

### 解构

解构元组或列表：

```py
my_tuple = (1, 2, 3)
a, b, c = my_tuple

my_list = [1, 2, 3]
a, b, c = my_list
```

使用 * 进行解构：

```py
my_list = [1, 2, 3, 4, 5]
a, *rest = my_list
print(a) # 1
print(rest) # [2, 3, 4, 5]

a, *rest, last = my_list
print(a) # 1
print(rest) # [2, 3, 4]
print(last) # 5
```

解构函数返回值：

```py
def test_func():
    return 1, 2, 3

a, b, c = test_func()
```

## 数据类型转换

|函数|描述|
|--|--|
|`int(x [,base])`|将x转换为一个整数|
|float(x)|将x转换到一个浮点数|
|`complex(real [,imag])`|创建一个复数|
|str(x)|将对象 x 转换为字符串|
|repr(x)|将对象 x 转换为表达式字符串|
|eval(str)|用来计算在字符串中的有效Python表达式,并返回一个对象|
|tuple(s)|将序列 s 转换为一个元组|
|list(s)|将序列 s 转换为一个列表|
|set(s)|转换为可变集合|
|dict(d)|创建一个字典。d 必须是一个 (key, value)元组序列。|
|frozenset(s)|转换为不可变集合|
|chr(x)|将一个整数转换为一个字符|
|ord(x)|将一个字符转换为它的整数值|
|hex(x)|将一个整数转换为一个十六进制字符串|
|oct(x)|将一个整数转换为一个八进制字符串|

## 运算符

|运算符|描述|实例|
|--|--|--|
|`**`| 幂 - 返回x的y次幂| `2**3 = 8` |
|`//`| 除法，取整除 - 往小的方向取整数 | `9//2 = 4`; `-9//2 = -5`|
|`%`|模运算，输出第一个参数除以第二个参数的余|`9%2 = 1`; `8%2 = 0`|
|`not`|`not x` 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。| `not 1 = False` |
|`in`| 如果在指定的序列中找到值返回 True，否则返回 False。| x 在 y 序列中 , 如果 x 在 y 序列中返回 True。|
|`not in`| 如果在指定的序列中没有找到值返回 True，否则返回 False。| x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。|
|`is`| `is` 是判断两个标识符是不是引用自一个对象| `x is y`, 类似 `id(x) == id(y)` , 如果引用的是同一个对象则返回 True，否则返回 False|
|`is not`| `is not` 是判断两个标识符是不是引用自不同对象| `x is not y` ， 类似 `id(x) != id(y)`。如果引用的不是同一个对象则返回结果 True，否则返回 False。|
|+=|||
|-=|||

- `in` 和 `not in` 可以用在列表、元组、字符串和字典
- `id()` 函数用于获取对象内存地址。
- `is` 与 `==` 区别：
  - `is` 用于判断两个变量引用对象是否为同一个
  - `==` 用于判断引用变量的值是否相等。

### 海象运算符

使用 `:=` 符号。这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。

```py
# 传统写法
n = 10
if n > 5:
    print(n)

# 使用海象运算符
if (n := 10) > 5:
    print(n)
```

## if 语句

表达式由多个表达式组成的，当前面的表达式为 `True` ，才会执行后面的表达式

```py
if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
```

if 嵌套：

```py
if 表达式1:
    语句
    if 表达式2:
        语句
    elif 表达式3:
        语句
    else:
        语句
elif 表达式4:
    语句
else:
    语句
```

更简洁的写法，可用于三目运算：

```py
result = value1 if condition1 > condition2 else value2
```

- `condition1 > condition2` 为 `true` 则返回 `value1`
- `condition1 > condition2` 为 `false` 则返回 `value2`

## match...case 语句

语法：

```py
match expression:
    case pattern1:
        # 处理pattern1的逻辑
    case pattern2 if condition:
        # 处理pattern2并且满足condition的逻辑
    case pattern3 | pattern4:
        # 匹配多个值
    case _:
        # 处理其他情况的逻辑
```

参数说明：

- `match` 语句后跟一个表达式，然后使用 `case` 语句来定义不同的模式。
- `case` 后跟一个模式，可以是具体值、变量、通配符等。
- 可以使用 `if` 关键字在 `case` 中添加条件。
- `_` 通常用作通配符，匹配任何值。

```py
# 例子1
def match_example(value):
    match value:
        case 1:
            print("匹配到值为1")
        case 2:
            print("匹配到值为2")
        case _:
            print("匹配到其他值")

match_example(1)  # 输出: 匹配到值为1
match_example(2)  # 输出: 匹配到值为2
match_example(3)  # 输出: 匹配到其他值

# 例子2
def match_example(item):
    match item:
        case (x, y) if x == y:
            print(f"匹配到相等的元组: {item}")
        case (x, y):
            print(f"匹配到元组: {item}")
        case _:
            print("匹配到其他情况")

match_example((1, 1))  # 输出: 匹配到相等的元组: (1, 1)
match_example((1, 2))  # 输出: 匹配到元组: (1, 2)
match_example("other") # 输出: 匹配到其他情况

# 类型匹配
class Circle:
    def __init__(self, radius):
        self.radius = radius

class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

def match_shape(shape):
    match shape:
        case Circle(radius=1):
            print("匹配到半径为1的圆")
        case Rectangle(width=1, height=2):
            print("匹配到宽度为1，高度为2的矩形")
        case _:
            print("匹配到其他形状")

match_shape(Circle(radius=1))          # 输出: 匹配到半径为1的圆
match_shape(Rectangle(width=1, height=2)) # 输出: 匹配到宽度为1，高度为2的矩形
match_shape("other")                    # 输出: 匹配到其他形状
```

## 循环语句

### while 循环

一般形式：

```py
n = 100
sum = 0
counter = 1

while counter <= n:
    sum = sum + counter
    counter += 1
 
print("1 到 %d 之和为: %d" % (n,sum))
```

无限循环。可以使用 `CTRL+C` 来退出当前的无限循环。：

```py
var = 1
while var == 1 :  # 表达式永远为 true
   num = int(input("输入一个数字  :"))
   print ("你输入的数字是: ", num)
 
print ("Good bye!")
```

while 循环使用 else 语句。如果 while 后面的条件语句为 false 时，则执行 else 的语句块。

```py
while <expr>:
    <statement(s)>
else:
    <additional_statement(s)>
```

简单语句组：如果你的 while 循环体中**只有一条语句**，你可以将该语句与 while 写在同一行中

```py
flag = 1
while (flag): print ('欢迎访问菜鸟教程!')
```

使用 `break` 语句退出循环

```py
count = 0
while count < 5:
    print(count)
    count += 1
    if count == 3:
        break  # 当 count 等于 3 时退出循环
```

使用 `return` 语句直接返回，不执行代码（包括 while 后面的代码）

```py
count = 0
while count < 5:
    print(count)
    count += 1
    if count == 3:
        return
```

### for 循环

语法：

```py
for <variable> in <sequence>:
    <statements>
else:
    <statements>
```

例子：

```py
# 例子1
sites = ["Baidu", "Google","Runoob","Taobao"]
for site in sites:
    print(site)


# 例子2
word = 'runoob'
for letter in word:
    print(letter)
```

如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句。

```py
sites = ["Baidu", "Google","Runoob","Taobao"]
for site in sites:
    if site == "Runoob":
        print("Runoob!")
        break
    print("循环数据 " + site)
else:
    print("没有循环数据!") # 不会执行这个语句
print("完成循环!")
```

您可以结合 `range()` 和 `len()` 函数以遍历一个序列的索引,如下所示:

```py
>>> a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']
>>> for i in range(len(a)):
...     print(i, a[i])
... 
0 Google
1 Baidu
2 Runoob
3 Taobao
4 QQ
>>>
```

在循环中更改数组的值

```py
# 使用 range 和 len
list_example = [1, 2, 3, 4, 5]

for i in range(len(list_example)):
    list_example[i] += 1  # 例如，将每个元素的值增加1

print(list_example)  # 输出: [2, 3, 4, 5, 6]

# 使用 enumerate
list_example = [1, 2, 3, 4, 5]

for index, value in enumerate(list_example):
    list_example[index] = value * 2  # 例如，将每个元素的值乘以2

print(list_example)  # 输出: [2, 4, 6, 8, 10]

```

**break、continue** 语句

### pass 语句

Python pass是空语句，是为了保持程序结构的完整性。

pass 不做任何事情，一般用做占位语句，如下实例:

```py
>>>while True:
...     pass  # 等待键盘中断 (Ctrl+C)
```

## 推导式

Python 推导式的用途：**可以从一个数据序列构建另一个新的数据序列的结构体**。

Python 支持各种数据结构的推导式：

- 列表(list)推导式
- 字典(dict)推导式
- 集合(set)推导式
- 元组(tuple)推导式

### 列表推导式

格式：

```py
[表达式 for 变量 in 列表] 

# 或者
[表达式 for 变量 in 列表 if 条件]
```

- 表达式：指的是列表的元素最终展示的结果
- if 条件：条件语句，可以过滤列表中不符合条件的值。

例子：

```py
# 例子1
>>> names = ['Bob','Tom','alice','Jerry','Wendy','Smith']
>>> new_names = [name.upper()for name in names if len(name)>3]
>>> print(new_names)
['ALICE', 'JERRY', 'WENDY', 'SMITH']

# 例子2
>>> multiples = [i for i in range(30) if i % 3 == 0]
>>> print(multiples)
[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]
```

### 字典推导式

格式：

```py
{ key_expr: value_expr for value in collection }

# 或
{ key_expr: value_expr for value in collection if condition }
```

例子：

```py
# 例子1。将列表中各字符串值为键，各字符串的长度为值，组成键值对
listdemo = ['Google','Runoob', 'Taobao']
>>> newdict = {key:len(key) for key in listdemo}
>>> newdict
{'Google': 6, 'Runoob': 6, 'Taobao': 6}

# 例子2
>>> dic = {x: x**2 for x in (2, 4, 6)}
>>> dic
{2: 4, 4: 16, 6: 36}
>>> type(dic)
<class 'dict'>
```

### 集合推导式

格式：

```py
{ expression for item in Sequence }
# 或
{ expression for item in Sequence if conditional }
```

例子：

```py
# 计算数字 1,2,3 的平方数：
>>> setnew = {i**2 for i in (1,2,3)}
>>> setnew
{1, 4, 9}


# 判断不是 abc 的字母并输出：
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'d', 'r'}
>>> type(a)
<class 'set'>
```

### 元组推导式（生成器表达式）

元组推导式返回的结果是一个生成器对象。

```py
>>> a = (x for x in range(1,10))
>>> a
<generator object <genexpr> at 0x7faf6ee20a50>  # 返回的是生成器对象

>>> tuple(a)       # 使用 tuple() 函数，可以直接将生成器对象转换成元组
(1, 2, 3, 4, 5, 6, 7, 8, 9)
```

## 迭代器与生成器

### 迭代器

- 迭代器是一个可以记住遍历的位置的对象。
- 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
- 迭代器有两个基本的方法：`iter()` 和 `next()`。
- 字符串，列表或元组对象都可用于创建迭代器

例子：

```py
>>> list=[1,2,3,4]
>>> it = iter(list)    # 创建迭代器对象
>>> print (next(it))   # 输出迭代器的下一个元素
1
>>> print (next(it))
2
>>>
```

迭代器对象可以使用常规 `for` 语句进行遍历:

```py
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print (x, end=" ")
# 1 2 3 4
```

#### 创建一个迭代器

- 把一个类作为一个迭代器使用需要在类中实现两个方法 `__iter__()` 与 `__next__()` 。
- `__iter__()` 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 `__next__()` 方法并通过 `StopIteration` 异常标识迭代的完成。
- `__next__()` 方法会返回下一个迭代器对象。
- `StopIteration` 异常用于标识迭代的完成，防止出现无限循环的情况，在 `__next__()` 方法中我们可以设置在完成指定循环次数后触发 `StopIteration` 异常来结束迭代。

例子：创建一个返回数字的迭代器，初始值为 1，逐步递增 1，在 20 次迭代后停止执行

```py
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a <= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
 
for x in myiter:
  print(x)
```

### 生成器

在 Python 中，使用了 `yield` 的函数被称为生成器（generator）。

`yield` 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。

跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。

当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。

然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。

调用一个生成器函数，返回的是一个迭代器对象。

## 函数

### 使用

格式：

```py
def 函数名（参数列表）:
    函数体
```

如果以 `return [表达式]` 结束函数，选择性地返回一个值给调用方，不带表达式的 `return` 相当于返回 `None` 。

**默认参数**。要放在普通变量的后面。例子：

```py
def printinfo( name, age = 35 ):
   print ("名字: ", name)
   print ("年龄: ", age)
 
#调用printinfo函数
printinfo("runoob")
printinfo("runoob", 20)
```

**关键字参数**：使用关键字参数允许函数调用时参数的顺序与声明时不一致

**注意**：如果部分参数使用关键字，部分参数没有使用关键字，那么参数的顺序一定要按照声明的顺序

```py
def printinfo( name, age ):
   print ("名字: ", name)
   print ("年龄: ", age)
   return
 
printinfo( age=50, name="runoob" )
```

### 不定长参数

`*` 参数只能有一个，`**` 参数也只能有一个。

使用 `*` 表示不定长参数。语法：

```py
def functionname([formal_args,] *var_args_tuple ):
   "函数_文档字符串"
   function_suite
   return [expression]
```

**加了星号 `*` 的参数会以元组(`tuple`)的形式导入**，存放所有未命名的变量参数。

```py
def printinfo( arg1, *vartuple ):
   print ("输出: ")
   print (arg1)
   print (vartuple)
 
printinfo( 70, 60, 50 )

""" 
输出结果：
70
(60, 50)
"""
```

**加了两个星号 `**` 的不定长参数会以字典的形式导入**。

通过 get(key) 或者 get(key, default) 获取参数

```py
#!/usr/bin/python3
  
# 可写函数说明
def printinfo( arg1, **vardict ):
   "打印任何传入的参数"
   print("输出: ")
   print(arg1)
   print(vardict)
   print(vardict.get("c", "5"))
   print(vardict.get("a"))
 
# 调用printinfo 函数
printinfo(1, a=2,b=3)

""" 
输出: 
1
{'a': 2, 'b': 3}
5
2
"""
```

`*` 参数和 `**` 参数可以同时声明：

```py
def testPara(label, *args, **kwargs):
    print(args)
    print(kwargs)

testPara(1, 2, 3, 4, d=2, b=3, c=31)
""" 
结果：
(2, 3, 4)
{'d': 2, 'b': 3, 'c': 31}
"""
```

**声明函数时，参数中星号 `*` 可以单独出现**，但是使用不了不定长参数，例如:

```py
def f(a,b,*,c):
    return a+b+c
```

如果单独出现星号 `*`，则星号 `*` 后的参数必须用关键字传入：

```py
>>> def f(a,b,*,c):
...     return a+b+c
... 
>>> f(1,2,3)   # 报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: f() takes 2 positional arguments but 3 were given

>>> f(1,2,c=3) # 正常
6
```

### other

在编写函数的过程中，可以用 `->` 显式指定函数的参数类型及返回值类型：

```py
def function_demo(param_A: int, param_B: float) -> dict:
    pass
```

## lambda（匿名函数）

lambda 语法格式：`lambda arguments: expression`

- lambda是 Python 的关键字，用于定义 lambda 函数。
- arguments 是参数列表，可以包含零个或多个参数，但必须在冒号(:)前指定。
- expression 是一个表达式，用于计算并返回函数的结果。
- lambda 函数通常只包含一行代码

```py
# 1、没有参数
f = lambda: "Hello, world!"
print(f())  # 输出: Hello, world!

# 2、多个参数
x = lambda a, b : a * b
print(x(5, 6))

# 3、与 filter() 一起，筛选偶数
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # 输出：[2, 4, 6, 8]

# 4、使用 reduce() 和 lambda 表达式演示如何计算一个序列的累积乘积
from functools import reduce
 
numbers = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 输出：120
```

## 装饰器

装饰器（decorators）是 Python 中的一种高级功能，它允许你动态地修改函数或类的行为。

**原理**：装饰器是一种函数，它接受一个函数作为参数，并返回一个新的函数或修改原来的函数。在返回的函数内部你可以执行一些额外的操作，然后调用原始函数 func，并返回其结果。

装饰器的语法使用 `@[decorator_name]` 来应用在函数或方法上。

Python 还提供了一些内置的装饰器，比如 `@staticmethod` 和 `@classmethod`，用于定义静态方法和类方法。

装饰器的应用场景：

- 日志记录: 装饰器可用于记录函数的调用信息、参数和返回值。
- 性能分析: 可以使用装饰器来测量函数的执行时间。
- 权限控制: 装饰器可用于限制对某些函数的访问权限。
- 缓存: 装饰器可用于实现函数结果的缓存，以提高性能。

语法：

```py
def decorator_function(original_function):
    def wrapper(*args, **kwargs):
        # 这里是在调用原始函数前添加的新功能
        before_call_code()
        
        result = original_function(*args, **kwargs)
        
        # 这里是在调用原始函数后添加的新功能
        after_call_code()
        
        return result
    return wrapper

# 使用装饰器
@decorator_function
def target_function(arg1, arg2):
    pass  # 原始函数的实现
```

解析：decorator 是一个装饰器函数，它接受一个函数 func 作为参数，并返回一个内部函数 wrapper，在 wrapper 函数内部，你可以执行一些额外的操作，然后调用原始函数 func，并返回其结果。

```py
@time_logger
def target_function():
    pass

# 等同于
def target_function():
    pass
target_function = time_logger(target_function)
```

### 使用

不带参数：

```py
def addPrint(func):
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        print("add print")
    return wrapper

@addPrint
def testHello(label):
    print("hello" + label)
    pass
```

带参数的装饰器：

```py
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
```

### 类装饰器

类装饰器（Class Decorator）是一种用于**动态修改类行为**的装饰器，它**接收一个类作为参数，并返回一个新的类或修改后的类**。

类装饰器可以用于：

- 添加/修改类的方法或属性
- 拦截实例化过程
- 实现单例模式、日志记录、权限检查等功能

类装饰器有两种常见形式：

- 函数形式的类装饰器（接收类作为参数，返回新类）
- 类形式的类装饰器（实现 `__call__` 方法，使其可调用）

#### 函数形式的类装饰器

以下实例给类添加日志功能：

```py
def log_class(cls):
    """类装饰器，在调用方法前后打印日志"""
    class Wrapper:
        def __init__(self, *args, **kwargs):
            self.wrapped = cls(*args, **kwargs)  # 实例化原始类
        
        def __getattr__(self, name):
            """拦截未定义的属性访问，转发给原始类"""
            return getattr(self.wrapped, name)
        
        def display(self):
            print(f"调用 {cls.__name__}.display() 前")
            self.wrapped.display()
            print(f"调用 {cls.__name__}.display() 后")
    
    return Wrapper  # 返回包装后的类

@log_class
class MyClass:
    def display(self):
        print("这是 MyClass 的 display 方法")

obj = MyClass()
obj.display()
```

#### 类形式的类装饰器（实现 `__call__` 方法）

```py
class DecoratorClass:
    def __init__(self, func):
        self.func = func
    
    def __call__(self, *args, **kwargs):
        # 在调用原始函数之前/之后执行的代码
        result = self.func(*args, **kwargs)
        # 在调用原始函数之后执行的代码
        return result

@DecoratorClass
def my_function():
    pass
```

### 内置装饰器

Python 提供了一些内置的装饰器，例如：

- `@staticmethod`: 将方法定义为静态方法，不需要实例化类即可调用。
- `@classmethod`: 将方法定义为类方法，第一个参数是类本身（通常命名为 cls）。
- `@property`: 将方法转换为属性，使其可以像属性一样访问。

### 多个装饰器的堆叠

你可以将多个装饰器堆叠在一起，它们会按照**从上往下**的顺序依次应用。例如：

```py
def decorator1(func):
    def wrapper():
        print("Decorator 1")
        func()
    return wrapper

def decorator2(func):
    def wrapper():
        print("Decorator 2")
        func()
    return wrapper

@decorator1
@decorator2
def say_hello():
    print("Hello!")

say_hello()

""" 
相当于 say_hello = decorator1(decorator2(say_hello))
"""
```

输出：

```txt
Decorator 1
Decorator 2
Hello!
```

### 保留被装饰函数的元数据

被装饰了的函数的一些元数据（`__name__`, `__doc__` 等等）在被装饰后会丢失

```py
def another_decorator(func):
    def wrapper(*args, **kwargs):
        print("Another thing is happening before the function is called.")
        result = func(*args, **kwargs)
        return result
    return wrapper

@another_decorator
def say_hello():
    """一个简单的打招呼函数。"""
    print("你好！")

say_hello()
print(say_hello.__name__)  # 输出：wrapper
print(say_hello.__doc__)  # 输出：None
```

使用 `functools.update_wrapper` 或 `@functools.wraps` 可以保留这些数据

语法：

- `functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)`
- `@functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)`

使用：

```py
from functools import wraps, update_wrapper

# use wraps
def another_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("Another thing is happening before the function is called.")
        result = func(*args, **kwargs)
        return result
    return wrapper

# or use update_wrapper
def another_decorator(func):
    def wrapper(*args, **kwargs):
        print("Another thing is happening before the function is called.")
        result = func(*args, **kwargs)
        return result
    update_wrapper(wrapper, func)
    return wrapper

@another_decorator
def say_hello():
    """一个简单的打招呼函数。"""
    print("你好！")

say_hello()
print(say_hello.__name__)  # 输出：say_hello
print(say_hello.__doc__)  # 输出：一个简单的打招呼函数。
```

## 模块

```py
# 正确的导入顺序和风格

# 标准库导入
import os
import sys
 
# 第三方库导入
import requests
 
# 应用程序自定义模块导入
from myapp.utils import utility_function
 
# 使用绝对导入
from mypackage import mymodule
 
# 导入模块时，应使用模块的全名，不要使用 import *
```

### `__name__` 属性

一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。

```py
# Filename: using_name.py
if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
```

运行输出如下：

```py
$ python using_name.py
程序自身在运行
```

```py
$ python
>>> import using_name
我来自另一模块
>>>
```

说明： 每个模块都有一个 `__name__` 属性，当其值是'`__main__`'时，表明该模块自身在运行，否则是被引入。

## 错误和异常

### 异常处理

#### try/except

异常捕捉可以使用 `try/except` 语句。

try 语句按照如下方式工作：

- 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。
- 如果没有异常发生，忽略 except 子句，try 子句执行后结束。
- 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 `except` 之后的名称相符，那么对应的 `except` 子句将被执行。
- 如果一个异常没有与任何的 `except` 匹配，那么这个异常将会传递给上层的 `try` 中。

一个 `try` 语句可能包含多个 `except` 子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。

最后一个 `except` 子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。：

```py
import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err: # 使用 except ... as ... 来访问异常
    print("OS error: {0}".format(err))
except ValueError:
    print("Could not convert data to an integer.")
except:
    print("Unexpected error:", sys.exc_info()[0])
    raise
```

一个 `except` 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:

```py
except (RuntimeError, TypeError, NameError):
    pass
```

#### try/except...else

`try/except` 语句还有一个可选的 `else` 子句，如果使用这个子句，那么必须**放在所有的 `except` 子句之后**。

`else` 子句将在 `try` 子句**没有发生任何异常的时候执行**。

```py
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()
```

#### try-finally

`try-finally` 语句无论是否发生异常都将执行最后的代码。

```py
try:
    runoob()
except AssertionError as error:
    print(error)
else:
    try:
        with open('file.log') as file:
            read_data = file.read()
    except FileNotFoundError as fnf_error:
        print(fnf_error)
finally:
    print('这句话，无论异常是否发生都会执行。')
```

#### except、else、finally

- except
  - 发生异常时执行的代码
- else
  - 没有异常时执行的代码
- finally
  - 不管有没有异常都会执行的代码

### 抛出异常

使用 `raise` 语句抛出一个指定的异常。

`raise` 语法格式：`raise [Exception [, args [, traceback]]]`

抛出的异常必须是一个异常的实例或者是异常的类（也就是 `Exception` 的子类）

```py
x = 10
if x > 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
```

可以直接抛出捕获的异常：

```py
try:
    # ...
except Exception as e:
    print(e)
    raise
```

### 用户自定义异常

你可以通过创建一个新的异常类来拥有自己的异常。异常类**继承**自 `Exception` 类，可以直接继承，或者间接继承，例如:

```py
>>> class MyError(Exception):
        def __init__(self, value):
            self.value = value
        def __str__(self):
            return repr(self.value)
   
>>> try:
        raise MyError(2*2)
    except MyError as e:
        print('My exception occurred, value:', e.value)
   
My exception occurred, value: 4
>>> raise MyError('oops!')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
__main__.MyError: 'oops!'
```

### with 关键字

Python 中的 `with` 语句用于异常处理，封装了 `try…except…finally` 编码范式，提高了易用性。

在**处理文件对象**时使用 `with` 关键字是一种很好的做法。

使用 `try...except...finally` 写法：

```py
file = open('./test_runoob.txt', 'w')
try:
    file.write('hello world')
finally:
    file.close()
```

使用 `with` 关键字：

```py
with open('./test_runoob.txt', 'w') as file:
    file.write('hello world !')
```

使用 `with` 关键字系统会**自动调用 `f.close()` 方法**， `with` 的作用等效于 `try/finally` 语句是一样的。

原理：

- with 语句实现原理建立在**上下文管理器**之上。
- 上下文管理器是一个实现 `__enter__` 和 `__exit__` 方法的类。
- 在文件对象中定义了 `__enter__` 和 `__exit__` 方法，即文件对象也实现了上下文管理器
  - 首先调用 `__enter__` 方法，
  - 然后执行 `with` 语句中的代码
  - 最后调用 `__exit__` 方法。
  - 即使出现错误，也会调用 `__exit__` 方法，也就是会关闭文件流。

## 面向对象

- 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 `self` 修饰的变量。

### 使用

使用 `class` 定义类

```py
class MyClass:
    """一个简单的类实例"""
    i = 12345
    def f(self):
        return 'hello world'
 
# 实例化类
x = MyClass()
 
# 访问类的属性和方法
print("MyClass 类的属性 i 为：", x.i)
print("MyClass 类的方法 f 输出为：", x.f())
```

构造方法：`__init__()`，在类实例化时会自动调用，`__init__()` 可以有参数也可以没有参数：

```py
#!/usr/bin/python3
 
class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart
x = Complex(3.0, -4.5)
print(x.r, x.i)   # 输出结果：3.0 -4.5
```

类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 `self`。

注意：**`self` 代表类的实例，而非类。`self.class` 才指向类**

### 继承

语法：

```py
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    <statement-N>
```

例子：

```py
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade))

s = student('ken',10,60,3)
s.speak()
# 结果：ken 说: 我 10 岁了，我在读 3 年级
```

#### 子类继承父类构造函数

- 子类需要自动调用父类的方法：
  - 子类不重写 `__init__()` 方法，实例化子类后，会自动调用父类的 `__init__()` 的方法。
- 子类不需要自动调用父类的方法：
  - 子类重写 `__init__()` 方法，实例化子类后，将不会自动调用父类的 `__init__()` 的方法。
- 子类重写 `__init__()` 方法又需要调用父类的方法：
  - 使用 `super` 关键词：

```py
class Son(Father):
  def __init__(self, name):   
    super().__init__(name)
```

### 多继承

语法：

```py
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    <statement-N>
```

子类调用的方法如果在子类中未找到时，**从左到右**查找父类中是否包含方法。

```py
class student():
    grade = ''
    def __init__(self,g):
        self.grade = g
    def speak(self):
        print("我在读 %d 年级"%(self.grade))
 
#另一个类，多继承之前的准备
class speaker():
    topic = ''
    name = ''
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print("我叫 %s，我是一个演说家，我演讲的主题是 %s"%(self.name,self.topic))
 
#多继承
class sample(speaker,student):
    def __init__(self,n,g,t):
        student.__init__(self,g)
        speaker.__init__(self,n,t)
 
test = sample("Tim",4,"Python")
test.speak()   #方法名同，默认调用的是在括号中参数位置排前父类的方法
# 结果：我叫 Tim，我是一个演说家，我演讲的主题是 Python
```

### 方法重写

```py
class Parent:        # 定义父类
   def myMethod(self):
      print ('调用父类方法')
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print ('调用子类方法')
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法

""" 
结果：
调用子类方法
调用父类方法
"""
```

### 类属性与方法

- 私有属性
  - `__private_attrs`：**两个下划线开头**，声明该属性为私有，不能在类的外部被使用或直接访问。
  - 在类内部的方法中使用时 `self.__private_attrs`
- 私有方法
  - `__private_method`：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。
  - `self.__private_methods`

```py
class Site:
    def __init__(self, name, url):
        self.name = name       # public
        self.__url = url   # private
 
    def who(self):
        print('name  : ', self.name)
        print('url : ', self.__url)
 
    def __foo(self):          # 私有方法
        print('这是私有方法')
 
    def foo(self):            # 公共方法
        print('这是公共方法')
        self.__foo()
 
x = Site('菜鸟教程', 'www.runoob.com')
x.who()        # 正常输出
x.foo()        # 正常输出
x.__foo()      # 报错
```

类的专有方法：

- `__init__` : 构造函数，在生成对象时调用
- `__del__` : 析构函数，释放对象时使用
- `__repr__` : 打印，转换
- `__setitem__` : 按照索引赋值
- `__getitem__`: 按照索引获取值
- `__len__`: 获得长度
- `__cmp__`: 比较运算
- `__call__`: 函数调用
- `__add__`: 加运算
- `__sub__`: 减运算
- `__mul__`: 乘运算
- `__truediv__`: 除运算
- `__mod__`: 求余运算
- `__pow__`: 乘方
- `__str__`：print(object) 时用

运算符重载例子：

```py
class Vector:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __str__(self):
        return "Vector (%d, %d)" % (self.a, self.b)

    def __add__(self, other):
        return Vector(self.a + other.a, self.b + other.b)
 
v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)

# 解析：加法运算返回了 Vector 对象，使用 print() 触发 Vector 对象的 __str__() 方法
```

### @dataclass

1

## 枚举（Enum）

基本使用：

```py
from enum import Enum

# 创建枚举类
class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

# 使用
print(Color.RED) # Color.RED
print(Color.RED.name) # RED
print(Color.RED.value) # 1
print(Color(1)) # Color.RED
print(Color["RED"]) # Color.RED
print(Color["GREEN"]) # Color.GREEN

print(isinstance(Color.RED, Color)) # True
```

遍历和比较：

```py
for color in Color:
    print(color) # 打印枚举成员

print(Color.RED == Color.BLUE)
```

使用 `auto()` 自动生成值，将从 1 开始自动分配

```py
from enum import Enum, auto

class Color(Enum):
    RED = auto()
    GREEN = auto()
    BLUE = auto()

# 使用
print(Color.RED.value) # 1
print(Color.GREEN.value) # 2
print(Color.BLUE.value) # 3
```

声明静态方法，实现自定义检查

```py
from enum import Enum, auto

class Color(Enum):
    RED = auto()
    GREEN = auto()
    BLUE = auto()

    @staticmethod
    def is_primary_color(value):
        return value in (Color.RED, Color.GREEN)

print(Color.is_primary_color(Color.RED)) # True
print(Color.is_primary_color(Color.BLUE)) # False
```

别名。当两个成员被赋予相同的值，第二个成员为第一个成员的别名

```py
from enum import Enum

class Status(Enum):
    ACTIVE = 1
    RUNNING = 2

print(Status.ACTIVE == Status.RUNNING) # True
```

使用函数的方式创建枚举

```py
from enum import Enum

Animal = Enum('Animal', 'ANT BEE CAT DOG')
print(Animal.ANT) # Animal.ANT
print(Animal.BEE.value) # 2

Color = Enum('Color', [('RED', 1), ('GREEN', 2), ('BLUE', 3)])
```

使用 `@unique`，如果枚举有任何别名的话会报错

```py
from enum import Enum, unique

@unique
class Color(Enum):
    RED = 1
    BLUE = 1
# 运行程序时会报错：ValueError: duplicate values found in <enum 'Color'>: BLUE -> RED
```

自定义枚举类，自定义方法和属性

```py
from enum import Enum

class Color(Enum):
    RED = 1
    BLUE = 1

    def describe(self):
        return f"{self.name} is my favourite color"
    
    @property
    def primary(self):
        return self in (Color.RED, Color.GREEN)

print(Color.RED.describe()) # RED is my favourite color
print(Color.BLUE.primary) # False
```

## Flag

`Flag` 与 `Enum` 的相同，但其成员支持按位运算符 `& (AND), | (OR), ^ (XOR) 和 ~ (INVERT)`，这些运算的结果都是枚举成员（的别名）。

创建：

```py
from enum import Flag
class Weekday(Flag):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 4
    THURSDAY = 8
    FRIDAY = 16
    SATURDAY = 32
    SUNDAY = 64
```

使用：

```py
# 将几个成员并入一个变量
weekend = Weekday.SATURDAY | Weekday.SUNDAY
print(weekend) # <Weekday.SATURDAY|SUNDAY: 96>

# 迭代
for day in weekend:
    print(day)
# Weekday.SATURDAY
# Weekday.SUNDAY
```

## 派生的枚举

### IntEnum

`IntEnum` 的成员可与整数进行比较；通过扩展，不同类型的整数枚举也可以相互进行比较:

```py
from enum import IntEnum
class Shape(IntEnum):
    CIRCLE = 1
    SQUARE = 2

class Request(IntEnum):
    POST = 1
    GET = 2

print(Shape.CIRCLE == 1) # True
print(Shape.CIRCLE == Request.POST) # True
```

不过，它们仍然不可与标准 `Enum` 枚举进行比较:

```py
class Shape(IntEnum):
    CIRCLE = 1
    SQUARE = 2

class Color(Enum):
    RED = 1
    GREEN = 2

print(Shape.CIRCLE == Color.RED) # False
```

### other

StrEnum, IntFlag
