# 模块

模块是包含 `Python` 定义和语句的文件。其文件名是模块名加后缀名 `.py` 。

在模块内部，通过全局变量 `__name__` 可以获取模块名（即字符串）。

每个模块都有自己的私有命名空间，它会被用作模块中定义的所有函数的全局命名空间。

- [模块](#模块)
  - [模块搜索路径](#模块搜索路径)
    - [流程](#流程)
    - [sys.path 的组成](#syspath-的组成)
    - [修改搜索路径](#修改搜索路径)
      - [操作 sys.path](#操作-syspath)
        - [添加相对路径](#添加相对路径)
        - [添加绝对路径](#添加绝对路径)
        - [bat 文件运行 python 文件](#bat-文件运行-python-文件)
        - [尽量使用绝对路径](#尽量使用绝对路径)
      - [设置环境变量 PYTHONPATH](#设置环境变量-pythonpath)
  - [`__init__.py`](#__init__py)
  - [包](#包)
    - [导入](#导入)
      - [import 模块](#import-模块)
      - [from 模块 import 模块](#from-模块-import-模块)
      - [from 模块 import 函数或变量](#from-模块-import-函数或变量)
    - [从包中导入 `*`](#从包中导入-)

## 模块搜索路径

### 流程

- 当导入一个名为 `spam` 的模块时，解释器首先会搜索具有该名称的**内置模块**。
  - 这些模块的名称在 `sys.builtin_module_names` 中列出。
- 如果未找到，它将在变量 `sys.path` 所给出的目录列表中搜索名为 `spam.py` 的文件。
  - Python 按 `sys.path` 的顺序依次查找，找到第一个匹配的模块后停止
  - 路径的顺序非常重要：
    - 如果自定义模块与标准库同名，且路径在标准库之前，会导致覆盖。
    - 使用 `sys.path.insert(0, ...)` 可提高自定义路径的优先级。

### sys.path 的组成

`sys.path` 包含以下路径（按顺序）：

- 当前运行脚本所在的目录（非当前工作目录）。
  - `python -m module` 命令行：添加当前工作目录。
  - `python script.py` 命令行：添加脚本的目录
  - `python -c code` 和 `python (REPL)` 命令行：添加一个空字符串，这表示当前工作目录。
- 环境变量 `PYTHONPATH`：用户自定义的路径。
- 标准库目录：`Python` 安装的默认库路径。
- 第三方库目录：如 `site-packages`（通过 `pip` 安装的包存放位置）。
- `.pth` 文件定义的路径：在 `site-packages` 目录中，`.pth` 文件可以添加额外路径。
- 代码手动添加的路径（ `sys.path.append()` , `sys.path.extend()` ）

假设当前运行的脚本的路径为 `c:\\Users\\admin\\probject\\business\\test.py`, 查看路径：

```py
import sys
print(sys.path)

""" 
[
  # 当前脚本所在的目录
  'c:\\Users\\admin\\probject\\business',
  # 标准库目录：
  'C:\\Users\\admin\\.conda\\envs\\python_test\\python310.zip', 
  'C:\\Users\\admin\\.conda\\envs\\python_test\\DLLs', 
  'C:\\Users\\admin\\.conda\\envs\\python_test\\lib', 
  'C:\\Users\\admin\\.conda\\envs\\python_test', 
  # 第三方库目录
  'C:\\Users\\admin\\.conda\\envs\\python_test\\lib\\site-packages', 
  'C:\\Users\\admin\\.conda\\envs\\python_test\\lib\\site-packages\\win32', 
  'C:\\Users\\admin\\.conda\\envs\\python_test\\lib\\site-packages\\win32\\lib', 
  'C:\\Users\\admin\\.conda\\envs\\python_test\\lib\\site-packages\\Pythonwin', 
  # 代码手动添加的路径
  '/db_connection/handler'
]
"""
```

### 修改搜索路径

#### 操作 sys.path

```py
import sys
sys.path.append("/path/to/your/module")   # 添加到列表末尾
sys.path.insert(0, "/path/to/priority")   # 插入到列表开头（优先级最高）
```

> 如果添加了不存在的路径，那么该路径会被忽略掉，不会报错

##### 添加相对路径

当你向 `sys.path` 添加一个相对路径（例如 `"../home"`）时，最终的完整搜索路径取决于 Python 解释器的当前工作目录（Current Working Directory, CWD），而不是脚本所在目录。

假设当前的工作目录为 `c:\work\test`，运行脚本的目录为 `c:\work\test\connect\test.py`

- 添加 `./`
  - 完整路径：`c:\work\test\`
- 添加 `../`
  - 完整路径：`c:\work\`
- 添加 `./business`
  - 完整路径：`c:\work\test\business`
- 添加 `../business`
  - 完整路径：`c:\work\business`
- 添加 `../test`
  - 完整路径：`c:\work\test`
  - 解析：先解析 `../`，先返回上一级，再进入 `test` 文件夹

在代码中动态打印解析后的路径：

```python
import sys
import os

# 添加相对路径 "../home"
sys.path.append("../home")

# 打印 sys.path 中的最后一个路径（即刚添加的路径）
added_path = sys.path[-1]
abs_path = os.path.abspath(added_path)
print(f"实际添加的绝对路径：{abs_path}")
```

##### 添加绝对路径

路径的组成为：当前工作目录所在盘 + 绝对路径

假设当前的工作目录为 `c:\work\test`

- 添加 `/db_connection`
  - 完整路径：`c:\db_connection`
- 添加 `business/test`
  - 完整路径：`c:\business\test`
- 添加 `d:/abc`
  - 完整路径：`d:\abc`

##### bat 文件运行 python 文件

假设 bat 文件的路径为 `c:\work\test\scripts\test.bat` ，运行的 py 文件的路径为 `c:\work\test\connect\test.py`

- 相对路径
  - 当前的工作目录为 `c:\work\test\scripts\`，完整路径取决于该路径
  - 添加 `./`
    - 完整路径：`c:\work\test\scripts\`
  - 添加 `../`
    - 完整路径：`c:\work\test\`
  - 添加 `./business`
    - 完整路径：`c:\work\test\scripts\business`
- 绝对路径
  - 添加 `/db_connection`
    - 完整路径：`c:\db_connection`
  - 添加 `business/test`
    - 完整路径：`c:\business\test`

##### 尽量使用绝对路径

因为相对路径会随着当前工作目录变化而变化，所以用绝对路径能准确定位到对应的模块

```py
import sys
import os

# 获取当前脚本的目录（例如：/project/scripts）
script_dir = os.path.dirname(os.path.abspath(__file__))

# 基于脚本目录构造目标路径
target_dir = os.path.join(script_dir, "../home")
sys.path.append(os.path.abspath(target_dir))
```

#### 设置环境变量 PYTHONPATH

在终端中设置（临时生效）：

```sh
bash
# Linux/macOS
export PYTHONPATH="/path/to/your/module:$PYTHONPATH"

# Windows
set PYTHONPATH=C:\path\to\your\module;%PYTHONPATH%
```

或在 `.bashrc/.zshrc`（Linux/macOS）或系统环境变量（Windows）中永久设置。

## `__init__.py`

1、基本作用‌

`__init__.py` 文件的主要功能包括：

- ‌标识包‌：告诉 Python 解释器该目录应被视为包（Package），而非普通目录。
- ‌初始化包‌：在导入包时自动执行文件内的代码（如设置包级变量、导入依赖等）。
- ‌定义命名空间‌：控制包内哪些模块或变量可被外部导入（通过 `__all__` 列表）。

2、常见用法‌

- ‌空文件‌：仅作为包标识，无需额外功能时可保留为空。
- ‌导入与重新导出‌：在 `__init__.py` 中导入子模块内容并暴露给外部，简化用户导入路径（如 `from my_package import function1` ）。
- ‌包级配置‌：设置常量（如 `VERSION` ）、环境变量或日志配置，供包内所有模块共享。
- ‌自动初始化‌：执行包启动时的必要操作（如数据库连接）。

> ‌`Python 3.3+` 的隐式命名空间包‌：目录不含 `__init__.py` 也可能被视为包，但显式使用该文件仍是推荐做法。

## 包

包是通过使用“带点号模块名”来构造 Python 模块命名空间的一种方式。 例如，模块名 `A.B` 表示名为 `A` 的包中名为 `B` 的子模块。

### 导入

假设现在有一个 sound 包，目录结构如下

```txt
sound/                          最高层级的包
      __init__.py               初始化 sound 包
      formats/                  用于文件格式转换的子包
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  用于音效的子包
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  用于过滤器的子包
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
```

从包中导入模块有 3 种语法

#### import 模块

```py
import sound.effects.echo
```

这将加载子模块 sound.effects.echo。 它**必须通过其全名来引用**。

```py
sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
```

> 使用 `import item.subitem.subsubitem` 句法时，除最后一项外，每个 `item` 都必须是包；最后一项可以是模块或包，但不能是上一项中定义的类、函数或变量。

#### from 模块 import 模块

```py
from sound.effects import echo
```

这也会加载子模块 echo，并使其不必加包前缀，因此可按如下方式使用:

```py
echo.echofilter(input, output, delay=0.7, atten=4)
```

#### from 模块 import 函数或变量

```py
from sound.effects.echo import echofilter
```

同样，这将加载子模块 echo，但这使其函数 echofilter() 直接可用:

```py
echofilter(input, output, delay=0.7, atten=4)
```

import 语句首先测试包中是否定义了 item；如果未在包中定义，则假定 item 是模块，并尝试加载。如果找不到 item，则触发 ImportError 异常。

### 从包中导入 `*`

注意：**不推荐使用这种方式导入**

语法：`from package import *`

解释：

- `package` 在 `__init__.py` 定义了列表 `__all__`
  - 导入 `__all__` 指定的内容
- `package` 没有在 `__init__.py` 定义了列表 `__all__`
  - 不会把 `package` 中的所有子模块都导入到当前命名空间
  - 只确保 `package` 已被导入（可能还会运行 `__init__.py` 中的任何初始化代码）
  - 然后再导入包中定义的任何名称。
    - 包括由 `__init__.py` 定义的任何名称。
    - 包括 `import` 语句显式加载的包里的任何子模块。

例子：

1、定义了列表 `__all__`

```py
__all__ = ["echo", "surround", "reverse"]
```

这意味着 `from sound.effects import *` 将导入 `sound.effects` 包的三个命名子模块。

2、定义了列表 `__all__`，但是定义了一个同名的函数，这样这样函数会覆盖掉同名的模块

```py
__all__ = [
    "echo",      # 指向 'echo.py' 文件
    "surround",  # 指向 'surround.py' 文件
    "reverse",   # !!! 现在指向 'reverse' 函数 !!!
]

def reverse(msg: str):  # <-- 此名称将覆盖 'reverse.py' 子模块
    return msg[::-1]    #     针对 'from sound.effects import *' 的情况
```

3、没有定义列表 `__all__`，但是通过 `import` 显示加载子模块

```py
import sound.effects.echo
import sound.effects.surround
from sound.effects import *
```

`echo` 和 `surround` 模块会被导入到当前命名空间
