# 内置函数

- [内置函数](#内置函数)
  - [装饰器](#装饰器)
    - [classmethod](#classmethod)
    - [staticmethod](#staticmethod)
    - [classmethod 和 staticmethod 的区别](#classmethod-和-staticmethod-的区别)
  - [range()](#range)
  - [print()](#print)
  - [list()](#list)
  - [map()](#map)
  - [filter()](#filter)
  - [enumerate()](#enumerate)
  - [zip()](#zip)
  - [reversed()](#reversed)
  - [sorted()](#sorted)
  - [iter()](#iter)
  - [next()](#next)
  - [super()](#super)
  - [str()](#str)
  - [repr()](#repr)
    - [repr() 和 str() 主要区别](#repr-和-str-主要区别)
  - [any()](#any)
    - [any() + 列表推导式](#any--列表推导式)
  - [all()](#all)
  - [hasattr()](#hasattr)
  - [setattr()](#setattr)
  - [len()](#len)

## 装饰器

### classmethod

把一个方法封装成**类方法**。`classmethod` 修饰符对应的函数不需要实例化。

语法：

```py
class C:
    @classmethod
    def f(cls, arg1, arg2): ...
```

- 类方法的调用可以在类上进行 (例如 `C.f()`) 也可以在实例上进行 (例如 `C().f()`)。
- 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。

参数：

- 第一个参数不是 `self` 参数（实例变量）
- **第一个参数是表示自身类的参数（参数名可以随便设置，按照规范最好为 `cls`）**，可以来调用类的属性，类的方法，实例化对象等。
- 第一个参数后可以再声明其他参数

```py
class A(object):
    bar = 1
    def func1(self):  
        print ('foo') 
    @classmethod
    def func2(cls):
        print ('func2')
        print (cls.bar)
        cls().func1()   # 调用 func1 方法
 
A.func2()               # 不需要实例化

""" 
输出结果：
func2
1
foo 
"""
```

> 类方法不再可以包装其他 `descriptors` 例如 `property()`。

### staticmethod

将方法转换为静态方法。

静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法

```py
class C:
    @staticmethod
    def f(arg1, arg2, argN): ...
```

例子：

```py
class C(object):
    @staticmethod
    def f():
        print('runoob')
 
C.f();          # 静态方法无需实例化
cobj = C()
cobj.f()        # 也可以实例化后调用
```

### classmethod 和 staticmethod 的区别

- 参数传递:
  - @classmethod: 类方法的第一个参数是类本身，通常命名为 cls，用于访问类的属性和方法。
  - @staticmethod: 静态方法没有默认的类或实例参数，它与类和实例无关。
- 访问类属性:
  - @classmethod: 可以访问和修改类的属性，因为它有一个指向类的第一个参数。
  - @staticmethod: 无法直接访问类的属性，因为它没有指向类的参数。
- 使用场景:
  - @classmethod: 适用于与类相关的操作，但不依赖于实例的状态。常用于工厂方法或操作类级别的属性。
  - @staticmethod: 适用于与类和实例无关的操作。如果方法不需要访问类或实例的状态，可以使用静态方法。

## range()

`Python3` `range()` 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。

`Python3` `list()` 函数是对象迭代器，可以把 `range()` 返回的可迭代对象转为一个列表，返回的变量类型为列表。

语法：

```py
range(stop)
range(start, stop[, step])
```

- `start`: 计数从 `start` 开始。默认是从 0 开始。例如 `range(5)` 等价于 `range(0， 5)`
- `stop`: 计数到 `stop` 结束，**但不包括 `stop`**。例如：`range(0， 5)` 是 `[0, 1, 2, 3, 4]` 没有 `5`
- `step`：步长，默认为 1。例如：`range(0， 5)` 等价于 `range(0, 5, 1)`

例子：

```py
for number in range(1, 6):
    print(number)

'''
结果：
1
2
3
4
5
'''
```

## print()

`print()` 方法用于打印输出

语法:

`print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)`

参数：

- objects -- 复数，表示可以一次输出多个对象。输出多个对象时，需要用 `,` 分隔。
- sep -- 用来间隔多个对象，默认值是一个空格。
- end -- 用来设定以什么结尾。**默认值是换行符 `\n`**，我们可以换成其他字符串。
- file -- 要写入的文件对象。
- flush -- 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。

## list()

`list()` 方法用于将元组或字符串转换为列表。

```py
aTuple = (123, "Google", "Runoob", "Taobao")
list1 = list(aTuple)
print("列表元素 : ", list1)

str = "Hello World"
list2 = list(str)
print("列表元素 : ", list2)
```

## map()

`map()` 函数会根据提供的函数对指定序列做映射。

map() 方法的语法: `map(function, iterable, ...)`

- function -- 函数。以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。
- iterable -- 一个或多个序列

注意：**结果返回迭代器**

```py
>>> def square(x) :         # 计算平方数
...     return x ** 2
... 
>>> map(square, [1,2,3,4,5])    # 计算列表各个元素的平方
<map object at 0x100d3d550>     # 返回迭代器

>>> list(map(square, [1,2,3,4,5]))   # 使用 list() 转换为列表
[1, 4, 9, 16, 25]

>>> list(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))   # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
>>>
```

## filter()

`filter()` 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象

该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。

语法：`filter(function, iterable)`

```py
# 过滤出列表中的所有奇数 
def is_odd(n):
    return n % 2 == 1

tmplist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
newlist = list(tmplist)
print(newlist)
```

## enumerate()

`enumerate()` 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。

语法: `enumerate(sequence, [start=0])`

参数

- sequence -- 一个序列、迭代器或其他支持迭代对象。
- start -- 下标起始位置。**这里指的是返回的 `enumerate` 对象的下标开始位置，不是序列的开始遍历的位置**

返回值：返回 `enumerate` 对象。

```py
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']

>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]

>>> list(enumerate(seasons, start=1))       # 下标从 1 开始
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

```py
seq = ['one', 'two', 'three']
for i, element in enumerate(seq):
    print(i, element)
```

## zip()

`zip()` 函数用于将可迭代的对象（如列表、元组、字符串等）作为参数，将对象中对应的元素打包成一个个元组，然后**返回由这些元组组成的对象**。

可以使用 `list()` 转换 `zip()` 返回的结果来输出列表。

理解：

```py
a = [a1, a2, a3]
b = [b1, b2, b3]

print(list(zip(a, b)))
# 结果
# [(a1, b1), (a2, b2), (a3, b3)]
```

如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。

利用 `*` 号操作符，可以将元组解压为列表。

```py
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> c = [4,5,6,7,8]

>>> zipped = zip(a,b)     # 返回一个对象

>>> zipped
<zip object at 0x103abc288>

# list() 转换为列表
>>> list(zipped)  
[(1, 4), (2, 5), (3, 6)]

# 元素个数与最短的列表一致
>>> list(zip(a,c))              
[(1, 4), (2, 5), (3, 6)]

# 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式
>>> a1, a2 = zip(*zip(a,b))         
>>> list(a1)
[1, 2, 3]
>>> list(a2)
[4, 5, 6]
>>>
```

## reversed()

reversed 函数返回一个反转的迭代器。

```py
# 字符串
seqString = 'Runoob'
print(list(reversed(seqString)))
 
# 元组
seqTuple = ('R', 'u', 'n', 'o', 'o', 'b')
print(list(reversed(seqTuple)))
 
# range
seqRange = range(5, 9)
print(list(reversed(seqRange)))
 
# 列表
seqList = [1, 2, 4, 3, 5]
print(list(reversed(seqList)))

""" 
以上实例输出结果为：
['b', 'o', 'o', 'n', 'u', 'R']
['b', 'o', 'o', 'n', 'u', 'R']
[8, 7, 6, 5]
[5, 3, 4, 2, 1]
"""
```

## sorted()

`sorted()` 函数**对所有可迭代的对象**进行排序操作。

> **sort 与 sorted 区别**：
>
> sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。
>
> list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。

语法：`sorted(iterable, key=None, reverse=False)`

参数说明：

- iterable -- 可迭代对象。
- key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
- reverse -- 排序规则，reverse = True 降序 ， **reverse = False 升序（默认）**。

返回值：返回重新排序的列表。

```py
# 1、
>>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]                      # 默认为升序

# 2、
>>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]

# 3、倒序排序
>>> example_list = [5, 0, 6, 1, 2, 7, 3, 4]
>>> sorted(example_list, reverse=True)
[7, 6, 5, 4, 3, 2, 1, 0]

# 4、
student_tuples = [
    ('john', 'A', 15),
    ('jane', 'B', 12),
    ('dave', 'B', 10),
]
print(sorted(student_tuples, key=lambda student: student[2]))   # sort by age
# 结果：
# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
```

不懂：

`new_para = sorted(para.items(), key=lambda x: (x[1], x[0]))` 这里不懂排序的规则是什么

```py
def main():
    s = "德国 10 11 16\n意大利 10 10 20\n荷兰 10 12 14\n法国 10 12 11\n\
英国 22 21 22\n中国 38 32 18\n日本 27 14 17\n美国 39 41 33\n\
俄罗斯奥委会 20 28 23\n澳大利亚 17 7 22\n匈牙利 6 7 7\n加拿大 7 6 11\n古巴 7 3 5\n巴西 7 6 8\n新西兰 7 6 7"

    stodata = s.split("\n", -1)

    # 使用sorted
    para = {}

    for line in stodata:
        # 每一行数据
        data = line.split(" ")
        print(data)
        # 组装数据结构para={'China': [], 'Russia': []}
        # 转换成负数
        para[data[0]] = [int("-" + i) for i in data[1:]]
    
    # 开始排序(x[1]代表奖牌数目, x[0]代表国家)
    new_para = sorted(para.items(), key=lambda x: (x[1], x[0]))
    print()

    c = []
    for i in new_para:
        c.append((i[0]))
    for j in range(15):
        print(f"{(j+1):2d}  {c[j]}")
```

## iter()

iter() 函数用来生成迭代器。

语法：`iter(object[, sentinel])`

参数

- object -- 支持迭代的集合对象。
- sentinel -- 如果传递了第二个参数，则参数 **`object` 必须是一个可调用的对象（如，函数）**，此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的__next__()方法时，都会调用 object。

返回值：迭代器对象。

```py
>>>lst = [1, 2, 3]
>>> for i in iter(lst):
...     print(i)
... 
1
2
3
```

## next()

`next()` 返回迭代器的下一个项目。

`next()` 函数要和生成迭代器的 `iter()` 函数一起使用。

语法：`next(iterable[, default])`

参数说明：

- iterable -- 可迭代对象
- default -- 可选，用于**设置在没有下一个元素时返回该默认值**，如果不设置，又没有下一个元素则会触发 StopIteration 异常。

返回值：返回下一个项目。

```py
# 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
        print(x)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
```

## super()

`super()` 函数是用于调用父类(超类)的一个方法。

`super()` 方法的语法: `super(type[, object-or-type])`

`Python3.x` 和 `Python2.x` 的一个区别是: `Python 3` 可以在类方法中直接使用 `super().xxx` 代替 `super(Class, self).xxx` :

```py
# Python3.x 实例：
class A:
     def add(self, x):
         y = x+1
         print(y)
class B(A):
    def add(self, x):
        super().add(x)
b = B()
b.add(2)  # 3
Python2.x 实例：

# Python2.x 实例：
class A(object):   # Python2.x 记得继承 object
    def add(self, x):
         y = x+1
         print(y)
class B(A):
    def add(self, x):
        super(B, self).add(x)
b = B()
b.add(2)  # 3
```

## str()

`str()` 函数将对象转化为适于人阅读的形式。

```py
>>>s = 'RUNOOB'
>>> str(s)
'RUNOOB'

>>> dict = {'runoob': 'runoob.com', 'google': 'google.com'};
>>> str(dict)
"{'google': 'google.com', 'runoob': 'runoob.com'}"
>>>
```

## repr()

`repr()` 函数将对象转化为供解释器读取的形式。

```py
>>> s = 'RUNOOB'
>>> repr(s)
"'RUNOOB'"

>>> dict = {'runoob': 'runoob.com', 'google': 'google.com'}
>>> repr(dict)
"{'google': 'google.com', 'runoob': 'runoob.com'}"
>>>
```

### repr() 和 str() 主要区别

- 目的不同：
  - `repr()`: 返回一个字符串，这个字符串应该是合法的 Python 表达式，可以用来重新创建对象（如果可能）。它主要用于开发和调试，旨在提供尽可能多的信息。
  - `str()`: 返回一个字符串，这个字符串是适合人类可读的形式，主要用于显示对象。
- 实现方式：
  - `repr()`: 通常由对象的 `__repr__()` 方法实现。
  - `str()`: 通常由对象的 `__str__()` 方法实现。如果对象没有定义 `__str__()` 方法，会使用 `__repr__()` 方法作为替代。

例子：

```py
class MyClass:
    def __repr__(self):
        return "MyClass(param1='value1', param2='value2')"

    def __str__(self):
        return "MyClass with value1 and value2"

obj = MyClass()
print(repr(obj))  # 输出: MyClass(param1='value1', param2='value2')
print(str(obj))   # 输出: MyClass with value1 and value2
```

## any()

语法：`any(iterable)`

`any()` 函数：如果给定的可迭代参数 `iterable` 全部为 False，则返回 False，如果有一个为 True，则返回 True。

元素除了是 0、空、FALSE 外都算 TRUE。

```py
>>>any(['a', 'b', 'c', 'd'])  # 列表list，元素都不为空或0
True
 
>>> any(['a', 'b', '', 'd'])   # 列表list，存在一个为空的元素
True
 
>>> any([0, '', False])        # 列表list,元素全为0,'',false
False
 
>>> any(('a', 'b', 'c', 'd'))  # 元组tuple，元素都不为空或0
True
 
>>> any(('a', 'b', '', 'd'))   # 元组tuple，存在一个为空的元素
True
 
>>> any((0, '', False))        # 元组tuple，元素全为0,'',false
False
  
>>> any([]) # 空列表
False
 
>>> any(()) # 空元组
False
```

### any() + 列表推导式

使用列表推导式将判断的列表转换成 True 或 False 的列表，然后通过 any() 判断有没有 True 值

```py
numbers = [1, 2, 3, 4, 5]
has_greater_than_ten = any(x > 10 for x in numbers)
print(has_greater_than_ten) # output: False
```

## all()

语法：`all(iterable)`

`all()` 函数：如果给定的可迭代参数 iterable 全部为 True，则返回 True，如果有一个为 False，则返回 False。

```py
>>> all(['a', 'b', 'c', 'd'])  # 列表list，元素都不为空或0
True
>>> all(['a', 'b', '', 'd'])   # 列表list，存在一个为空的元素
False
>>> all([0, 1，2, 3])          # 列表list，存在一个为0的元素
False
   
>>> all(('a', 'b', 'c', 'd'))  # 元组tuple，元素都不为空或0
True
>>> all(('a', 'b', '', 'd'))   # 元组tuple，存在一个为空的元素
False
>>> all((0, 1, 2, 3))          # 元组tuple，存在一个为0的元素
False
   
>>> all([])             # 空列表
True
>>> all(())             # 空元组
True
```

## hasattr()

`hasattr()` 函数用于**判断对象**是否包含对应的属性。

> 不是用来判断字典是否包含某个 key 的

语法：`hasattr(object, name)`

参数

- object -- 对象。
- name -- 字符串，属性名。

返回值：如果对象有该属性返回 True，否则返回 False。

```py
class Coordinate:
    x = 10
    y = -5
    z = 0
 
point1 = Coordinate() 
print(hasattr(point1, 'x'))
print(hasattr(point1, 'y'))
print(hasattr(point1, 'z'))
print(hasattr(point1, 'no'))  # 没有该属性

""" 
输出结果：
True
True
True
False
"""
```

## setattr()

语法：`setattr(object, name, value)`

只要对象允许，函数会将值赋给属性。如 `setattr(x, 'foobar', 123)` 等价于 `x.foobar = 123`。

## len()

语法：`len(s)`

- 返回对象的长度（元素个数）。
- 实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。

```py
a = []
print(len(a))
```
