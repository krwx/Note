# 判断类型

- [判断类型](#判断类型)
  - [1. 使用 `type()` 函数](#1-使用-type-函数)
  - [2. 使用 `isinstance()` 函数（推荐）](#2-使用-isinstance-函数推荐)
  - [3. 各种数据类型的判断示例](#3-各种数据类型的判断示例)
  - [4. 特殊类型的判断](#4-特殊类型的判断)
  - [5. 实用的类型检查函数](#5-实用的类型检查函数)
  - [`isinstance(True, int) == True`](#isinstancetrue-int--true)

在Python中，有多种方法可以判断数据类型。以下是常用的几种方式：

## 1. 使用 `type()` 函数

`type()` 不会考虑继承情况

```python
# 基本用法
num = 10
print(type(num))  # <class 'int'>
print(type(num) == int)  # True

text = "Hello"
print(type(text) == str)  # True

lst = [1, 2, 3]
print(type(lst) == list)  # True
```

## 2. 使用 `isinstance()` 函数（推荐）

**优先使用 `isinstance()`** 而不是 `type()`，因为它考虑了继承关系

```python
# 检查单个类型
num = 10
print(isinstance(num, int))  # True

# 检查多个可能的类型
value = 3.14
print(isinstance(value, (int, float)))  # True
```

继承关系例子：

```python
class Animal:
    pass

class Dog(Animal):
    pass

my_dog = Dog()
print(isinstance(my_dog, Dog))     # True
print(isinstance(my_dog, Animal))  # True
print(type(my_dog) == Animal)      # False
```

## 3. 各种数据类型的判断示例

```python
def check_data_type(value):
    if isinstance(value, int):
        return "整数"
    elif isinstance(value, float):
        return "浮点数"
    elif isinstance(value, str):
        return "字符串"
    elif isinstance(value, list):
        return "列表"
    elif isinstance(value, tuple):
        return "元组"
    elif isinstance(value, dict):
        return "字典"
    elif isinstance(value, set):
        return "集合"
    elif isinstance(value, bool):
        return "布尔值"
    elif value is None:
        return "None"
    else:
        return "其他类型"

# 测试
test_values = [
    10, 3.14, "hello", [1, 2, 3], 
    (1, 2), {"a": 1}, {1, 2, 3}, True, None
]

for value in test_values:
    print(f"{value} -> {check_data_type(value)}")
```

## 4. 特殊类型的判断

```python
import collections

def check_special_types(value):
    # 检查是否可迭代
    if isinstance(value, collections.abc.Iterable):
        print("是可迭代对象")
    
    # 检查是否是函数
    if callable(value):
        print("是可调用对象")
    
    # 检查是否是生成器
    if isinstance(value, collections.abc.Generator):
        print("是生成器")

# 检查可调用对象
def my_function():
    pass

check_special_types([1, 2, 3])      # 是可迭代对象
check_special_types(my_function)     # 是可调用对象
check_special_types((x for x in range(3)))  # 是生成器
```

## 5. 实用的类型检查函数

```python
def get_detailed_type_info(value):
    """获取详细的类型信息"""
    type_info = {
        'type': type(value).__name__,
        'is_numeric': isinstance(value, (int, float, complex)),
        'is_sequence': isinstance(value, (list, tuple, str)),
        'is_mapping': isinstance(value, dict),
        'is_iterable': hasattr(value, '__iter__'),
        'is_callable': callable(value),
        'actual_type': type(value)
    }
    return type_info

# 使用示例
print(get_detailed_type_info(42))
print(get_detailed_type_info([1, 2, 3]))
print(get_detailed_type_info(lambda x: x+1))
```

## `isinstance(True, int) == True`

`isinstance(True, int)` 会返回 `True` 是因为在 Python 中， `bool` 类型是 `int` 类型的子类。

```py
print(issubclass(bool, int))  # True，bool是int的子类

# 因此：
print(isinstance(True, bool))  # True
print(isinstance(True, int))   # 也返回True，因为bool继承自int
```

`bool` 也可以参与整数运算：

```py
print(True == 1)    # True
print(False == 0)   # True

print(int(True))    # 1
print(int(False))   # 0

# 在数学运算中
print(True + 1)     # 2
print(False * 5)    # 0
```

如果要精确地判断是否为纯粹的整数类型（不包括布尔值），可以使用以下方法：

```py
def is_pure_int(value):
    return isinstance(value, int) and not isinstance(value, bool)

# 测试
print(is_pure_int(10))     # True
print(is_pure_int(True))   # False
print(is_pure_int(False))  # False
```
