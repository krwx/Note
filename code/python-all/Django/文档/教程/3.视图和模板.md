# 视图和模板

- [视图和模板](#视图和模板)
  - [编写更多视图](#编写更多视图)
  - [写一个真正有用的视图](#写一个真正有用的视图)
    - [render()](#render)
  - [抛出 404 错误](#抛出-404-错误)
    - [get\_object\_or\_404()](#get_object_or_404)
  - [使用模板系统](#使用模板系统)
  - [去除模板中的硬编码 URL](#去除模板中的硬编码-url)
  - [为 URL 名称添加命名空间](#为-url-名称添加命名空间)

概况：

- 在 Django 中，网页和其他内容都是从视图派生而来。
- 每一个视图表现为一个 Python 函数。
- Django 将会根据用户请求的 URL 来选择使用哪个视图。

## 编写更多视图

向 polls/views.py 里添加更多接收参数的视图

```py
# polls/views.py¶
def detail(request, question_id):
    return HttpResponse("You're looking at question %s." % question_id)


def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)


def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)
```

polls.urls 添加 url 配置：

```py
# polls/urls.py
from django.urls import path

from . import views

urlpatterns = [
    # ex: /polls/
    path("", views.index, name="index"),
    # ex: /polls/5/
    path("<int:question_id>/", views.detail, name="detail"),
    # ex: /polls/5/results/
    path("<int:question_id>/results/", views.results, name="results"),
    # ex: /polls/5/vote/
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
```

## 写一个真正有用的视图

Django 要求视图返回的是一个 HttpResponse ，或者抛出一个异常。

直接展示数据：

```py
# polls/views.py
from django.http import HttpResponse

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    output = ", ".join([q.question_text for q in latest_question_list])
    return HttpResponse(output)
```

添加详情模板：

1. 创建 `polls/templates/polls/` 文件夹
2. 在刚创建的文件夹创建 `index.html` 文件

index.html:

```html
<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>My test page</title>
  </head>
  <body>
    {% if latest_question_list %}
        <ul>
        {% for question in latest_question_list %}
            <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
        {% endfor %}
        </ul>
    {% else %}
        <p>No polls are available.</p>
    {% endif %}
  </body>
</html>
```

更新视图，渲染模板:

```py
# polls/views.py
from django.http import HttpResponse
from django.template import loader

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    template = loader.get_template("polls/index.html")
    context = {
        "latest_question_list": latest_question_list,
    }
    return HttpResponse(template.render(context, request))
```

### render()

render() 是快捷函数

```py
from django.shortcuts import render

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    context = {"latest_question_list": latest_question_list}
    return render(request, "polls/index.html", context)
```

## 抛出 404 错误

```py
from django.http import Http404
from django.shortcuts import render

from .models import Question


def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    return render(request, "polls/detail.html", {"question": question})
```

### get_object_or_404()

get_object_or_404() 是快捷函数

```py
from django.shortcuts import get_object_or_404, render

from .models import Question


# ...
def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, "polls/detail.html", {"question": question})
```

## 使用模板系统

polls/detail.html:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>{{ question.question_text }}</h1>
    <ul>
    {% for choice in question.choice_set.all %}
        <li>{{ choice.choice_text }}</li>
    {% endfor %}
    </ul>
</body>
</html>
```

模板系统统一使用点符号来访问变量的属性。在示例 `{{ question.question_text }}` 中，首先 Django 尝试对 question 对象使用字典查找（也就是使用 obj.get(str) 操作），如果失败了就尝试属性查找（也就是 obj.str 操作），结果是成功了。如果这一操作也失败的话，将会尝试列表查找（也就是 obj[int] 操作）。

在 `{% for %}` 循环中发生的函数调用：`question.choice_set.all` 被解释为 Python 代码 `question.choice_set.all()` ，将会返回一个可迭代的 Choice 对象，这一对象可以在 `{% for %}` 标签内部使用。

## 去除模板中的硬编码 URL

还记得吗，我们在 polls/index.html 里编写投票链接时，链接是硬编码的：

```html
<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
```

在 `polls.urls` 模块中的 `path()` 函数中定义了 `name` 参数，你可以通过使用 `{% url %}` 模板标签来消除对 `url` 配置中定义的特定 `URL` 路径的依赖：

```html
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
```

如果你想改变投票详情视图的 URL，比如想改成 `polls/specifics/12/` ，你不用在模板里修改任何东西（包括其它模板），只要在 `polls/urls.py` 里稍微修改一下就行：

```py
# before
path("<int:question_id>/", views.detail, name="detail"),

# after, added the word 'specifics'
path("specifics/<int:question_id>/", views.detail, name="detail"),
```

## 为 URL 名称添加命名空间

在一个真实的 Django 项目中，可能会有五个，十个，二十个，甚至更多应用。Django 如何分辨重名的 URL 呢？

答案是：在根 `URLconf` 中添加命名空间。在 `polls/urls.py` 文件中稍作修改，加上 `app_name` 设置命名空间：

```py
# polls/urls.py
from django.urls import path

from . import views

app_name = "polls"
urlpatterns = [
    path("", views.index, name="index"),
    path("<int:question_id>/", views.detail, name="detail"),
    path("<int:question_id>/results/", views.results, name="results"),
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
```

现在，编辑 `polls/index.html` 文件，修改为指向具有命名空间的详细视图：

```html
<!-- polls/templates/polls/index.html -->
<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>
```
