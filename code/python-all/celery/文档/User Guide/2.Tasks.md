# Tasks

- [Tasks](#tasks)
  - [调用任务](#调用任务)
    - [在任务中调用其他任务](#在任务中调用其他任务)
    - [执行完任务后再确认消息](#执行完任务后再确认消息)
  - [重试任务](#重试任务)

## 调用任务

### 在任务中调用其他任务

在任何任务函数中，导入其他任务并调用其异步方法（如 delay()）：

```py
# proj/tasks.py
from .celery_app import app
from .other_tasks import multiply, calc  # 导入其他任务

@app.task
def add(x, y):
    return x + y


@app.task
def add_and_multiply(x, y, z):
    # 调用当前文件的 add 任务
    add_result = add.delay(x, y).get()  # 同步等待结果（慎用，会阻塞！）

    # 调用其他文件的 calc 任务
    calc.delay() # 这样不会同步等待结果
    
    # 调用其他文件的 multiply 任务
    multiply_result = multiply.delay(add_result, z)
    return multiply_result.get()
```

调用任务时，不调用 `get()` 的话是异步执行的，调用了是同步执行

### 执行完任务后再确认消息

在 Celery 中，**默认**行为是消费者接收到任务后**立即确认（ACK）消息**，导致消息从队列中移除。若希望任务执行完成后再确认消息，需通过 `acks_late=True` 参数控制：

```py
@app.task(acks_late=True)
def my_task():
    # 任务逻辑
```

`acks_late=True` 的意思：

- 消息保留：任务执行期间消息保留在队列中，直到任务成功完成才发送 ACK，移除消息。
- 失败处理：若任务执行中崩溃或抛出异常，消息不会被确认，可能重新入队（需配合重试策略）。

## 重试任务

task 要设置 `bind=True`，然后 task 的第一个参数为 self，调用 `self.retry()` 来重试任务

```py
@celery_app.task(bind=True)
def my_task(self, task_record_id, if_clear_cache):
    try:
        # ....
    except Exception as exc:
        self.retry(exc=exc, max_retries=2, countdown=30)
```

参数：

- exc：错误，异常
- max_retries：重试次数
- countdown：间隔多少秒后重试，单位为秒

> 在 `@task()` 配置的重试参数会被手动调用的 `retry()` 的参数覆盖

当任务的重试次数超过设定的最大重试次数（`max_retries`）时，任务的状态转为 `FAILURE`。如果未显式处理失败逻辑，异常会传递到 Celery Worker，并输出错误日志（如 Task handler raised error）。

使用 `on_failure` 回调自定义处理异常

```py
@app.task(bind=True, max_retries=3, on_failure=handle_failure)
def my_task(self, arg1):
    try:
        # 任务逻辑
    except Exception as e:
        self.retry(exc=e)

def handle_failure(self, task_id, args, kwargs, einfo):
    # 自定义处理逻辑，如记录到数据库、发送邮件等
    logging.error(f"Task {task_id} 失败: {einfo}")
```
