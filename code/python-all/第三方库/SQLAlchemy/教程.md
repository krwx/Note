# 教程

参考：SQLAlchemy Unified Tutorial

只包含了 ORM 的使用，其他使用未包含

- [教程](#教程)
  - [概述](#概述)
  - [安装](#安装)
  - [Establishing Connectivity - the Engine](#establishing-connectivity---the-engine)
  - [Working with Transactions and the DBAPI（直接用 sql 语句）](#working-with-transactions-and-the-dbapi直接用-sql-语句)
    - [创建连接](#创建连接)
    - [提交修改](#提交修改)
    - [处理结果](#处理结果)
    - [传递参数](#传递参数)
    - [DML 语句传递多个参数](#dml-语句传递多个参数)
    - [使用 ORM 会话执行 sql 语句](#使用-orm-会话执行-sql-语句)
  - [Working with Database Metadata](#working-with-database-metadata)
    - [使用 MetaData object 创建表（少用，不用管）](#使用-metadata-object-创建表少用不用管)
    - [使用 ORM 创建表（重点）](#使用-orm-创建表重点)
  - [Working with Data（ORM）](#working-with-dataorm)
    - [使用 INSERT 语句](#使用-insert-语句)
      - [构造 `INSERT` 语句](#构造-insert-语句)
      - [执行 `INSERT` 语句](#执行-insert-语句)
      - [不使用 `insert.values()` ，使用 `insert()` 插入](#不使用-insertvalues-使用-insert-插入)
      - [INSERT...RETURNING](#insertreturning)
      - [INSERT...FROM SELECT](#insertfrom-select)
    - [使用 SELECT 语句](#使用-select-语句)
      - [构造 select 语句](#构造-select-语句)
      - [设置返回的 COLUMNS 和 FROM 子句](#设置返回的-columns-和-from-子句)
      - [WHERE 子句](#where-子句)
      - [JOIN 子句](#join-子句)
        - [手动设置 ON 子句](#手动设置-on-子句)
        - [outer join 和 full join](#outer-join-和-full-join)
      - [ORDER BY, GROUP BY, HAVING 子句](#order-by-group-by-having-子句)
        - [ORDER BY 子句](#order-by-子句)
        - [GROUP BY, HAVING 子句](#group-by-having-子句)
      - [给表设置别名(aliases)](#给表设置别名aliases)
      - [子查询和 CTE](#子查询和-cte)
      - [Scalar and Correlated Subqueries](#scalar-and-correlated-subqueries)
      - [UNION, UNION ALL 和其他 set(集合) 操作](#union-union-all-和其他-set集合-操作)
      - [EXISTS 运算符](#exists-运算符)
      - [使用 SQL 方法](#使用-sql-方法)
    - [使用 UPDATE 和 DELETE 语句](#使用-update-和-delete-语句)
      - [UPDATE 语句](#update-语句)
        - [使用其他表的数据 UPDATE](#使用其他表的数据-update)
        - [UPDATE...FROM](#updatefrom)
        - [MySQL 支持的特性](#mysql-支持的特性)
      - [DELETE 语句](#delete-语句)
        - [MySQL 删除多个表](#mysql-删除多个表)
      - [获取 UPDATE, DELETE 语句影响的行数](#获取-update-delete-语句影响的行数)
      - [Using RETURNING with UPDATE, DELETE](#using-returning-with-update-delete)
  - [other](#other)
    - [session.add() 、session.flush()](#sessionadd-sessionflush)
    - [使用未知值 insert 或 update](#使用未知值-insert-或-update)

## 概述

`SQLAlchemy` 是 `ORM` 框架

`SQLAlchemy` 由两个 API 组成：`SQLAlchemy Core`、`SQLAlchemy ORM`

- SQLAlchemy Core
  - `SQLAlchemyCore` 是 `SQLAlchemy` 作为“数据库工具包”的基础架构。该库提供了用于管理数据库连接、与数据库查询和结果交互以及SQL语句编程构造的工具。
- SQLAlchemy ORM
  - `SQLAlchemy ORM` 基于 `Core` 构建，提供可选的对象关系映射功能。
  - `ORM` 提供了一个额外的配置层，允许用户定义的 `Python` 类映射到数据库表和其他构造，以及一个称为 `Session` 的对象持久化机制。
  - 然后，它扩展了核心级SQL表达式语言，允许根据用户定义的对象组合和调用SQL查询。

## 安装

命令行：`pip install SQLAlchemy`

conda：`conda install sqlalchemy`。记得切换环境

测试安装成功：

```py
import sqlalchemy

if __name__ == "__main__":
    print(sqlalchemy.__version__) # 输出：2.0.30
```

## Establishing Connectivity - the Engine

创建引擎--用于连接数据库

使用 `create_engine()` 创建 engine，engine 用于连接数据库

> **lazy connecting**
>
> 当 `create_Engine()` 首次返回引擎时，它实际上还没有尝试连接到数据库；这仅在它第一次被要求对数据库执行任务时发生。  
> 这是一种被称为延迟初始化的软件设计模式。

```py
from sqlalchemy import create_engine

engine = create_engine(f'mysql+pymysql://{mysql["username"]}:{mysql["password"]}@{mysql["server"]}/{mysql["database"]}',
                       echo=False, future=True, pool_size=10, max_overflow=5)

engine = create_engine(f'mysql+pymysql://root:1234@localhost:3306/datatest',
                       echo=False, future=True, pool_size=10, max_overflow=5)
```

`DBAPI` 解释：

- `Python DBAPI` 是 `SQLAlchemy` 用来与特定数据库交互的第三方驱动程序。
- 在上面的例子，我们使用 `pymysql` 这个名称。
- 如果省略， `SQLAlchemy` 将为所选的特定数据库使用默认 `DBAPI` 。
- **注意：`DBAPI` 要提前下载的。即在上面的例子中，需要在 `conda` 下载 `pymysql` 这个包**

## Working with Transactions and the DBAPI（直接用 sql 语句）

事务与 `DBAPI`

这里介绍怎么执行 `sql` 语句

### 创建连接

当直接使用 `Core` 时，不使用 `ORM` 时， `Connection` 对象是与数据库进行所有交互的方式。

因为 `Connection` 针对数据库创建了一个开放资源，所以我们希望将此对象的使用限制在特定的上下文中。最好的方法是使用 Python 上下文管理器，也称为 `with` 语句。

- 使用 `engine.connect()` 创建连接
- 使用 `conn.execute()` 执行 sql 语句
- 文本 `SQL` 是用一个名为 `text()` 的构造创建的

使用一个文本 `SQL` 语句来显示 `“Hello World”`：

```py
def test_sql():
    engine = create_engine('mysql+pymysql://root:1234@localhost:3306/datatest',
                       echo=False, future=True, pool_size=10, max_overflow=5)
    with engine.connect() as conn:
        result = conn.execute(text("select 'hello world'"))
        print(result.all())
```

注意：

- `Python DBAPI` 的默认行为是事务始终在进行中；当连接被释放时，会发出 `ROLLBACK` 以结束事务。
- 事务不会自动提交；如果我们想**提交数据（插入或更新数据）**，我们需要调用 `Connection.commit()`

### 提交修改

使用 `Connection.commit()` 方法提交事务：

```py
def test_sql():
    engine = create_engine('mysql+pymysql://root:1234@localhost:3306/datatest',
                       echo=False, future=True, pool_size=10, max_overflow=5)
    with engine.connect() as conn:
        conn.execute(text("CREATE TABLE some_table (x int, y int)"))
        conn.execute(
            text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
            [{"x": 1, "y": 1}, {"x": 2, "y": 4}],
        )
        conn.commit()
```

或者使用 `engine.begin()` ，它会在结束事务时 提交修改 或者 抛出异常如果报错的话：

```py
def test_sql():
    engine = create_engine('mysql+pymysql://root:1234@localhost:3306/datatest',
                       echo=False, future=True, pool_size=10, max_overflow=5)
    with engine.begin() as conn:
        conn.execute(text("CREATE TABLE some_table (x int, y int)"))
        conn.execute(
            text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
            [{"x": 1, "y": 1}, {"x": 2, "y": 4}],
        )
```

### 处理结果

执行 SELECT 语句会返回 Result 对象。该对象有内置函数，也可以对它进行遍历。

```py
def test_sql():
    engine = create_engine('mysql+pymysql://root:1234@localhost:3306/datatest',
                       echo=False, future=True, pool_size=10, max_overflow=5)
    with engine.connect() as conn:
        result = conn.execute(text("SELECT x, y FROM some_table"))
        for row in result:
            print(f"x: {row.x}  y: {row.y}")
""" 
结果：
x: 1  y: 1
x: 2  y: 4
"""
```

遍历：

1、元组赋值：在收到变量时按位置为每一行赋值

```py
result = conn.execute(text("select x, y from some_table"))

for x, y in result:
    ...
```

2、通过索引访问

```py
result = conn.execute(text("select x, y from some_table"))

for row in result:
    x = row[0]
```

3、通过属性名称访问

```py
result = conn.execute(text("select x, y from some_table"))

for row in result:
    y = row.y

    # illustrate use with Python f-strings
    print(f"Row: {row.x} {y}")
```

4、通过映射访问

```py
result = conn.execute(text("select x, y from some_table"))

for dict_row in result.mappings():
    x = dict_row["x"]
    y = dict_row["y"]
```

### 传递参数

将要传递给 sql 语句的参数传递给 `conn.execute()` 的第二个参数：

```py
def test_sql():
    engine = create_engine('mysql+pymysql://root:1234@localhost:3306/datatest',
                       echo=False, future=True, pool_size=10, max_overflow=5)
    with engine.connect() as conn:
        result = conn.execute(text("SELECT x, y FROM some_table WHERE y > :num"), {"num": 2})
        for row in result:
            print(f"x: {row.x}  y: {row.y}")
```

多个查询参数：

```py
result = conn.execute(text("SELECT x, y FROM some_table WHERE y > :num And y < :num2"), {"num": 2, "num2": 5})
```

### DML 语句传递多个参数

DML 语句：UPDATE, INSERT 语句

通过传递列表给 `conn.execute()` 的第二个参数实现

```py
def test_sql():
    engine = create_engine('mysql+pymysql://root:1234@localhost:3306/datatest',
                       echo=False, future=True, pool_size=10, max_overflow=5)
    with engine.begin() as conn:
        conn.execute(text("CREATE TABLE some_table (x int, y int)"))
        conn.execute(
            text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
            [{"x": 1, "y": 1}, {"x": 2, "y": 4}],
        )
```

### 使用 ORM 会话执行 sql 语句

使用 `ORM` 时，基本的事务/数据库交互对象称为 `Session`。

在 `SQLAlchemy` 中，当使用 `Session` 时，它在内部引用一个 `Connection` ，用于发出 `SQL` 。

当 `Session` 与非 `ORM` 构造一起使用时，与 `Connection` 直接执行的方式没有太大区别

```py
from sqlalchemy.orm import Session
def test_sql():
    engine = create_engine(
        "mysql+pymysql://root:1234@localhost:3306/datatest",
        echo=False,
        future=True,
        pool_size=10,
        max_overflow=5,
    )
    stmt = text("SELECT x, y FROM some_table WHERE y > :y ORDER BY x, y")
    with Session(engine) as session:
        result = session.execute(stmt, {"y": 0})
        for row in result:
            print(f"x: {row.x}  y: {row.y}")
```

当更新或插入数据时，也要在后面调用 `session.commit()` 才会提交修改

`Session` 在结束事务后实际上并没有保留 `Connection` 对象。下次需要对数据库执行 SQL 时，它会从引擎获取一个新的连接。

## Working with Database Metadata

METADATA 指的是：表示表和列等数据库概念的 `Python` 对象。这些对象统称为数据库元数据。

METADATA = 元数据

### 使用 MetaData object 创建表（少用，不用管）

表用 Table 对象表示，列用 Column 对象表示

1. 调用 `MetaData()` 创建 `MetaData object`
2. 调用 `Table()` 创建表
   1. 第一个参数为表名
   2. 第二个参数为 `MetaData object`
   3. 后面的参数为列对象
      1. 通过 `primary_key=True` 指定主键
      2. 通过 `ForeignKey("[表名].[列名]")` 指定外键
      3. 通过 `nullable=False` 设置不为空的约束
3. 调用 `MetaData object` 的 `create_all(engine)` 创建表

```py
from sqlalchemy import (
    create_engine,
    text,
    MetaData,
    Table,
    Column,
    Integer,
    String,
    ForeignKey,
)

def test_sql():
    engine = create_engine(
        "mysql+pymysql://root:1234@localhost:3306/datatest",
        echo=False,
        future=True,
        pool_size=10,
        max_overflow=5,
    )

    metadata_obj = MetaData()
    user_table = Table(
        "user_account",
        metadata_obj,
        Column("id", Integer, primary_key=True),
        Column("name", String(30)),
        Column("fullname", String(30)),
    )

    address_table = Table(
        "address",
        metadata_obj,
        Column("id", Integer, primary_key=True),
        Column("user_id", ForeignKey("user_account.id"), nullable=False),
        Column("email_address", String(30), nullable=False),
    )

    metadata_obj.create_all(engine)
```

### 使用 ORM 创建表（重点）

1、声明 `DeclarativeBase`

```py
from sqlalchemy.orm import DeclarativeBase
class Base(DeclarativeBase):
    pass
```

2、创建表的映射类

- 映射类要继承基类
  - `class User(Base)`
- 使用 `Mapped` 类表示列的数据类型
  - 只声明类型：`Mapped[int]`
  - 添加约束或者对数据有要求，使用 `mapped_column()` 实现
    - 格式：`[列名]: Mapped[数据类型] = mapped_column()`
    - 主键：`mapped_column(primary_key=True)`
    - 字符长度：`mapped_column(String(30))`
  - 是否为空通过判断是否有 `Optional` 关键字实现
    - 有代表可为空，没有代表不能为空。
    - `Mapped[Optional[str]]` 可为空
  - 定义外键：`mapped_column(ForeignKey("user_account.id"))`
- 映射类如果没有定义 `__init__()` 或 `__repr__()` 等方法会自动调用基类的方法

```py
from typing import List
from typing import Optional
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.orm import relationship

class User(Base):
    __tablename__ = "user_account"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))
    fullname: Mapped[Optional[str]]
    addresses: Mapped[List["Address"]] = relationship(back_populates="user")
    def __repr__(self) -> str:
        return f"User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})"

class Address(Base):
    __tablename__ = "address"
    id: Mapped[int] = mapped_column(primary_key=True)
    email_address: Mapped[str]
    user_id = mapped_column(ForeignKey("user_account.id"))
    user: Mapped[User] = relationship(back_populates="addresses")
    def __repr__(self) -> str:
        return f"Address(id={self.id!r}, email_address={self.email_address!r})"
```

3、如果声明的映射类对应的表没有创建，使用 `create_all()` 创建。如果已经创建则不用管

```py
Base.metadata.create_all(engine)
```

4、完整代码

```py
from typing import List
from typing import Optional
from sqlalchemy import (
    create_engine,
    String,
    ForeignKey,
)
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.orm import relationship


class Base(DeclarativeBase):
    pass


class User(Base):
    __tablename__ = "user_account"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))
    fullname: Mapped[Optional[str]] = mapped_column(String(30))
    addresses: Mapped[List["Address"]] = relationship(back_populates="user")

    def __repr__(self) -> str:
        return f"User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})"


class Address(Base):
    __tablename__ = "address"
    id: Mapped[int] = mapped_column(primary_key=True)
    email_address: Mapped[str] = mapped_column(String(30))
    user_id = mapped_column(ForeignKey("user_account.id"))
    user: Mapped[User] = relationship(back_populates="addresses")

    def __repr__(self) -> str:
        return f"Address(id={self.id!r}, email_address={self.email_address!r})"


def test_sql():
    engine = create_engine(
        "mysql+pymysql://root:1234@localhost:3306/datatest",
        echo=False,
        future=True,
        pool_size=10,
        max_overflow=5,
    )

    Base.metadata.create_all(engine)
```

## Working with Data（ORM）

### 使用 INSERT 语句

#### 构造 `INSERT` 语句

导入 insert 。语法：`insert(ORM class).values(...)`

```py
from sqlalchemy import insert

# User 为 ORM 映射类
def test_sql():
    stmt = insert(User).values(name="spong", fullname="spong square")
    # 打印 sql 语句
    print(stmt)
    # 打印 sql 语句的参数
    print(stmt.compile().params)

""" 
结果：
INSERT INTO user_account (name, fullname) VALUES (:name, :fullname)
{'name': 'spong', 'fullname': 'spong square'}
"""
```

#### 执行 `INSERT` 语句

使用 `conn.excute()` 执行，然后调用 `conn.commit()` 执行。（使用 session 也可以）

当插入当行数据时返回的 Result 为 `CursorResult` 类，可以通过 `CursorResult.inserted_primary_key` 属性访问到新插入的数据的主键。主键的数据类型为 `tuple` ，因为主键是可以多个键组成的。

```py
def test_sql():
    engine = create_engine(
        "mysql+pymysql://root:1234@localhost:3306/datatest",
        echo=False,
        future=True,
        pool_size=10,
        max_overflow=5,
    )

    stmt = insert(User).values(name="spong", fullname="spong square")
    with engine.connect() as conn:
        result = conn.execute(stmt)
        conn.commit()
        print(result.inserted_primary_key) # output: (1,)
```

#### 不使用 `insert.values()` ，使用 `insert()` 插入

打印 `insert()` 会发现 `insert()` 默认指明所有列都插入

```py
print(insert(user_table)) 
# output: INSERT INTO user_account (id, name, fullname) VALUES (:id, :name, :fullname)
```

将要插入的数据（数据类型为 列表）作为 `conn.excute()` 的第二个参数

```py
def test_sql():
    engine = create_engine(
        "mysql+pymysql://root:1234@localhost:3306/datatest",
        echo=False,
        future=True,
        pool_size=10,
        max_overflow=5,
    )

    with engine.connect() as conn:
        result = conn.execute(
            insert(User),
            [
                {"name": "sandy", "fullname": "Sandy Cheeks"},
                {"name": "patrick", "fullname": "Patrick Star"},
            ],
        )
        conn.commit()
```

#### INSERT...RETURNING

TODO：再看

#### INSERT...FROM SELECT

TODO：再看

### 使用 SELECT 语句

#### 构造 select 语句

导入 select。执行的结果可以通过 for 循环进行遍历，来获取返回的数据

```py
from sqlalchemy import create_engine, select,
def test_sql():
    stmt = select(User).where(User.name == "spong")
    with engine.connect() as conn:
        for row in conn.execute(stmt):
            print(row)
""" 
结果：
(1, 'spong', 'spong square')
(2, 'spong', 'spong square')
"""
```

使用 `ORM` 的 `Session`：

```py
from sqlalchemy.orm import Session
def test_sql():
    stmt = select(User).where(User.name == "spong")
    with Session(engine) as session:
        for row in session.execute(stmt):
            print(row)
""" 
结果：
(User(id=1, name='spong', fullname='spong square'),)
(User(id=2, name='spong', fullname='spong square'),)
"""
```

#### 设置返回的 COLUMNS 和 FROM 子句

只使用 select() 会返回所有的列：

```py
print(select(User))
""" 
结果：
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
"""
```

返回的结果是一个可迭代对象，可以遍历它。遍历的值表示每一行数据，数据为长度为 1 的元组，元组的第一个元素才是数据：

```py
def test_sql():
    stmt = select(User)
    with Session(engine) as session:
        for row in session.execute(stmt):
            print(row)
""" 
结果：
(User(id=1, name='spong', fullname='spong square'),)
(User(id=2, name='spong', fullname='spong square'),)
"""

row = session.execute(select(User)).first()
print(row[0])
# User(id=1, name='spongebob', fullname='Spongebob Squarepants')
```

但是强烈建议使用 `Session.scalars()` 方法直接执行语句，以获得与上述相同的结果；此方法将返回一个 `ScalarResult` 对象，该对象一次传递每行的第一个“列”，在本例中为 `User` 类的实例：

```py
def test_sql():
    stmt = select(User)
    with Session(engine) as session:
        for row in session.scalars(stmt):
            print(row)
""" 
结果：
User(id=1, name='spong', fullname='spong square')
User(id=2, name='spong', fullname='spong square')
"""
```

取返回的结果的第一项，通过 `.first()` ：

```py
def test_sql():
    stmt = select(User)
    with Session(engine) as session:
        user = session.scalars(stmt).first()
        print(user)
""" 
结果：
User(id=1, name='spong', fullname='spong square')
"""
```

`session.execute()` 和 `session.scalars()` 的区别：

- 遍历 `session.execute()` 的结果，每一项为长度为 1 的元组，元组的第一个元素为 ORM 对象实例
- 遍历 `session.scalars()` 的结果，每一项为 ORM 对象实例

查询指定列，通过传递列的属性：

```py
print(select(User.name, User.fullname))

# SELECT user_account.name, user_account.fullname
# FROM user_account
```

注意：要使用 `excute()` 才会返回完整的数据，**不能使用 `scalars()`**

```py
def test_sql():
    stmt = select(User.name, User.fullname)
    with Session(engine) as session:
        for row in session.execute(stmt):
            print(row)
""" 
结果：
('spong', 'spong square')
('sandy', 'Sandy Cheeks')
('patrick', 'Patrick Star')
"""
```

可以查询多个表。以下例子，查询 User 表的 name 字段和 Address 表的所有字段

```py
def test_select():
    stmt = select(User.name, Address).where(User.id == Address.user_id)
    with Session(engine) as session:
        # 使用 all() 获取所有的数据
        result = session.execute(stmt).all()
        print(result)
```

#### WHERE 子句

简单使用：

```py
print(select(User).where(User.name == "squidward"))
""" 
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
WHERE user_account.name = :name_1
"""
```

`WHERE` 包含多种查询条件有两种做法：

1、调用多次 `where()`

```py
print(
    select(Address.email_address)
    .where(User.name == "spong")
    .where(Address.user_id == User.id)
)
""" 
SELECT address.email_address
FROM address, user_account
WHERE user_account.name = :name_1 AND address.user_id = user_account.id
"""
```

2、调用一次 `where()`，参数传多个判断条件

```py
print(
    select(Address.email_address)
    .where(User.name == "spong", Address.user_id == User.id)
)
```

和 `AND`, `OR` 一起使用。使用 `and_()` 和 `or_()` 实现：

```py
stmt = select(Address.email_address).where(
    and_(
        or_(User.name == "squidward", User.name == "spong"),
        Address.user_id == User.id,
    )
)
""" 
SELECT address.email_address
FROM address, user_account
WHERE (user_account.name = :name_1 OR user_account.name = :name_2)
AND address.user_id = user_account.id
"""
```

对于简单的 select ORM 对象实体，可以使用 `Select.filter_by()` 直接对指定列过滤指定值，作用的对象为最左侧的 `FROM` 子句或最后加入的实体：

```py
stmt = select(User).filter_by(name="spongebob", fullname="Spongebob Squarepants")

""" 
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
WHERE user_account.name = :name_1 AND user_account.fullname = :fullname_1
"""
```

#### JOIN 子句

sql 语句的语法：

```txt
SELECT column1, column2, ...
FROM table1
JOIN table2 ON condition;
```

两种方法使用 JOIN（默认使用 INNER JOIN）（**两种方法都是自动生成 ON 子句**）

1、使用 `Select.join_from(TableA, TableB)` 函数

该函数能指明 JOIN 的左侧和右侧

> 注意：`join_from()` 没有指明连接的 condition，它是通过两个表之间是否有外键连接推断 condition 的。  
> 下面的例子，address 的 user_id 有外键连接到 User 的 id，所有 condition 为这两个字段相等

```py
print(select(User.name, Address.email_address).join_from(User, Address))

""" 
SELECT user_account.name, address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
"""
```

2、使用 `Select.join(TableA)` 函数

该函数只能指明 JOIN 的右侧，左侧通过推理得到

```py
print(select(User.name, Address.email_address).join(Address))
# 结果和上面一样
```

推断 JOIN 的两侧实体和 JOIN 的条件是通过 `select()` 里面的字段推断的，但是有时候推断不出来（例如 `select()` 只查询其中一个表的字段，那么就不知道另一个表是什么），那么这时候要用到 `Select.select_from` .

```py
print(select(Address.email_address).join_from(User, Address))

print(select(Address.email_address).select_from(User).join(Address))

""" 
两个的结果都一样

SELECT address.email_address 
FROM user_account JOIN address ON user_account.id = address.user_id
"""
```

另一个使用 `Select.select_from` 的情况是 select() 推断不了查询的表，例子：

```py
from sqlalchemy import func
print(select(func.count("*")).select_from(User))

""" 
SELECT count(:count_2) AS count_1
FROM user_account
"""
```

##### 手动设置 ON 子句

有时候如果连接的两个表之间没有约束（例如外键）或者表之间有很多约束，那么就需要特别地指定 ON 子句

`Select.join()` 和 `Select.join_from()` 都接受 `onclause` 参数，用来指定 ON 子句

函数定义：

```py
(method) def join_from(
    from_: _FromClauseArgument,
    target: _JoinTargetArgument,
    onclause: _OnClauseArgument | None = None,
    *,
    isouter: bool = False,
    full: bool = False
) -> Select[Tuple[str]]

(method) def join(
    target: _JoinTargetArgument,
    onclause: _OnClauseArgument | None = None,
    *,
    isouter: bool = False,
    full: bool = False
) -> Select[Tuple[str]]
```

例子：

```py
print(select(Address.email_address).join_from(User, Address, User.id == Address.user_id))

print(select(Address.email_address).select_from(User).join(Address, User.id == Address.user_id))

""" 
两个的结果都一样

SELECT address.email_address 
FROM user_account JOIN address ON user_account.id = address.user_id
"""
```

##### outer join 和 full join

`Select.join()` 和 `Select.join_from()` 方法都接受关键字参数`Select.job.isouter` 和 `Select.job.full`，两个参数分别用于设置 `LEFT OUTER JOIN` 和 `FULL OUTER JOIN`

```py
print(select(user_table).join(address_table, isouter=True))
""" 
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account LEFT OUTER JOIN address ON user_account.id = address.user_id 
"""

print(select(user_table).join(address_table, full=True))
""" 
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account FULL OUTER JOIN address ON user_account.id = address.user_id 
"""
```

可以使用 `Select.outerjoin()` 代替 `.join(..., isouter=True)`

> 注意：SQL Alchemy 没有实现 `RIGHT OUTER JOIN`，如果要实现的话可以通过调换 `join_from()` 中两个表的位置实现.  
> 即 `join_from(TableA, TableB, isouter=True)` 变成 `join_from(TableB, TableA, isouter=True)`

#### ORDER BY, GROUP BY, HAVING 子句

##### ORDER BY 子句

使用 `Select.order_by()`

```py
print(select(User).order_by(User.fullname))

""" 
SELECT user_account.id, user_account.name, user_account.fullname 
FROM user_account ORDER BY user_account.fullname
"""
```

通过 `ColumnElement.asc()`(升序) 和 `ColumnElement.desc()`(降序) 可以指定排序的顺序

```py
print(select(User).order_by(User.fullname.asc()))
print(select(User).order_by(User.fullname.desc()))

""" 
SELECT user_account.id, user_account.name, user_account.fullname 
FROM user_account ORDER BY user_account.fullname ASC

SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account ORDER BY user_account.fullname DESC
"""
```

##### GROUP BY, HAVING 子句

使用统计函数可以从 sqlalchemy 导入 func ，然后使用 func 内置的函数

HAVING 通常与 GROUP BY 一起使用，用于筛选符合条件的 group

使用 `Select.group_by()` and `Select.having()`

```py
from sqlalchemy import func

with engine.connect() as conn:
    result = conn.execute(
        select(User.name, func.count(Address.id).label("count")) # 使用 label() 来命名字段
        .join(Address)
        .group_by(User.name)
        .having(func.count(Address.id) > 1)
    )
    print(result.all())
""" 
sql 语句：

SELECT user_account.name, count(address.id) AS count
FROM user_account JOIN address ON user_account.id = address.user_id GROUP BY user_account.name
HAVING count(address.id) > ?
"""
```

> order_by 和 group_by 可以直接传递字符串，例如 `.group_by(Address.user_id)` 可以写成 `.group_by("user_id")`

#### 给表设置别名(aliases)

使用：从 `sqlalchemy.orm` 导入 `aliased()` ，然后调用 `aliased()` 获取别名对象，**别名对象的名字就是变量的名字**

```py
from sqlalchemy.orm import aliased

address_1 = aliased(Address)
address_2 = aliased(Address)

print(
    select(User)
    .join_from(User, address_1)
    .where(address_1.email_address == "patrick@aol.com")
    .join_from(User, address_2)
    .where(address_2.email_address == "patrick@gmail.com")
)

""" 
SELECT user_account.id, user_account.name, user_account.fullname 
FROM user_account JOIN address AS address_1 ON user_account.id = address_1.user_id JOIN address AS address_2 ON user_account.id = address_2.user_id
WHERE address_1.email_address = :email_address_1 AND address_2.email_address = :email_address_2
"""
```

#### 子查询和 CTE

TODO：再看

#### Scalar and Correlated Subqueries

TODO：再看

#### UNION, UNION ALL 和其他 set(集合) 操作

`union_all()` 等函数返回的数据的类型为 `CompoundSelect`

使用 `union_all()` 的例子：

```py
from sqlalchemy import union_all

stmt1 = select(User).where(User.name == "sandy")
stmt2 = select(User).where(User.name == "spongebob")
u = union_all(stmt1, stmt2)
print(u)

with engine.connect() as conn:
    result = conn.execute(u) # 可以直接执行
    print(result.all())

""" 
SELECT user_account.id, user_account.name, user_account.fullname 
FROM user_account
WHERE user_account.name = :name_1 UNION ALL SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
WHERE user_account.name = :name_2
"""
```

使用 UNION 后还想对这个结果用简单的 Select 语句，可以用 `Select.from_statement()` 连接

```py
stmt1 = select(User).where(User.name == "sandy")
stmt2 = select(User).where(User.name == "spongebob")
u = union_all(stmt1, stmt2)

orm_stmt = select(User.name).from_statement(u)
print(orm_stmt)

""" 
SELECT user_account.name
FROM user_account
WHERE user_account.name = :name_1 UNION ALL SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
WHERE user_account.name = :name_2
"""
```

如果需要 UNION 的结果作为子查询来实现更复杂的操作，可以将 UNION 的结果设置别名：

1. 调用 `CompoundSelect.subquery()` 获取结果的子查询
2. 调用 `aliased(User, subquery)` 设置别名。
   1. aliased() 接收第二个参数，第二个参数为子查询，用于将子查询与某个表格挂钩上，然后设置别名

```py
user_alias = aliased(User, u.subquery())
orm_stmt = select(user_alias).order_by(user_alias.id)
print(orm_stmt)

""" 
SELECT anon_1.id, anon_1.name, anon_1.fullname 
FROM (SELECT user_account.id AS id, user_account.name AS name, user_account.fullname AS fullname 
FROM user_account 
WHERE user_account.name = :name_1 UNION ALL SELECT user_account.id AS id, user_account.name AS name, user_account.fullname AS fullname 
FROM user_account 
WHERE user_account.name = :name_2) AS anon_1 ORDER BY anon_1.id
 """
```

#### EXISTS 运算符

EXISTS 运算符用于判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False。

语法：

```sql
SELECT column_name(s) -- column_name(s) 代表一个列或多个列
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
```

调用 `ScalarSelect` 对象的 `Exists()` 方法构建一个子查询，然后将子查询放到 `where()` 里面

```py
subq = (
    select(func.count(Address.id))
    .where(User.id == Address.user_id)
    .group_by(Address.user_id)
    .having(func.count(Address.id) > 1)
).exists()
stmt = select(User.name).where(subq)
print(stmt)

""" 
SELECT user_account.name 
FROM user_account
WHERE EXISTS (SELECT count(address.id) AS count_1
FROM address
WHERE user_account.id = address.user_id GROUP BY address.user_id
HAVING count(address.id) > :count_2)
"""
```

通过在 `where()` 里面添加 `~` 来使用 `NOT EXISTS`

```py
stmt = select(User.name).where(~subq)

""" 
SELECT user_account.name 
FROM user_account
WHERE NOT (EXISTS (SELECT count(address.id) AS count_1
FROM address
WHERE user_account.id = address.user_id GROUP BY address.user_id
HAVING count(address.id) > :count_2))
"""
```

#### 使用 SQL 方法

TODO：再看

### 使用 UPDATE 和 DELETE 语句

#### UPDATE 语句

使用 `update()` 指定 update 的表，使用 `values()` 指定更新的值

```py
from sqlalchemy import update

stmt = update(User).where(User.name == "partick").values(fullname="Patrick the star")
print(stmt)

""" 
UPDATE user_account SET fullname=:fullname WHERE user_account.name = :name_1
"""
```

更新的值可以使用表达式。表达式中可以用 column 字段，即可以用其他 column 的数据组装数据

```py
stmt = update(User).values(fullname="Username: " + User.name)
print(stmt)

""" 
UPDATE user_account SET fullname=(:name_1 || user_account.name)
"""
```

在 `excute()` 可以进行批量更新。构造 statement 时使用 `bindparam()` 绑定参数。传递给 `excute()` 的数据的格式为包含 dict 的 list

```py
from sqlalchemy import update, 

stmt = update(User).where(User.name == bindparam("oldname")).values(name=bindparam("newname"))

with engine.connect() as conn:
    conn.execute(
        stmt,
        [
            {"oldname": "jack", "newname": "ed"},
            {"oldname": "wendy", "newname": "mary"},
        ],
    )
```

##### 使用其他表的数据 UPDATE

在 `values()` 设置值时使用子查询，将其他子查询的结果作为更新的值

```py
scalar_subq = (
    select(Address.email_address)
    .where(Address.user_id == user_table.c.id)
    .order_by(Address.id)
    .limit(1)
    .scalar_subquery()
)
update_stmt = update(User).values(fullname=scalar_subq)
print(update_stmt)

""" 
UPDATE user_account SET fullname=(SELECT address.email_address
FROM address
WHERE address.user_id = user_account.id ORDER BY address.id
LIMIT :param_1)
"""
```

##### UPDATE...FROM

有些数据库例如 PostgreSQL 和 MySQL 支持 `UPDATE FROM` 语法。该方法支持 `where` 子句可以添加关于其他表的限制条件。

当 `where()` 里面出现其他表就会隐式使用该语法

```py
update_stmt = (
    update(User)
    .where(User.id == Address.user_id)
    .where(Address.email_address == "patrick@aol.com")
    .values(fullname="Pat")
)
print(update_stmt)

"""  """
```

##### MySQL 支持的特性

1、**可以更新多个表**

1. 从 `sqlalchemy.dialects` 导入 `mysql`
2. `update()` 还是指定某一个表，给 `values()` 传递字典，里面包含多个表的字段
3. 调用 statement 的 compile() 方法

```py
from sqlalchemy.dialects import mysql
update_stmt = (
    update(User)
    .where(User.id == Address.user_id)
    .where(Address.email_address == "patrick@aol.com")
    .values(
        {
            User.fullname: "Pat",
            Address.email_address: "pat@aol.com",
        }
    )
)
print(update_stmt.compile(dialect=mysql.dialect()))

""" 
UPDATE user_account, address
SET address.email_address=%s, user_account.fullname=%s
WHERE user_account.id = address.user_id AND address.email_address = %s
"""
```

2、**控制更新的参数的顺序**

有时候更新的参数依赖于前面的参数的值，所以需要控制顺序

使用 `Update.ordered_values()` 接受一列 tuple 数据

```py
update_stmt = update(some_table).ordered_values(
    (some_table.c.y, 20), (some_table.c.x, some_table.c.y + 10)
)
print(update_stmt)

""" 
UPDATE some_table SET y=:y, x=(some_table.y + :y_1)
"""
```

#### DELETE 语句

```py
from sqlalchemy import delete
stmt = delete(user_table).where(user_table.c.name == "patrick")
print(stmt)

""" 
DELETE FROM user_account WHERE user_account.name = :name_1
"""
```

##### MySQL 删除多个表

```py
delete_stmt = (
    delete(user_table)
    .where(user_table.c.id == address_table.c.user_id)
    .where(address_table.c.email_address == "patrick@aol.com")
)
from sqlalchemy.dialects import mysql
print(delete_stmt.compile(dialect=mysql.dialect()))

""" 
DELETE FROM user_account USING user_account, address
WHERE user_account.id = address.user_id AND address.email_address = %s
"""
```

#### 获取 UPDATE, DELETE 语句影响的行数

通过 `excuete()` 返回的结果的 `rowcount` 属性获取

```py
with engine.begin() as conn:
    result = conn.execute(
        update(user_table)
        .values(fullname="Patrick McStar")
        .where(user_table.c.name == "patrick")
    )
    print(result.rowcount)
```

#### Using RETURNING with UPDATE, DELETE

TODO：再看

## other

### session.add() 、session.flush()

关于`add()`，`fulsh()`，`commit()`操作的作用：

`db.session.add()`、`db.session.flush()` 和 `db.session.commit()` 是 SQLAlchemy 中常用的数据库操作方法，它们通常结合使用来管理会话（Session）中的数据库事务。

- `db.session.add()`：
  - 用于将新创建或修改后的实体对象添加到当前会话中。
  - 只是将对象添加到会话的临时缓存中，并不会立即执行数据库操作。
  - 在使用 `add()` 方法后，可以继续对对象进行修改，直到调用 `flush()` 或 `commit()` 执行实际数据库操作。
- `db.session.flush()`：
  - 将当前会话中所有未提交的数据库操作（插入、更新、删除等）发送到数据库服务器执行。
  - `flush()` 方法通常在以下情况下使用：
    - 当需要在后续代码中获取插入记录的自增 `ID`（例如，MySQL 中的 `AUTO_INCREMENT`）时，可以在 `flush()` 后立即获得 `ID`。
    - 当需要立即检查数据库操作是否成功或是否有错误时，可以在 `flush()` 后查看数据库执行结果。
- `db.session.commit()`：
  - 将当前会话中的所有数据库操作提交到数据库服务器。
  - `commit()` 方法将会话中的所有操作一起作为一个事务提交到数据库。
  - 提交后，所有之前的 `flush()` 操作将永久生效，且数据库事务完成。

通常，数据库操作的基本流程是：

1. 使用 `add()` 将实体对象添加到会话中，可以在此阶段进行实体对象的初始化和修改。
2. 使用 `flush()` 提交之前的数据库操作，以便获取自增 ID 或检查执行结果。
3. 使用 `commit()` 最终将所有操作提交到数据库，实现持久化存储。

需要注意的是，在使用 `commit()` 提交事务后，会话将被清理，所有之前添加的对象和更改都会失去跟踪。所以，在一个会话中，通常只需要调用一次 `commit()`

### 使用未知值 insert 或 update

原理：使用对象存放未知值，然后遍历对象，使用 `hasattr` 判断 ORM 对象有没有该属性，有的话则使用 `setattr` 设值

insert：

```py
def insert_data(insert_data: dict = None):
    with Session(engine) as session:
        model = InsertModel()

        if not insert_data is None:
            for key, value in insert_data.items():
                if hasattr(model, key):
                    setattr(model, key, value)

        session.add(model)
        session.flush()
        new_id = copy.copy(model.id)
        session.commit()
        return new_id
```

update:

```py
def update_data(data_id, update_data: dict):
    with Session(engine) as session:
        model = session.scalar(select(UpdateModel).filter_by(id=data_id))
        for key, value in update_data.items():
            if hasattr(model, key):
                setattr(model, key, value)
        session.commit()
```
