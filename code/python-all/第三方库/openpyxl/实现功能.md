# 实现功能

- [实现功能](#实现功能)
  - [获取 sheet 单元格有数据的最大行](#获取-sheet-单元格有数据的最大行)
  - [查找值](#查找值)
  - [找单元格的 End](#找单元格的-end)
  - [插入行列](#插入行列)
  - [复制单元格的格式](#复制单元格的格式)

## 获取 sheet 单元格有数据的最大行

使用 sheet.max_row 是获取了 sheet 的最大行，但不是有数据的最大行。即有数据的最大行为 50，但是 sheet 的最大行可以为 10000

> 为什么不用 pandas 的 `dataframe` 的 `shape[0]` 获取行数？  
> （？，deepseek 说的，不知道对不对）因为 `dataframe` 的 `shape[0]` 不是准确的，如果 50 行有数据，10000 行也有数据，那么它可能返回的是 50

方案：sheet 的数据是没有规律的，所以通过分块跳跃倒叙检查

deepseek 代码：

```py
from openpyxl import load_workbook

def get_max_row_sparse(sheet, jump_step=1000, sample_cols=3):
    """
    分块跳跃检查，动态抽样部分列
    :param sheet: 工作表对象
    :param jump_step: 跳跃步长（根据文件大小调整）
    :param sample_cols: 每行随机抽样的列数（减少检查量）
    """
    max_row = sheet.max_row
    last_non_empty = 0
    
    # 第一阶段：大跳跃快速定位非空区域
    while max_row > 0:
        # 抽样检查当前行的部分列
        cols_to_check = [chr(65 + i % 26) for i in range(sample_cols)]  # 示例：检查前3列（A/B/C）
        has_value = any(
            sheet[f"{col}{max_row}"].value is not None
            for col in cols_to_check
        )
        if has_value:
            last_non_empty = max_row
            break  # 找到非空区域，停止跳跃
        max_row = max(0, max_row - jump_step)
    
    # 第二阶段：精细检查（从跳跃点向上逐行验证）
    if last_non_empty > 0:
        start_row = min(last_non_empty + jump_step, sheet.max_row) # 当前非空区域加上跳跃步长，找到更准确的最大行
        for row in range(start_row, last_non_empty, -1):
            if any(cell.value is not None for cell in sheet[row]):
                return row
        return last_non_empty
    return 0

# 启用只读模式加速
wb = load_workbook("chaotic_data.xlsx", read_only=True)
ws = wb.active

max_row = get_max_row_sparse(ws, jump_step=5000, sample_cols=5)
print("实际最大行:", max_row)
```

实际使用：

```py
def get_max_row_sparse(sheet):
    # block jump check
    jump_step = 1000
    max_row = sheet.max_row
    last_non_empty = 0

    # Phase 1: Rapid positioning of non empty areas with large jumps
    while max_row > 0:
        if max_row < 50000 and jump_step != 500:
            jump_step = 500
        if max_row < 10000 and jump_step != 10:
            jump_step = 10
        has_value = any(cell.value is not None for cell in sheet[max_row])
        if has_value:
            last_non_empty = max_row
            break
        max_row = max(0, max_row - jump_step)

    # Phase 2: Fine Inspection (Verify line by line from the jump point upwards)
    if last_non_empty > 0:
        start_row = min(last_non_empty + 1000, sheet.max_row)
        for row in range(start_row, last_non_empty, -1):
            if any(cell.value is not None for cell in sheet[row]):
                return row
        return last_non_empty
    return 0
```

## 查找值

```py
def find_value_in_excel(sheet, value_to_find: str, match_whole_word=True, match_case=True):
    if not match_case:
        value_to_find = value_to_find.lower()
    for row in range(1, sheet.max_row + 1):
        if sheet.row_dimensions[row].hidden:
            continue
        for column in range(1, sheet.max_column + 1):
            if sheet.column_dimensions[get_column_letter(column)].hidden:
                continue
            cell = sheet.cell(row, column)
            cell_value = str(cell.value)
            if not match_case:
                cell_value = cell_value.lower()
            if match_whole_word:
                if cell_value == value_to_find:
                    return cell
            elif cell_value != "None" and (cell.data_type == "s" or cell.data_type == "n"):
                if value_to_find in cell_value:
                    return cell
    return None
```

## 找单元格的 End

```py
def get_end_of_cell(sheet, row, column, direction: Direction):
    max_row = max(sheet.max_row, 1048576)
    max_column = max(sheet.max_column, 16384)
    if row > max_row or row < 1 or column > max_column or column < 1:
        return None

    end_cell = None

    match direction:
        case Direction.RIGHT:
            end_cell = get_column_end_of_cell(sheet, row, column, max_column, 1)
        case Direction.LEFT:
            end_cell = get_column_end_of_cell(sheet, row, column, 1, -1)
        case Direction.UP:
            end_cell = get_row_end_of_cell(sheet, row, column, 1, -1)
        case Direction.DOWN:
            end_cell = get_row_end_of_cell(sheet, row, column, max_row, 1)

    return end_cell


def get_row_end_of_cell(sheet, row, column, edge_row, step: int):
    end_cell = None
    if row == edge_row or row + step == edge_row:
        end_cell = sheet.cell(edge_row, column)
    elif not sheet.cell(row + step, column).value is None:
        # The adjacent cell has a value, find the first place without a value until the boundary
        for index in range(row + step, edge_row + step, step):
            if sheet.cell(index, column).value is None:
                end_cell = sheet.cell(index - step, column)
                break
    else:
        # The adjacent cell has no value. Find the first place with a value until the boundary is reached
        for index in range(row + step, edge_row + step, step):
            if not sheet.cell(index, column).value is None:
                end_cell = sheet.cell(index, column)
                break
        if end_cell is None:
            end_cell = sheet.cell(edge_row, column)
    return end_cell


def get_column_end_of_cell(sheet, row, column, edge_column, step: int):
    end_cell = None
    if column == edge_column or column + step == edge_column:
        end_cell = sheet.cell(row, edge_column)
    elif not sheet.cell(row, column + step).value is None:
        for index in range(column + step, edge_column + step, step):
            if sheet.cell(row, index).value is None:
                end_cell = sheet.cell(row, index - step)
                break
    else:
        for index in range(column + step, edge_column + step, step):
            if not sheet.cell(row, index).value is None:
                end_cell = sheet.cell(row, index)
                break
        if end_cell is None:
            end_cell = sheet.cell(row, edge_column)
    return end_cell
```

## 插入行列

worksheet 的 insert_rows 、insert_cols 并不是像 excel 那样真的插入一行或一列。

以插入行为例，它实际是将插入行后面的数据复制到它的下一行，即 n 行的数据复制到 n+1 行。所有如果有隐藏行或有 merge cell，那么单元格的数据就变得不一样

解决方法就是先取消隐藏行和对 merge cell 进行 unmerge，然后调用 insert_rows 插入行，然后再 merge 取消 merge 的 merge cell，然后再隐藏行

插入行

```py
def sheet_insert_rows(sheet, idx: int, amount: int = 1):
    # unhide row
    hidden_rows = []
    for row in range(1, sheet.max_row + 1):
        if sheet.row_dimensions[row].hidden and row > idx:
            sheet.row_dimensions[row].hidden = False
            hidden_rows.append(row)

    # unmerge cell
    merged_ranges = sheet.merged_cells.ranges
    insert_above_merged_cell_list = []
    insert_in_merge_cell_list = []
    for merged_range in merged_ranges:
        if merged_range.min_row >= idx:
            insert_above_merged_cell_list.append((merged_range.min_row, merged_range.min_col, merged_range.max_row, merged_range.max_col))
        elif merged_range.min_row < idx and merged_range.max_row >= idx:
            insert_in_merge_cell_list.append((merged_range.min_row, merged_range.min_col, merged_range.max_row, merged_range.max_col))

    for merged_range in insert_above_merged_cell_list + insert_in_merge_cell_list:
        sheet.unmerge_cells(start_row=merged_range[0], start_column=merged_range[1], end_row=merged_range[2], end_column=merged_range[3])

    sheet.insert_rows(idx, amount)

    # merge cell
    for merged_range in insert_above_merged_cell_list:
        sheet.merge_cells(
            start_row=merged_range[0] + amount, start_column=merged_range[1], end_row=merged_range[2] + amount, end_column=merged_range[3]
        )
    for merged_range in insert_in_merge_cell_list:
        sheet.merge_cells(start_row=merged_range[0], start_column=merged_range[1], end_row=merged_range[2] + amount, end_column=merged_range[3])

    # hide row
    for row in hidden_rows:
        sheet.row_dimensions[row + amount].hidden = True
```

插入列

```py
def sheet_insert_cols(sheet, idx: int, amount: int = 1):
    # unhide column
    hidden_columns = []
    for column in range(1, sheet.max_column + 1):
        if sheet.column_dimensions[get_column_letter(column)].hidden and column > idx:
            sheet.column_dimensions[get_column_letter(column)].hidden = False
            hidden_columns.append(column)

    # unmerge cell
    merged_ranges = sheet.merged_cells.ranges
    insert_above_merged_cell_list = []
    insert_in_merge_cell_list = []
    for merged_range in merged_ranges:
        if merged_range.min_col >= idx:
            insert_above_merged_cell_list.append((merged_range.min_row, merged_range.min_col, merged_range.max_row, merged_range.max_col))
        elif merged_range.min_col < idx and merged_range.max_col >= idx:
            insert_in_merge_cell_list.append((merged_range.min_row, merged_range.min_col, merged_range.max_row, merged_range.max_col))

    for merged_range in insert_above_merged_cell_list + insert_in_merge_cell_list:
        sheet.unmerge_cells(start_row=merged_range[0], start_column=merged_range[1], end_row=merged_range[2], end_column=merged_range[3])

    sheet.insert_cols(idx, amount)

    # merge cell
    for merged_range in insert_above_merged_cell_list:
        sheet.merge_cells(
            start_row=merged_range[0], start_column=merged_range[1] + amount, end_row=merged_range[2], end_column=merged_range[3] + amount
        )
    for merged_range in insert_in_merge_cell_list:
        sheet.merge_cells(start_row=merged_range[0], start_column=merged_range[1], end_row=merged_range[2], end_column=merged_range[3] + amount)

    # hide column
    for column in hidden_columns:
        sheet.column_dimensions[get_column_letter(column + amount)].hidden = True
```

## 复制单元格的格式

```py
def copy_format(target_cell, source_cell):
    target_cell.fill = copy(source_cell.fill)
    if source_cell.has_style:
        target_cell.font = copy(source_cell.font)
        target_cell.border = copy(source_cell.border)
        target_cell.fill = copy(source_cell.fill)
        target_cell.number_format = copy(source_cell.number_format)
        target_cell.protection = copy(source_cell.protection)
        target_cell.alignment = copy(source_cell.alignment)
```
